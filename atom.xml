<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kblog</title>
  
  
  <link href="http://kangqingfei.cn/atom.xml" rel="self"/>
  
  <link href="http://kangqingfei.cn/"/>
  <updated>2024-02-15T17:04:39.355Z</updated>
  <id>http://kangqingfei.cn/</id>
  
  <author>
    <name>kangqingfei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>reserve proxy by frp</title>
    <link href="http://kangqingfei.cn/2024/02/16/frp/"/>
    <id>http://kangqingfei.cn/2024/02/16/frp/</id>
    <published>2024-02-15T17:04:24.000Z</published>
    <updated>2024-02-15T17:04:39.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h2><p>在没有公网IP的情况下需要将运营商内网的服务暴露到外网访问就需要使用到反向代理。需要有一台能够被公网访问的机器，局域网内的机器主动与公网机器建立tcp连接。公网机器处理用户的请求，并把流量转发给局域网机器。这种原理与服务发现类似，而 <a href="https://github.com/fatedier/frp"><code>FRP</code></a>就优雅地实现了该功能。</p><p>frp 使用go语言编写，只有一个服务端文件和一个客户端文件加上配置文件就能快速部署，非常优雅。frp使用go语言编写，内嵌了一个 vue 的页面，方便在网页看到对应的流量转发和服务注册情况。</p><span id="more"></span><h2 id="FRP-服务端配置"><a href="#FRP-服务端配置" class="headerlink" title="FRP 服务端配置"></a>FRP 服务端配置</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">bindPort</span> = <span class="number">7100</span>  <span class="comment"># 服务端监听的端口</span></span><br><span class="line"><span class="comment"># transport.heartbeatTimeout = 90 # 默认的心跳超时时间，超过这个时间没有收到心跳认为客户端以及断开</span></span><br><span class="line"><span class="comment"># transport.tcpKeepalive = 7200 # tcp连接的保活时间，超过这个时间tcp要重新建立连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟主机端口配置</span></span><br><span class="line"><span class="attr">vhostHTTPPort</span> = <span class="number">8888</span> <span class="comment"># 可以 proxy_pass 用户请求到客户端，当客户端type 是 http 时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 鉴权配置</span></span><br><span class="line"><span class="comment"># auth.method = &quot;token&quot; # 支持 token 以及 OIDC</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;xxxxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh 跳板配置</span></span><br><span class="line"><span class="attr">sshTunnelGateway.bindPort</span> = <span class="number">2222</span> <span class="comment"># 网关端口，frp监听的，客户端ssh连接时需指定</span></span><br><span class="line"><span class="attr">sshTunnelGateway.privateKeyFile</span> = <span class="string">&quot;./ssh/id_rsa&quot;</span> <span class="comment"># ssh网关对客户端鉴权的私钥，默认为空使用自动生成的</span></span><br><span class="line"><span class="attr">sshTunnelGateway.autoGenPrivateKeyPath</span> = <span class="string">&quot;./ssh/frp_autogen_ssh_key&quot;</span> <span class="comment">#  默认是 ./.autogen_ssh_key frp自动生成的密钥文件目录</span></span><br><span class="line"><span class="attr">sshTunnelGateway.authorizedKeysFile</span> = <span class="string">&quot;./ssh/authorized_keys&quot;</span> <span class="comment"># 指定受信的公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理后台配置</span></span><br><span class="line"><span class="comment"># webServer.addr = &quot;127.0.0.1&quot; # 地址</span></span><br><span class="line"><span class="attr">webServer.port</span> = <span class="number">8880</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">webServer.user</span> = <span class="string">&quot;xxx&quot;</span> <span class="comment"># 用户名，可选</span></span><br><span class="line"><span class="attr">webServer.password</span> = <span class="string">&quot;xxx&quot;</span> <span class="comment"># 密码，可选</span></span><br></pre></td></tr></table></figure><p>所有的配置项可以参考： <a href="https://github.com/fatedier/frp/blob/dev/conf/frps_full_example.toml">https://github.com/fatedier/frp/blob/dev/conf/frps_full_example.toml</a></p><p><code>./frps -c frps.toml</code> 来启动服务端。</p><h3 id="NGINX-配置"><a href="#NGINX-配置" class="headerlink" title="NGINX 配置"></a>NGINX 配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># mobile sub domain</span><br><span class="line">upstream frps_dashboard <span class="punctuation">&#123;</span></span><br><span class="line">    server localhost<span class="punctuation">:</span><span class="number">8880</span> weight=<span class="number">5</span>;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    listen <span class="punctuation">[</span><span class="punctuation">:</span><span class="punctuation">:</span><span class="punctuation">]</span><span class="punctuation">:</span><span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">    ssl_certificate       /xxx/kangqingfei.cn.pem;</span><br><span class="line">    ssl_certificate_key  /xxx/kangqingfei.cn.key;</span><br><span class="line">    ssl_session_timeout <span class="number">1</span>d;</span><br><span class="line">    ssl_session_cache shared<span class="punctuation">:</span>MozSSL<span class="punctuation">:</span><span class="number">10</span>m;</span><br><span class="line">    ssl_session_tickets off;</span><br><span class="line"></span><br><span class="line">    ssl_protocols         TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span> TLSv1<span class="number">.3</span>;</span><br><span class="line">    ssl_ciphers           ECDHE-ECDSA-AES128-GCM-SHA256<span class="punctuation">:</span>ECDHE-RSA-AES128-GCM-SHA256<span class="punctuation">:</span>ECDHE-ECDSA-AES256-GCM-SHA384<span class="punctuation">:</span>ECDHE-RSA-AES256-GCM-SHA384<span class="punctuation">:</span>ECDHE-ECDSA-CHACHA20-POLY1305<span class="punctuation">:</span>ECDHE-RSA-CHACHA20-POLY1305<span class="punctuation">:</span>DHE-RSA-AES128-GCM-SHA256<span class="punctuation">:</span>DHE-RSA-AES256-GCM-SHA384;</span><br><span class="line">    ssl_prefer_server_ciphers off;</span><br><span class="line">    #listen <span class="number">80</span>;</span><br><span class="line">    server_name mobile.kangqingfei.cn;</span><br><span class="line">    root /usr/share/nginx/;</span><br><span class="line"></span><br><span class="line">    location = /admin/ <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-NginX-Proxy <span class="literal"><span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">        rewrite ^/admin/(.*)$ /$<span class="number">1</span> break;</span><br><span class="line">        proxy_pass http<span class="punctuation">:</span><span class="comment">//frps_dashboard;</span></span><br><span class="line">        #proxy_pass http<span class="punctuation">:</span><span class="comment">//127.0.0.1:8880/;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    location ^~ /static/ <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass http<span class="punctuation">:</span><span class="comment">//frps_dashboard;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    location ^~ /api/ <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass http<span class="punctuation">:</span><span class="comment">//frps_dashboard;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">    location / <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass http<span class="punctuation">:</span><span class="comment">//127.0.0.1:8888;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name mobile.kangqingfei.cn;</span><br><span class="line">    rewrite ^(.*)$ https<span class="punctuation">:</span><span class="comment">//$host$1 permanent;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h3><p>CentOS 8 SELinux 需要配置防火墙才能访问对应的端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先查看哪些端口被占用了</span></span><br><span class="line">firewall-cmd --permanent --list-all</span><br><span class="line"><span class="comment"># 开启端口映射并重启防火墙</span></span><br><span class="line">firewall-cmd --permanent --add-port=7100/tcp</span><br><span class="line">systemctl restart firewalld.service <span class="comment"># 或者 firewall-cmd --reload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口分配</span></span><br><span class="line">2201: mbp16</span><br><span class="line">2202: desktop macos catalina</span><br><span class="line">2203: oppo findx5 termux</span><br><span class="line">2204: desktop linux</span><br><span class="line">2205: xps13 macos catalina</span><br><span class="line">2206: rk3399_device1 ubuntu</span><br></pre></td></tr></table></figure><h2 id="FRP-客户端配置"><a href="#FRP-客户端配置" class="headerlink" title="FRP 客户端配置"></a>FRP 客户端配置</h2><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span> = <span class="string">&quot;rk3399&quot;</span> <span class="comment"># 指定客户机的名字，在管理后台会以 &#123;user&#125;.&#123;proxy&#125; 命名一条连接</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment"># 服务端的IP，也可以使用域名，例如 mobile.kangqingfei.cn</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7100</span> <span class="comment"># 服务端监听的端口</span></span><br><span class="line"><span class="attr">auth.token</span> = <span class="string">&quot;xxxx&quot;</span> <span class="comment"># 注册到服务端时需要鉴权的密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端的管理后台配置</span></span><br><span class="line"><span class="attr">webServer.addr</span> = <span class="string">&quot;192.168.2.102&quot;</span></span><br><span class="line"><span class="attr">webServer.port</span> = <span class="number">7400</span></span><br><span class="line"><span class="attr">webServer.user</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"><span class="attr">webServer.password</span> = <span class="string">&quot;admin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span>  <span class="comment"># 注册一个服务，可以注册多个</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;python web&quot;</span> <span class="comment"># 名字</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span> <span class="comment"># 协议类型</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span> <span class="comment"># 指定注册的地址，可以是局域网的其他机器</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">8000</span> <span class="comment"># 需要被反代的本地端口</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">7200</span> <span class="comment"># 服务端访问需要使用的端口，如果是0 就会使用随机分配的端口</span></span><br><span class="line"><span class="attr">customDomains</span> = [<span class="string">&quot;mobile.kangqingfei.cn&quot;</span>] <span class="comment"># 可以用来区分不同的服务</span></span><br></pre></td></tr></table></figure><p>还有一些带宽等相关配置可以参考：<a href="https://github.com/fatedier/frp/blob/dev/conf/frpc_full_example.toml">https://github.com/fatedier/frp/blob/dev/conf/frpc_full_example.toml</a> </p><p><code>./frpc -c frpc.toml</code> 来启动客户端。</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240216000432208.png@wt" alt="image-20240216000432208"></p><p>然后访问 mobile.kangqingfei.cn:7200 就能访问到局域网内的 8000 端口的python服务了</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240216000840853.png@wt" alt="image-20240216000840853"></p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240216000930878.png@wt" alt="image-20240216000930878"></p><p>同样可以用来代理ssh服务</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240216001654604.png@wt" alt="image-20240216001654604"></p><p>另外还支持反代 dns，udp， http，socket 等协议。</p><h2 id="FRP-管理后台"><a href="#FRP-管理后台" class="headerlink" title="FRP 管理后台"></a>FRP 管理后台</h2><p>客户端，主要进行配置的热更新</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240216001356268.png@wt" alt="image-20240216001356268"></p><p>服务端，主要查看当前注册的连接</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240216000620345.png@wt" alt="image-20240216000620345"></p><h2 id="FRP-实现-SSH-跳板"><a href="#FRP-实现-SSH-跳板" class="headerlink" title="FRP 实现 SSH 跳板"></a>FRP 实现 SSH 跳板</h2><p>SSH Tunnel Gateway，通常用来作为外网到内容ssh的跳板机，对连接进行审计和鉴权（例如两步验证）。这就需要客户端A拥有 到跳板机B的连接权限，再检查客户端到目标机器C的连接权限。</p><h3 id="ssh-跳板机逻辑"><a href="#ssh-跳板机逻辑" class="headerlink" title="ssh 跳板机逻辑"></a>ssh 跳板机逻辑</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网关 B配置</span></span><br><span class="line">sshTunnelGateway.bindPort = 2222</span><br><span class="line">sshTunnelGateway.privateKeyFile = <span class="string">&quot;~/.ssh/id_rsa&quot;</span> <span class="comment"># 使用向目标机器登陆的私钥，如果为空则使用autoGenPrivateKeyPath</span></span><br><span class="line">sshTunnelGateway.autoGenPrivateKeyPath = <span class="string">&quot;~/.ssh/frp_autogen_ssh_key&quot;</span> <span class="comment"># 如果privateKeyFile为空，将使用这个作为私钥发起登陆，这个也为空就自动生成</span></span><br><span class="line">sshTunnelGateway.authorizedKeysFile = <span class="string">&quot;~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure><p>被代理机器（任意小鸡）C 发起代理（开启后门）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反代tcp or ssh</span></span><br><span class="line"></span><br><span class="line">ssh -R :80:&#123;local_ip:port&#125; v0@&#123;frps_address&#125; -p &#123;frps_ssh_listen_port&#125; &#123;tcp|http|https|stcp|tcpmux&#125; --remote_port &#123;real_remote_port&#125; --proxy_name &#123;proxy_name&#125; --token &#123;frp_token&#125;</span><br><span class="line"></span><br><span class="line">ssh -R :80:localhost:22 v0@cd.kangqingfei.cn -p 2222 tcp --token xxxx  --remote_port 2206 --proxy_name rk3399  <span class="comment">#这个 v0 目前貌似没啥作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 被代理机器显示</span></span><br><span class="line">User: qingfei.kang@xxx</span><br><span class="line">ProxyName: qingfei.kang@xxx.sshtunnel-tcp-7a2c5a22</span><br><span class="line">Type: tcp</span><br><span class="line">RemoteAddress: :2201</span><br></pre></td></tr></table></figure><p>网关B登录</p><p><code>ssh -p 2201  qingfei.kang@127.0.0.1</code>  验证ok</p><p>客户端 A 登录</p><p><code>ssh  -t root@cd.kangqingfei.cn ssh -p 2201 qingfei.kang@127.0.0.1</code>   验证ok</p><p><code>ssh qingfei.kang@cd.kangqingfei.cn -p 2201</code>  直接连接，验证ok</p><h3 id="反代-http"><a href="#反代-http" class="headerlink" title="反代 http"></a>反代 http</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh -R :80:127.0.0.1:8080 v0@&#123;frp address&#125; -p 2200 http --proxy_name <span class="string">&quot;test-http&quot;</span>  --custom_domain test-http.frps.com</span><br><span class="line"></span><br><span class="line">ssh -R :80:localhost:8000 v0@cd.kangqingfei.cn -p 2222 http --token xxx   --custom_domain cd.kangqingfei.cn  <span class="comment"># 绑定域名+端口 可以用于映射不同服务，但是端口不能变</span></span><br><span class="line"></span><br><span class="line">ssh -R :80:localhost:8000 v0@cd.kangqingfei.cn -p 2222 http --token xxx   --custom_domain 127.0.0.1 <span class="comment"># 必须绑定，不然无法 proxy_pass</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;使用背景&quot;&gt;&lt;a href=&quot;#使用背景&quot; class=&quot;headerlink&quot; title=&quot;使用背景&quot;&gt;&lt;/a&gt;使用背景&lt;/h2&gt;&lt;p&gt;在没有公网IP的情况下需要将运营商内网的服务暴露到外网访问就需要使用到反向代理。需要有一台能够被公网访问的机器，局域网内的机器主动与公网机器建立tcp连接。公网机器处理用户的请求，并把流量转发给局域网机器。这种原理与服务发现类似，而 &lt;a href=&quot;https://github.com/fatedier/frp&quot;&gt;&lt;code&gt;FRP&lt;/code&gt;&lt;/a&gt;就优雅地实现了该功能。&lt;/p&gt;
&lt;p&gt;frp 使用go语言编写，只有一个服务端文件和一个客户端文件加上配置文件就能快速部署，非常优雅。frp使用go语言编写，内嵌了一个 vue 的页面，方便在网页看到对应的流量转发和服务注册情况。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="frp" scheme="http://kangqingfei.cn/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>tmux user manual</title>
    <link href="http://kangqingfei.cn/2024/02/15/tmux-manual/"/>
    <id>http://kangqingfei.cn/2024/02/15/tmux-manual/</id>
    <published>2024-02-14T18:48:24.000Z</published>
    <updated>2024-02-14T18:54:07.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户手册阅读"><a href="#用户手册阅读" class="headerlink" title="用户手册阅读"></a>用户手册阅读</h1><p>tmux 的用户手册对tmux的所有特性都有详细的介绍，每个命令和配置都可以在里面找到。主要分为下面几块，可以按需快速找到要查阅的内容</p><h3 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#DESCRIPTION">DESCRIPTION</a></h3><p> 介绍tmux基本功能</p><h3 id="DEFAULT-KEY-BINDINGS"><a href="#DEFAULT-KEY-BINDINGS" class="headerlink" title="DEFAULT KEY BINDINGS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#DEFAULT_KEY_BINDINGS">DEFAULT KEY BINDINGS</a></h3><p> 介绍默认的按键配置</p><h3 id="COMMAND-PARSING-AND-EXECUTION"><a href="#COMMAND-PARSING-AND-EXECUTION" class="headerlink" title="COMMAND PARSING AND EXECUTION"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#COMMAND_PARSING_AND_EXECUTION">COMMAND PARSING AND EXECUTION</a></h3><p> 解释命令是怎么和运行的。主要包括在终端，以及配置文件，或者绑定按键的方式来运行命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tmux set-option -g status-style <span class="built_in">bg</span>=cyan <span class="comment"># 终端直接运行命令</span></span><br><span class="line">set-option -g status-style <span class="built_in">bg</span>=cyan  <span class="comment"># 在配置文件中运行</span></span><br><span class="line">bind-key C set-option -g status-style <span class="built_in">bg</span>=cyan <span class="comment"># 绑定快捷键的方式运行</span></span><br><span class="line"><span class="comment"># set-option 是命令 -g 是选项  status-style bg=cyan 是参数</span></span><br></pre></td></tr></table></figure>  <span id="more"></span><h3 id="PARSING-SYNTAX"><a href="#PARSING-SYNTAX" class="headerlink" title="PARSING SYNTAX"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#PARSING_SYNTAX">PARSING SYNTAX</a></h3><p> 介绍命令解析的语法，每条命令以分号结束，例如 <code>$tmux neww \; splitw</code> 如果是在tmux中执行则不需要转义 <code>neww ; splitw</code></p><p> 另外还有 <code>#</code> 用于注释，而命令所需参数必须通过 <code>&#39;</code> <code>&quot;</code> 或者<code>&#123;&#125;</code> 来传递。单双引号不能跨行使用，大括号却可以。</p><h3 id="COMMANDS"><a href="#COMMANDS" class="headerlink" title="COMMANDS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#COMMANDS">COMMANDS</a></h3><p>  介绍命令支持的选项，大部分都可以支持 -t&#x2F;s 的选项，分别用来指定目标对象(target)和源对象（source）。对于目标类型的不同，参数解析的方式也不一样：</p><ul><li><p>会话 target-session ，参数解析的顺序如下：</p><ol><li><p><code>$</code> 为前缀的 sessionID</p></li><li><p>会话名称的精确匹配</p></li><li><p>会话名称的前缀匹配，注意如果加上了<code>=</code>来指定的话，只接受精确匹配</p></li><li><p>fnmatch</p></li></ol><p>如果找到单个会话，那就是目标会话。如果有多个就报错。如果没有找到，就用当前会话。如果没有当前会话就用最近用的会话。</p></li><li><p>窗口 target-window，指定源窗口或目的窗口，格式为：<code>session:window</code>，同样有解析的顺序：</p><ol><li>指定的token   例如 <code>tmux send-keys -t:&#123;last&#125; ls</code></li><li>窗口的序号</li><li>窗口的id，以<code>@</code> 引用</li><li>窗口名称的精确匹配</li><li>窗口名称的前缀匹配，如果名称前指定了<code>=</code>那么就只接受精确匹配</li><li>fnmatch</li></ol><p>窗口的匹配支持的token如下：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="keyword">start</span>&#125;       ^    The lowest-numbered <span class="keyword">window</span></span><br><span class="line">&#123;<span class="keyword">end</span>&#125;         $    The highest-numbered <span class="keyword">window</span></span><br><span class="line"><span class="built_in">&#123;last</span>&#125;        !    The<span class="built_in"> last</span> (previously current) <span class="keyword">window</span></span><br><span class="line">&#123;<span class="keyword">next</span>&#125;        +    The <span class="keyword">next</span> <span class="keyword">window</span> <span class="keyword">by</span><span class="built_in"> number</span></span><br><span class="line">&#123;<span class="keyword">previous</span>&#125;    -    The <span class="keyword">previous</span> <span class="keyword">window</span> <span class="keyword">by</span><span class="built_in"> number</span></span><br></pre></td></tr></table></figure></li><li><p>窗格，查找顺序和窗口类似的，指定语法为<code>session:window.paneindx</code> 窗格支持的token为：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Token                  Meaning</span><br><span class="line">&#123;last&#125;            !    The last (previously active) pane</span><br><span class="line">&#123;next&#125;            +    The next pane <span class="built_in">by</span> number</span><br><span class="line">&#123;previous&#125;        -    The previous pane <span class="built_in">by</span> number</span><br><span class="line">&#123;<span class="built_in">top</span>&#125;                  The <span class="built_in">top</span> pane</span><br><span class="line">&#123;<span class="built_in">bottom</span>&#125;               The <span class="built_in">bottom</span> pane</span><br><span class="line">&#123;<span class="built_in">left</span>&#125;                 The leftmost pane</span><br><span class="line">&#123;<span class="built_in">right</span>&#125;                The rightmost pane</span><br><span class="line">&#123;<span class="built_in">top</span>-<span class="built_in">left</span>&#125;             The <span class="built_in">top</span>-<span class="built_in">left</span> pane</span><br><span class="line">&#123;<span class="built_in">top</span>-<span class="built_in">right</span>&#125;            The <span class="built_in">top</span>-<span class="built_in">right</span> pane</span><br><span class="line">&#123;<span class="built_in">bottom</span>-<span class="built_in">left</span>&#125;          The <span class="built_in">bottom</span>-<span class="built_in">left</span> pane</span><br><span class="line">&#123;<span class="built_in">bottom</span>-<span class="built_in">right</span>&#125;         The <span class="built_in">bottom</span>-<span class="built_in">right</span> pane</span><br><span class="line">&#123;up-of&#125;                The pane above the active pane</span><br><span class="line">&#123;down-of&#125;              The pane below the active pane</span><br><span class="line">&#123;<span class="built_in">left</span>-of&#125;              The pane to the <span class="built_in">left</span> of the active pane</span><br><span class="line">&#123;<span class="built_in">right</span>-of&#125;             The pane to the <span class="built_in">right</span> of the active pane</span><br></pre></td></tr></table></figure><p>其中<code>+</code> <code>-</code> 可以紧跟offset的数值来指定偏移量，例如 <code>select-window -t:+2</code></p></li></ul><p>另外还有一些全局token，</p><ul><li><code>&#123;mouse&#125;</code>   <code>=</code> 表示，用来指定最近出现鼠标事件的对象</li><li><code>&#123;marked&#125;</code> <code>~</code>  表示，用来指定被标记的窗格</li></ul><p>会话，窗口，和窗格都有一个唯一的ID，会话使用 <code>$</code> 窗口使用 <code>@</code>  窗格使用 <code>%</code> ，这些ID在对象存在的生命周期内都不会改变。这些ID可以通过 <code>session_id</code> <code>window_id</code> <code>pane_id</code> 这些方式显示出来，也可以通过 <code>display-message</code>  <code>list-sessions</code> <code>list-windows</code> <code>list-panes</code> 这些命令来显示。通过快捷键 <code>i</code> 来出发<code>display-message</code> 可以看到对应的ID格式为：<code> &#123;session_id&#125;- &#123;pane_id&#125;-&#123;window_id&#125;</code></p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240128222912887.png@wt" alt="image-20240128222912887"></p><p>在一些指令后面可以指定参数用来传递给shell，例如：<code>new-window &#39;vi ~/.tmux.conf&#39;</code> 就会在打开一个新窗口的同时打开vim。</p><h3 id="CLIENTS-AND-SESSIONS"><a href="#CLIENTS-AND-SESSIONS" class="headerlink" title="CLIENTS AND SESSIONS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#CLIENTS_AND_SESSIONS">CLIENTS AND SESSIONS</a></h3><p>主要介绍 客户端（client）和会话（session）的一些常用操作，这些操作可以通过<code>list-command</code>来查看。客户端是用户的终端，必须关联到一个会话才能进行操作。客户端可以关联到同一个会话。 每个会话有一个或多个窗口。每个窗口可以关联到一个或多个会话，并由多个窗格组成。</p><p>客户端和会话支持的命令如下：</p><ul><li>attach-session</li><li>detach-client</li><li>has-session</li><li>kill-server</li><li>kill-session</li><li>list-clients</li><li>list-commands</li><li>list-sessions</li><li>lock-client</li><li>lock-session</li><li>new-session</li><li>refresh-client</li><li>rename-session</li><li>server-access</li><li>show-messages</li><li>source-file</li><li>start-server</li><li>suspend-client</li><li>switch-client</li></ul><h3 id="WINDOWS-AND-PANES"><a href="#WINDOWS-AND-PANES" class="headerlink" title="WINDOWS AND PANES"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#WINDOWS_AND_PANES">WINDOWS AND PANES</a></h3><p>每个窗口都可以由一个或多个窗格组成，默认窗口和窗格都是从<code>0</code> 开始标号的。一个窗格可以存在多个模式：</p><ul><li>复制模式，用于选定并复制窗格内的内容</li><li>查看模式，当执行的命令产生很多的输出时会进入该模式，例如：<code>list-keys</code></li><li>选择模式，用于在列表中选择条目，该模式可以通过以下命令进入：<code>choose-buffer</code> <code>choose-client </code>  <code>choose-tree</code></li></ul><p>复制模式支持两种按键绑定，通过 <code>mode-keys</code> 选项来配置 <code>copy-mode</code> 代指 emacs <code>copy-mode-vi</code> 代指 <code>vi</code>，具体快捷键可以通过<code>list-keys</code>来查看。</p><p>窗口和窗格主要支持以下的命令：</p><ul><li><code>copy-mode</code> 进入复制模式</li><li>select-layout 选定窗格布局</li><li>break-pane</li><li>capture-pane</li><li>choose-client</li><li>choose-tree</li><li>customize-mode</li><li>display-panes</li><li>find-window</li><li>join-pane</li><li>kill-pane</li><li>kill-window</li><li>last-pane</li><li>last-window</li><li>link-window</li><li>list-panes</li><li>list-windows</li><li>move-pane</li><li>move-window</li><li>new-window</li><li>next-layout</li><li>next-window</li><li>pipe-pane</li><li>previous-layout</li><li>previous-window</li><li>rename-window</li><li>resize-pane</li><li>resize-window</li><li>respawn-pane</li><li>respawn-window</li><li>rotate-window</li><li>select-layout</li><li>select-pane</li><li>select-window</li><li>split-window</li><li>swap-pane</li><li>swap-window</li><li>unlink-window</li></ul><h3 id="KEY-BINDINGS"><a href="#KEY-BINDINGS" class="headerlink" title="KEY BINDINGS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#KEY_BINDINGS">KEY BINDINGS</a></h3><ul><li>bind-key 用来配置快捷键，<code>-r</code> 表示这个按键可以重复</li><li>list-keys 列出按键配置</li><li>send-keys 向目标输入按键</li><li>send-prefix 向目标发送前缀键</li><li>unbind-key 取消绑定按键</li></ul><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#OPTIONS">OPTIONS</a></h3><p>通过选项可以配置tmux 的外观和行为，包括：server options, session options, window options, pane options。可以通过 <code>set-options</code> 来配置也可以通过<code>show-options -s|w|p </code> 来查看。</p><h3 id="HOOKS"><a href="#HOOKS" class="headerlink" title="HOOKS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#HOOKS">HOOKS</a></h3><p>钩子用于指定特定命令执行，或者状态改变之后的一些操作</p><h3 id="MOUSE-SUPPORT"><a href="#MOUSE-SUPPORT" class="headerlink" title="MOUSE SUPPORT"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#MOUSE_SUPPORT">MOUSE SUPPORT</a></h3><p>鼠标支持相关</p><h3 id="FORMATS"><a href="#FORMATS" class="headerlink" title="FORMATS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#FORMATS">FORMATS</a></h3><p>一些支持 -F 选项的命令的显示配置，可以在这里查到可以显示的内置变量，例如</p><p> <code>#T</code> 为pane的标题，<code>#P</code> 为pane的index ,<code>#D</code> 为pane的ID</p><p><code>#H</code> 为hostname <code>#S</code> 为会话名 <code>#F</code> 为窗口标记 <code>#I</code> 为窗口index <code>W</code> 为窗口名字</p><h3 id="STYLES"><a href="#STYLES" class="headerlink" title="STYLES"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#STYLES">STYLES</a></h3><p>用于指定样式，包括：</p><p> fg bg align fill list range push-default, pop-default</p><h3 id="NAMES-AND-TITLES"><a href="#NAMES-AND-TITLES" class="headerlink" title="NAMES AND TITLES"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#NAMES_AND_TITLES">NAMES AND TITLES</a></h3><p>窗口和会话有名字，只有窗格有 标题</p><h3 id="GLOBAL-AND-SESSION-ENVIRONMENT"><a href="#GLOBAL-AND-SESSION-ENVIRONMENT" class="headerlink" title="GLOBAL AND SESSION ENVIRONMENT"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#GLOBAL_AND_SESSION_ENVIRONMENT">GLOBAL AND SESSION ENVIRONMENT</a></h3><p>一些用于传递信息的变量</p><p>set-environment</p><p>show-environment</p><h3 id="STATUS-LINE"><a href="#STATUS-LINE" class="headerlink" title="STATUS LINE"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#STATUS_LINE">STATUS LINE</a></h3><p>用于显示终端状态的状态栏，支持以下符号 <code>* - # ! ~ M Z</code></p><h3 id="BUFFERS"><a href="#BUFFERS" class="headerlink" title="BUFFERS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#BUFFERS">BUFFERS</a></h3><p>剪贴板的管理</p><h3 id="MISCELLANEOUS"><a href="#MISCELLANEOUS" class="headerlink" title="MISCELLANEOUS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#MISCELLANEOUS">MISCELLANEOUS</a></h3><p>其他组件</p><h3 id="EXIT-MESSAGES"><a href="#EXIT-MESSAGES" class="headerlink" title="EXIT MESSAGES"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#EXIT_MESSAGES">EXIT MESSAGES</a></h3><p>客户端段开时的提示</p><h3 id="TERMINFO-EXTENSIONS"><a href="#TERMINFO-EXTENSIONS" class="headerlink" title="TERMINFO EXTENSIONS"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#TERMINFO_EXTENSIONS">TERMINFO EXTENSIONS</a></h3><p>一些扩展</p><h3 id="CONTROL-MODE"><a href="#CONTROL-MODE" class="headerlink" title="CONTROL MODE"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#CONTROL_MODE">CONTROL MODE</a></h3><p>应用程序控制接口</p><h3 id="ENVIRONMENT"><a href="#ENVIRONMENT" class="headerlink" title="ENVIRONMENT"></a><a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1#ENVIRONMENT">ENVIRONMENT</a></h3><p>与tmux有关的环境变量</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;用户手册阅读&quot;&gt;&lt;a href=&quot;#用户手册阅读&quot; class=&quot;headerlink&quot; title=&quot;用户手册阅读&quot;&gt;&lt;/a&gt;用户手册阅读&lt;/h1&gt;&lt;p&gt;tmux 的用户手册对tmux的所有特性都有详细的介绍，每个命令和配置都可以在里面找到。主要分为下面几块，可以按需快速找到要查阅的内容&lt;/p&gt;
&lt;h3 id=&quot;DESCRIPTION&quot;&gt;&lt;a href=&quot;#DESCRIPTION&quot; class=&quot;headerlink&quot; title=&quot;DESCRIPTION&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://man.openbsd.org/OpenBSD-current/man1/tmux.1#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; 介绍tmux基本功能&lt;/p&gt;
&lt;h3 id=&quot;DEFAULT-KEY-BINDINGS&quot;&gt;&lt;a href=&quot;#DEFAULT-KEY-BINDINGS&quot; class=&quot;headerlink&quot; title=&quot;DEFAULT KEY BINDINGS&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://man.openbsd.org/OpenBSD-current/man1/tmux.1#DEFAULT_KEY_BINDINGS&quot;&gt;DEFAULT KEY BINDINGS&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; 介绍默认的按键配置&lt;/p&gt;
&lt;h3 id=&quot;COMMAND-PARSING-AND-EXECUTION&quot;&gt;&lt;a href=&quot;#COMMAND-PARSING-AND-EXECUTION&quot; class=&quot;headerlink&quot; title=&quot;COMMAND PARSING AND EXECUTION&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://man.openbsd.org/OpenBSD-current/man1/tmux.1#COMMAND_PARSING_AND_EXECUTION&quot;&gt;COMMAND PARSING AND EXECUTION&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; 解释命令是怎么和运行的。主要包括在终端，以及配置文件，或者绑定按键的方式来运行命令：&lt;/p&gt;
  &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ tmux set-option -g status-style &lt;span class=&quot;built_in&quot;&gt;bg&lt;/span&gt;=cyan &lt;span class=&quot;comment&quot;&gt;# 终端直接运行命令&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;set-option -g status-style &lt;span class=&quot;built_in&quot;&gt;bg&lt;/span&gt;=cyan  &lt;span class=&quot;comment&quot;&gt;# 在配置文件中运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bind-key C set-option -g status-style &lt;span class=&quot;built_in&quot;&gt;bg&lt;/span&gt;=cyan &lt;span class=&quot;comment&quot;&gt;# 绑定快捷键的方式运行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# set-option 是命令 -g 是选项  status-style bg=cyan 是参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="tmux" scheme="http://kangqingfei.cn/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>tmux advance usage</title>
    <link href="http://kangqingfei.cn/2024/02/15/tmux-advance/"/>
    <id>http://kangqingfei.cn/2024/02/15/tmux-advance/</id>
    <published>2024-02-14T18:48:13.000Z</published>
    <updated>2024-02-14T18:54:47.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux-高级特性"><a href="#tmux-高级特性" class="headerlink" title="tmux 高级特性"></a>tmux 高级特性</h1><h2 id="tmux-会话组"><a href="#tmux-会话组" class="headerlink" title="tmux 会话组"></a>tmux 会话组</h2><p>tmux grouped sessions 也就是将建立的多个会话归并到同一个组，同一个组内的多个会话拥有同样的窗口（和窗口里面的pane），但各自有着不同的<strong>当前窗口</strong>，是为了解决共享同一个会话却想拥有不同当前显示窗口的问题。</p><span id="more"></span><p>我们都知道 tmux 非常利于结对编程，因为不同的客户可以看到和控制相同的界面，但是不同客户的终端尺寸是不一样的，会话会以当前输入的客户的终端作为标准尺寸，其他客户则以空白填充剩余部分。例如，当分别有一个长的终端的客户和一个拥有宽的终端的客户同时连到同一个会话时，当长客户输入时（注意激活的光标在的位置），宽客户多余的宽被空白填充；当宽用户在输入时，长用户的多余的高被空白填充。</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240115235944495.png@wt" alt="image-20240115235944495"></p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240116000151112.png@wt" alt="image-20240116000151112"></p><p>设想这样一个场景，你的老师开了一个会话，要求所有的学生都加入看他写代码，但是你觉得想自己实践一下，想切个窗口边看边写。可以按照下面的方式实现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s teacher  <span class="comment"># 老师新建一个 teacher 会话</span></span><br><span class="line">tmux new-session -t teacher -s student <span class="comment"># 新建一个 student 会话 并将两个会话合并到一个组中，组名为 teacher ，两个会话共享窗口，但是可以使用自己的当前窗口</span></span><br><span class="line">tmux a -t teacher  <span class="comment"># attach 到 teacher 会话，一心一意听老师上课</span></span><br><span class="line">tmux a -t student  <span class="comment"># attach 到 student 会话，看同班同学的骚操作</span></span><br><span class="line">tmux kill-session -t student <span class="comment"># 删除mirror 会话，但是 当前 teacher 组中还有 teacher 会话，所以窗口都不会销毁</span></span><br><span class="line">tmux kill-session -t teacher <span class="comment"># 当前组的所有会话都没有了，窗口都被销毁</span></span><br></pre></td></tr></table></figure><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240116001250488.png@wt" alt="image-20240116001250488"></p><p>需要注意的是，由于会话组其实是共享窗口，当 student 会话切到自己窗口的时候，也会影响teacher-win窗口的内容和大小。这个可以通过 <code>set aggressive-resize off</code> 来解决，但是如果student 也切到 teacher-win 时，还是会互相影响，这个无解。简单来说，配置之后，当前窗口不同则各自最大化，当前窗口相同则缩小到公共部分大小。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="控制字符"><a href="#控制字符" class="headerlink" title="控制字符"></a>控制字符</h3><p>tmux终端意外出现控制字符，表现为 tmux 命令行提示符错位，出现敲了5个字 tab 出现6个字删也删不掉的情况。例如 敲了 <code>cd</code> 结果出现  <code>ccd</code>  然后<code>c</code> 怎么也删不掉。</p><p>这个其实是zsh的问题，具体原因是：zsh需要知道命令行的宽度，才能知道哪些命令的字符被替换。它假设每个字符占据一个字符位置，除非另有说明。所以造成这个“tab补全命令出现重复字符”的主要原因是zsh错误计算了命令行的宽度。如下可能性会造成这个情况：</p><p>shell和terminal的编码不一致，导致它们对相同字符的宽度识别不一致</p><p>可以将<code>#export LANG=en.UTF-8</code>   改为 <code>export LANG=en_US.UTF-8</code> 解决这个问题</p><p>参考： <a href="https://www.cnblogs.com/fzzfsec/p/14491567.html">https://www.cnblogs.com/fzzfsec/p/14491567.html</a></p><h3 id="iterm2-直接划复制内容"><a href="#iterm2-直接划复制内容" class="headerlink" title="iterm2 直接划复制内容"></a>iterm2 直接划复制内容</h3><p>可以打开如下配置即可：</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240215005210206.png@wt" alt="image-20240215005210206"></p><h2 id="会话保存与恢复"><a href="#会话保存与恢复" class="headerlink" title="会话保存与恢复"></a>会话保存与恢复</h2><h3 id="tmux-resurrect"><a href="#tmux-resurrect" class="headerlink" title="tmux-resurrect"></a>tmux-resurrect</h3><p>tmux-resurrect 可以用来保存和恢复当前的会话，窗口，窗格的信息及布局。</p><p>安装： <code>git clone https://github.com/tmux-plugins/tmux-resurrect.git ~/tools/</code></p><p>如果会话记录被覆盖可以按照如下方式将历史备份进行恢复</p><p><code>$ cd ~/.tmux/resurrect/  找到想要的时间戳 ln -sf &lt;file_name&gt; last</code></p><p>如果想保留保留vim 会话，可以添加如下配置:</p><p><code>set -g @resurrect-strategy-vim &#39;session&#39;</code></p><p>如果想保留窗格内容，可以添加如下配置:</p><p><code>set -g @resurrect-capture-pane-contents &#39;on&#39;</code></p><h3 id="tmuxinator"><a href="#tmuxinator" class="headerlink" title="tmuxinator"></a>tmuxinator</h3><p>tmuninator 是一个通过配置文件来对窗口，窗格的布局和内容进行编排的工具。tmux-resurrect 更适合做工作现场的备份，在机器重启后快速恢复原工作环境。而tmuxinator 适合做标准化工作环境的初始化，并且适合在多台机器之间分发。</p><h4 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tmuxinator new projectName   新建一个工程，并打开工程配置</span><br><span class="line">tmuxinator open projectName  打开工程配置</span><br><span class="line">tmuxinator projectName       按照配置打开一个tmux会话</span><br><span class="line">tmuxinator doctor            检测配置文件是否有问题</span><br><span class="line">tmuxinator list              查看配置文件列表</span><br><span class="line">tmuxinator copy [EXT] [NEW]  复制配置</span><br><span class="line">tmuxinator start [PRJ] [ARG] 开启一个tmux会话</span><br></pre></td></tr></table></figure><p>默认配置文件会放在  <code>~/.config/tmuxinator</code> 下面</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/qingfei.kang/.config/tmuxinator/test.yml</span></span><br><span class="line"></span><br><span class="line">name: <span class="built_in">test</span></span><br><span class="line">root: ~/</span><br><span class="line"></span><br><span class="line"><span class="comment"># on_project_start: command</span></span><br><span class="line"><span class="comment"># on_project_first_start: command</span></span><br><span class="line"><span class="comment"># on_project_restart: command</span></span><br><span class="line"><span class="comment"># on_project_exit: command</span></span><br><span class="line"><span class="comment"># on_project_stop: command</span></span><br><span class="line"><span class="comment"># pre_window: rbenv shell 2.0.0-p247</span></span><br><span class="line"><span class="comment"># tmux_options: -f ~/.tmux.mac.conf</span></span><br><span class="line"><span class="comment"># tmux_command: byobu</span></span><br><span class="line"><span class="comment"># startup_window: editor</span></span><br><span class="line"><span class="comment"># startup_pane: 1</span></span><br><span class="line"><span class="comment"># attach: false</span></span><br><span class="line"></span><br><span class="line">windows:</span><br><span class="line">  - editor:</span><br><span class="line">      layout: main-vertical  <span class="comment"># main-horizontal</span></span><br><span class="line">      panes:</span><br><span class="line">        - git:</span><br><span class="line">          - <span class="built_in">cd</span> ~/xxx</span><br><span class="line">          - git status</span><br><span class="line">        - vim:</span><br><span class="line">          - vim</span><br><span class="line">  - build: </span><br><span class="line">    - <span class="built_in">cd</span> ~/xxx &amp;&amp; go build</span><br><span class="line">    - ./xxx</span><br><span class="line">  - logs: </span><br><span class="line">    - <span class="built_in">cd</span> ~/xxx</span><br><span class="line">    - <span class="built_in">tail</span> -f <span class="built_in">log</span>/errors.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动时打开mysql并执行查询语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">windows:</span><br><span class="line">  - api:</span><br><span class="line">      layout: main-horizontal</span><br><span class="line">      panes:</span><br><span class="line">        - test-item-db:</span><br><span class="line">          - mysql -hakssjf -pakfl</span><br><span class="line">          - use xxx_db</span><br><span class="line">          - select * from xx_tab <span class="built_in">limit</span> 1 \G</span><br></pre></td></tr></table></figure><h4 id="传递变量"><a href="#传递变量" class="headerlink" title="传递变量"></a>传递变量</h4><p>在配置文件中可以配置项目目录, 但是并不够通用, 如果项目的目录变了, 那就得重新修改项目配置文件，有如下方式可以实现变量的传递</p><ul><li>位置参数</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tmuxinator project <span class="keyword">/var/</span>www/foo</span><br><span class="line"><span class="symbol">name:</span> project</span><br><span class="line"><span class="symbol">root:</span> <span class="params">&lt;%= @args[<span class="number">0</span>] %&gt;</span> <span class="meta"># 根目录通过 arg1 传入</span></span><br></pre></td></tr></table></figure><ul><li>键值参数</li></ul><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tmuxinator project2 <span class="keyword">workspace</span>=/var/www/foo2</span><br><span class="line">name: project2</span><br><span class="line">root: &lt;%= @settings[<span class="string">&quot;workspace&quot;</span>] %&gt;</span><br></pre></td></tr></table></figure><p>参考： <a href="https://anyisalin.github.io/2017/03/06/tmuxinator/">https://anyisalin.github.io/2017/03/06/tmuxinator/</a> </p><p>参考文档： <a href="https://github.com/tmuxinator/tmuxinator#windows">https://github.com/tmuxinator/tmuxinator#windows</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tmux-高级特性&quot;&gt;&lt;a href=&quot;#tmux-高级特性&quot; class=&quot;headerlink&quot; title=&quot;tmux 高级特性&quot;&gt;&lt;/a&gt;tmux 高级特性&lt;/h1&gt;&lt;h2 id=&quot;tmux-会话组&quot;&gt;&lt;a href=&quot;#tmux-会话组&quot; class=&quot;headerlink&quot; title=&quot;tmux 会话组&quot;&gt;&lt;/a&gt;tmux 会话组&lt;/h2&gt;&lt;p&gt;tmux grouped sessions 也就是将建立的多个会话归并到同一个组，同一个组内的多个会话拥有同样的窗口（和窗口里面的pane），但各自有着不同的&lt;strong&gt;当前窗口&lt;/strong&gt;，是为了解决共享同一个会话却想拥有不同当前显示窗口的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="tmux" scheme="http://kangqingfei.cn/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>tmux basic usage</title>
    <link href="http://kangqingfei.cn/2024/02/15/tmux-basic/"/>
    <id>http://kangqingfei.cn/2024/02/15/tmux-basic/</id>
    <published>2024-02-14T18:48:06.000Z</published>
    <updated>2024-02-14T18:54:29.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux-基础"><a href="#tmux-基础" class="headerlink" title="tmux 基础"></a>tmux 基础</h1><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><p>进入 tmux 后的正常的模式，大部分的操作都在普通模式下完成。</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>tmux 的一些快捷键（省略Prefix），如果存在相同功能的原生按键，则会说明原生按键是什么。如果存在对原生按键的修改，则会在备注说明原生按键的作用。当前使用配置的前缀键为 <code>C-a</code>。</p><span id="more"></span><h4 id="窗格相关"><a href="#窗格相关" class="headerlink" title="窗格相关"></a>窗格相关</h4><table><thead><tr><th>按键</th><th>原生按键</th><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>h&#x2F;j&#x2F;k&#x2F;l</td><td>方向键</td><td>select-pane -(L&#x2F;D&#x2F;U&#x2F;R)</td><td>切换到上下左右的窗格</td><td>窗格是循环的，到顶后再往上就会落到最下面</td></tr><tr><td>H&#x2F;J&#x2F;K&#x2F;L</td><td>C-方向键</td><td>resize-pane -(L&#x2F;D&#x2F;U&#x2F;R) 1</td><td>调整窗格大小</td><td>原生按键可能会和系统按键冲突</td></tr><tr><td>|&#x2F;-</td><td>“&#x2F;%</td><td>split-window -(h&#x2F;v)</td><td>水平或垂直分割当前窗格</td><td></td></tr><tr><td></td><td>x</td><td>kill-pane</td><td>销毁当前窗格</td><td></td></tr><tr><td></td><td>z</td><td>resize-pane -Z</td><td>最大化当前窗格</td><td>再按一次取消最大化</td></tr><tr><td></td><td>!</td><td>break-pane</td><td>将当前窗格分离到一个新的窗口中</td><td></td></tr><tr><td></td><td>;</td><td>last-pane</td><td>回到上次使用窗格</td><td>只能跳回当前窗口内的上衣次使用的窗格。<br />如果是从其他窗口的窗格跳过来的是没法跳回去的</td></tr><tr><td></td><td>m</td><td>select-pane -m</td><td>标记窗格</td><td>一次只能标记一个<br />对于（当前&#x2F;标记）的窗格会有（高亮&#x2F;阴影）提示。<br />只有一条横线左边代表上面窗格。<br />只有一条竖线上面代表左边窗格</td></tr><tr><td></td><td>M</td><td>select-pane -M</td><td>取消窗格标记</td><td>重复一次<code>Prefix-m</code>也可以取消标记</td></tr><tr><td>g</td><td></td><td>swap-pane</td><td>标记窗格与当前窗格互换位置</td><td></td></tr><tr><td></td><td>q</td><td>display-panes</td><td>显示窗格的序号和大小</td><td></td></tr><tr><td></td><td>o</td><td>select-pane -t :.+</td><td>按照窗格序号跳到下一个窗格</td><td></td></tr><tr><td></td><td>c-o</td><td>rotate-window</td><td>旋转移动窗格</td><td></td></tr><tr><td></td><td>{&#x2F;}</td><td>swap-pane  -(s|D)</td><td>当前窗格与（前&#x2F;后）一序号窗格互换</td><td>序号也会随之互换</td></tr><tr><td></td><td>空格</td><td>next-layout</td><td>调节当前窗格的布局</td><td></td></tr><tr><td></td><td>E</td><td>select-layout -E</td><td>将当前窗格水平均匀分布</td><td></td></tr><tr><td></td><td>c-s</td><td>set-window-option synchronize-panes</td><td>配置各个窗格间同步输入</td><td></td></tr><tr><td>Q</td><td></td><td>clear &amp;&amp; tmux clear-history</td><td>清空窗格缓冲区内容，包括滚动条</td><td></td></tr><tr><td></td><td>f</td><td>find-window</td><td>根据内容查找窗格</td><td></td></tr></tbody></table><h4 id="窗口相关"><a href="#窗口相关" class="headerlink" title="窗口相关"></a>窗口相关</h4><table><thead><tr><th>按键</th><th>原生按键</th><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td></td><td>c</td><td>new-window</td><td>创建新的窗口</td><td></td></tr><tr><td></td><td>&amp;</td><td>kill-window</td><td>关闭当前窗口</td><td></td></tr><tr><td></td><td>数字</td><td>select-window -t :&#x3D;2</td><td>跳到对应数字的窗口</td><td></td></tr><tr><td></td><td>n</td><td>next-window</td><td>跳到下一个窗口</td><td></td></tr><tr><td></td><td>w</td><td>choose-tree -Zw</td><td>进入树模式</td><td></td></tr><tr><td></td><td>‘</td><td>select-window -t :2</td><td>跳到对应下标窗口</td><td></td></tr><tr><td></td><td>.</td><td>move-window</td><td>移动窗口到指定下标</td><td></td></tr><tr><td></td><td>,</td><td>rename-window</td><td>重命名窗口</td><td></td></tr><tr><td></td><td>i</td><td>display-message</td><td>显示窗口信息</td><td></td></tr><tr><td></td><td>~</td><td>show-messages</td><td>显示刚才的按键提示</td><td></td></tr><tr><td>b</td><td></td><td>last-window</td><td>跳到最近活跃的窗口</td><td></td></tr><tr><td>G</td><td></td><td>swap-window</td><td>标记窗口与当前窗口互换位置</td><td></td></tr></tbody></table><h4 id="会话相关"><a href="#会话相关" class="headerlink" title="会话相关"></a>会话相关</h4><table><thead><tr><th>按键</th><th>原生按键</th><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td></td><td>s</td><td>choose-tree -sZ -O name</td><td>显示会话列表</td><td>自定义为按照名称排序</td></tr><tr><td></td><td>(</td><td>switch-client -p</td><td>上一个会话</td><td></td></tr><tr><td></td><td>)</td><td>switch-client -n</td><td>下一个会话</td><td></td></tr><tr><td>B</td><td></td><td>switch-client -l</td><td>跳到上一个活跃会话</td><td></td></tr><tr><td></td><td>d</td><td></td><td>断开当前会话的关联</td><td></td></tr><tr><td></td><td>D</td><td>choose-client -Z</td><td>进入客户端模式</td><td></td></tr><tr><td></td><td>$</td><td>rename-session test-kqf</td><td>修改会话名称</td><td></td></tr></tbody></table><p>会话没有索引，但是有名称，名称是必须且唯一的，默认按照创建先后排序，可以自定义按照 会话名称排序</p><h4 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h4><table><thead><tr><th>按键</th><th>原生按键</th><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td></td><td>r</td><td></td><td>重新载入配置文件</td><td></td></tr><tr><td></td><td>&#x2F;</td><td></td><td>显示指定按键的绑定命令</td><td></td></tr><tr><td></td><td>:</td><td></td><td>进入命令行模式</td><td></td></tr><tr><td></td><td>?</td><td></td><td>显示快捷键列表</td><td></td></tr><tr><td></td><td>C</td><td></td><td>显示配置列表</td><td></td></tr><tr><td></td><td>t</td><td></td><td>显示时钟</td><td></td></tr><tr><td></td><td>&lt;</td><td></td><td>显示窗口相关的右键提示</td><td>类似于鼠标右键的功能</td></tr><tr><td></td><td>&gt;</td><td></td><td>显示窗格相关的右键提示</td><td></td></tr><tr><td></td><td>F</td><td></td><td>保存会话信息</td><td>使用插件实现</td></tr><tr><td></td><td>R</td><td></td><td>恢复会话信息</td><td>使用插件实现</td></tr></tbody></table><h3 id="使用标记"><a href="#使用标记" class="headerlink" title="使用标记"></a>使用标记</h3><p>mark 标记附加在窗格及其父窗口上面，用于对窗格或者窗口进行快速操作。例如，标记窗格与当前窗格快速互换，标记窗口和当前窗口快速互换。</p><h3 id="理解窗口符号"><a href="#理解窗口符号" class="headerlink" title="理解窗口符号"></a>理解窗口符号</h3><p>窗口名字的右边有些情况下会带上符号用于显示终端状态的状态栏，支持以下符号：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Symbol    Meaning</span><br><span class="line">*         当前窗口</span><br><span class="line">-         上一个使用的窗口</span><br><span class="line"><span class="comment">#         窗口有活跃事件</span></span><br><span class="line">!         Window bells are monitored<span class="built_in"> and </span>a bell has occurred in the window.</span><br><span class="line">~         The window has been silent for the<span class="built_in"> monitor-silence </span>interval.</span><br><span class="line">M         窗口时标记窗口</span><br><span class="line">Z         窗口中的窗格被最大化了</span><br></pre></td></tr></table></figure><p>可以配置是不是显示这部分内容 <code>set -wg window-status-format &quot;#I:#W#F&quot;</code> 配置为 Index:WindowName Flag; 如果flag太多影响专注的话可以删除 #F</p><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><p>命令行模式可以实现快捷键的所有操作，类似于把快捷键的按键重新输入一遍：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:neww -t 8 -d -n winname  <span class="comment"># 指定下标为 8  并且 不设置为当前活动窗口（后台新建） 命名为 winname</span></span><br></pre></td></tr></table></figure><h2 id="缓冲区模式"><a href="#缓冲区模式" class="headerlink" title="缓冲区模式"></a>缓冲区模式</h2><p>进入缓冲区模式后进行复制粘贴相关的操作，例如这里复制指定内容 <code>git status</code></p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240115232812451.png@wt" alt="image-20240115232812451"></p><h4 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h4><table><thead><tr><th>按键</th><th>原生按键</th><th>命令</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td></td><td>[</td><td></td><td>进入复制模式</td><td></td></tr><tr><td>v</td><td>空格</td><td></td><td>开始选择</td><td></td></tr><tr><td></td><td>Enter</td><td></td><td>复制选择内容并退出复制模式</td><td></td></tr><tr><td>y</td><td></td><td></td><td>复制选择内容</td><td></td></tr><tr><td>p</td><td>]</td><td></td><td>粘贴剪贴板内容</td><td>原生按键为上一个窗口</td></tr><tr><td></td><td>o</td><td></td><td>切换选择方向</td><td></td></tr><tr><td></td><td>q</td><td></td><td>退出缓冲区模式</td><td></td></tr><tr><td></td><td>#</td><td>list-buffer</td><td>显示buffer列表</td><td>show-buffer 只显示一条</td></tr><tr><td></td><td>&#x3D;</td><td>choose-buffer</td><td>从buffer列表中选择内容</td><td></td></tr></tbody></table><p>复制过程按住 Shift 然后便能使用鼠标进行复制粘贴，如果使用vi 的模式  可以在选择的过程中使用vi的各种快捷键  包括 <code>j w e b / :</code> 等</p><h2 id="树模式"><a href="#树模式" class="headerlink" title="树模式"></a>树模式</h2><p>树模式可以用于快速预览并跳转到指定窗格，也可以用于批量操作窗口或窗格</p><p><img src="https://qiniu.kangqingfei.cn/typora/img/image-20240204014054803.png@wt" alt="image-20240204014054803"></p><p>快捷键如下:</p><table><thead><tr><th>按键</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>上下左右(hjkl)</td><td>上下移动目标会话，左右收起展开会话</td><td></td></tr><tr><td>t</td><td>给目标打上标签</td><td>打上标签的会在索引后面带上*，<br />注意与前面名称后面的符号区分开</td></tr><tr><td>T</td><td>取消所有标签</td><td></td></tr><tr><td>c-t</td><td>标记所有目标</td><td></td></tr><tr><td>x</td><td>快速关闭目标</td><td></td></tr><tr><td>X</td><td>关闭有标签的目标</td><td></td></tr><tr><td>&lt;|&gt;</td><td>在预览内容太多一屏放不下的时候左右移动</td><td></td></tr><tr><td>O</td><td>改变排序方式</td><td></td></tr><tr><td>r</td><td>反向排序</td><td></td></tr><tr><td>v</td><td>预览目标</td><td></td></tr><tr><td>Enter</td><td>选中目标</td><td></td></tr><tr><td>m</td><td>标记目标</td><td></td></tr><tr><td>M</td><td>取消标记</td><td></td></tr><tr><td>:</td><td>对打标记的目标执行操作</td><td></td></tr><tr><td>c-s</td><td>查找目标</td><td></td></tr><tr><td>n</td><td>再次触发查找</td><td></td></tr></tbody></table><p>控制树模式的键不需要前缀。</p><h2 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h2><p>和树模式类似的，目前使用场景有限暂不研究</p><h2 id="配置文件参考"><a href="#配置文件参考" class="headerlink" title="配置文件参考"></a>配置文件参考</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ 全局设置</span></span><br><span class="line"><span class="comment"># 设置默认的shell</span></span><br><span class="line"><span class="built_in">set</span> -g default-shell /bin/zsh</span><br><span class="line"><span class="comment"># 设置前缀键</span></span><br><span class="line"><span class="built_in">set</span> -g prefix C-a</span><br><span class="line"><span class="comment"># 设置前缀键与命令键的最长的间隔</span></span><br><span class="line"><span class="built_in">set</span> -s escape-time 1000</span><br><span class="line"><span class="comment"># 设置可重复按键时 两个重复按键之间的最长重复时长 例如在调整窗口大小时</span></span><br><span class="line"><span class="built_in">set</span> -g repeat-time 1000</span><br><span class="line"><span class="comment"># 释放初始的前缀键</span></span><br><span class="line">unbind C-b</span><br><span class="line"><span class="comment"># 设置向其他应用发送 C-a 的方式为按两次 C-a</span></span><br><span class="line"><span class="built_in">bind</span> C-a send-prefix</span><br><span class="line"><span class="comment"># 设置重载配置的快捷键 其中 \; 是多个命令之间的分隔符</span></span><br><span class="line"><span class="built_in">bind</span> r source-file ~/.tmux.conf \; display <span class="string">&quot;./.tmux.conf Reloaded!&quot;</span></span><br><span class="line"><span class="comment"># 开启鼠标</span></span><br><span class="line"><span class="built_in">set</span> -g mouse on</span><br><span class="line"><span class="comment"># 设置终端为 256 色模式</span></span><br><span class="line"><span class="built_in">set</span> -g default-terminal <span class="string">&quot;screen-256color&quot;</span></span><br><span class="line"><span class="comment"># 设置快捷键模式</span></span><br><span class="line"><span class="built_in">set</span> -g mode-keys vi</span><br><span class="line"><span class="comment"># 设置窗格同步操作的快捷键</span></span><br><span class="line"><span class="built_in">bind</span> C-s set-window-option synchronize-panes</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 复制粘贴 设置</span></span><br><span class="line"><span class="comment">## 复制粘贴设置</span></span><br><span class="line"><span class="comment"># Tab -&gt; [</span></span><br><span class="line"><span class="built_in">bind</span> Tab copy-mode</span><br><span class="line"><span class="comment"># v -&gt; space</span></span><br><span class="line">bind-key -T copy-mode-vi v send-keys -X begin-selection</span><br><span class="line"><span class="comment"># y + q -&gt; Enter</span></span><br><span class="line">bind-key -T copy-mode-vi y send-keys -X copy-selection</span><br><span class="line"><span class="comment"># p -&gt; ]</span></span><br><span class="line">unbind p <span class="comment"># 将窗口的前后切换换成了粘贴</span></span><br><span class="line"><span class="built_in">bind</span> p paste-buffer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 配色设置</span></span><br><span class="line"><span class="comment"># 设置状态栏颜色</span></span><br><span class="line"><span class="built_in">set</span> -g status-style <span class="built_in">fg</span>=white,bold,<span class="built_in">bg</span>=black</span><br><span class="line"><span class="comment"># 设置窗口列表配色</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-style <span class="built_in">fg</span>=cyan,<span class="built_in">bg</span>=black</span><br><span class="line"><span class="comment"># 设置激活的窗口的颜色</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-current-style <span class="built_in">fg</span>=white,bold,<span class="built_in">bg</span>=red</span><br><span class="line"><span class="comment"># 设置 窗格的边框</span></span><br><span class="line"><span class="built_in">set</span> -wg pane-border-style <span class="built_in">fg</span>=white,<span class="built_in">bg</span>=black</span><br><span class="line"><span class="comment"># 设置激活窗格的边框</span></span><br><span class="line"><span class="built_in">set</span> -wg pane-active-border-style <span class="built_in">fg</span>=red,<span class="built_in">bg</span>=black</span><br><span class="line"><span class="comment"># 高显激活窗格模糊其它窗格</span></span><br><span class="line"><span class="built_in">set</span> -wg window-style <span class="built_in">fg</span>=colour241,<span class="built_in">bg</span>=colour235</span><br><span class="line"><span class="built_in">set</span> -wg window-active-style <span class="built_in">fg</span>=white,<span class="built_in">bg</span>=black</span><br><span class="line"><span class="comment"># 设置命令行的外观</span></span><br><span class="line"><span class="built_in">set</span> -g message-style <span class="built_in">fg</span>=white,bold,<span class="built_in">bg</span>=black</span><br><span class="line"><span class="comment"># 设置左侧状态栏的文字外观</span></span><br><span class="line"><span class="built_in">set</span> -g status-left-length 40</span><br><span class="line"><span class="built_in">set</span> -g status-left <span class="string">&quot;#[fg=colour119]#S #[fg=yellow] #W-#I #[fg=green] Pane-#P&quot;</span></span><br><span class="line"><span class="comment"># 设置右侧状态栏文字</span></span><br><span class="line"><span class="built_in">set</span> -g status-right <span class="string">&quot;#[fg=colour220]%y-%m-%d %A %R &quot;</span></span><br><span class="line"><span class="comment"># 设置状态栏刷新频率</span></span><br><span class="line"><span class="built_in">set</span> -g status-interval 60</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 窗口设置</span></span><br><span class="line"><span class="comment"># 设置窗口的起始下标是 1 而不是 0</span></span><br><span class="line"><span class="built_in">set</span> -g base-index 1</span><br><span class="line"><span class="comment"># 设置在窗口中移动的快捷键</span></span><br><span class="line"><span class="built_in">bind</span> -r C-h select-window -t :-</span><br><span class="line"><span class="built_in">bind</span> -r C-l select-window -t :+</span><br><span class="line"><span class="comment"># 设置窗口列表居中</span></span><br><span class="line"><span class="built_in">set</span> -g status-justify centre</span><br><span class="line"><span class="comment"># 允许来自其他窗口的警告</span></span><br><span class="line"><span class="built_in">set</span> -wg monitor-activity on</span><br><span class="line"><span class="built_in">set</span> -g visual-activity on</span><br><span class="line"><span class="built_in">set</span> -wg window-status-activity-style <span class="built_in">fg</span>=colour226</span><br><span class="line"><span class="comment"># 禁止窗口自动重命名</span></span><br><span class="line"><span class="built_in">set</span> -wg allow-rename off</span><br><span class="line"><span class="built_in">set</span> -wg automatic-rename off</span><br><span class="line"><span class="comment"># 设置窗口列表显示的内容</span></span><br><span class="line"><span class="built_in">set</span> -wg window-status-format <span class="string">&quot;#I:#W#F&quot;</span> <span class="comment">## 中间状态栏配置 Index :WindowName Flag; 如果flag太多影响专注的话可以删除 #F</span></span><br><span class="line"><span class="comment"># 设置窗格的起始下标是1而不是0</span></span><br><span class="line"><span class="built_in">set</span> -wg pane-base-index 1</span><br><span class="line"><span class="comment"># 设置分隔窗格的快捷键</span></span><br><span class="line"><span class="built_in">bind</span> | split-window -h</span><br><span class="line"><span class="built_in">bind</span> - split-window -v</span><br><span class="line"><span class="comment"># 设置窗格中移动的快捷键</span></span><br><span class="line"><span class="built_in">bind</span> h select-pane -L</span><br><span class="line"><span class="built_in">bind</span> j select-pane -D</span><br><span class="line"><span class="built_in">bind</span> k select-pane -U</span><br><span class="line"><span class="built_in">bind</span> l select-pane -R</span><br><span class="line"><span class="comment"># 设置重新设置窗格大小的快捷键</span></span><br><span class="line"><span class="built_in">bind</span> -r H resize-pane -L 1</span><br><span class="line"><span class="built_in">bind</span> -r J resize-pane -D 1</span><br><span class="line"><span class="built_in">bind</span> -r K resize-pane -U 1</span><br><span class="line"><span class="built_in">bind</span> -r L resize-pane -R 1</span><br><span class="line"><span class="comment"># 设置标记窗格或窗口与当前窗格或窗口互换位置快捷键</span></span><br><span class="line"><span class="built_in">bind</span> g swap-pane</span><br><span class="line"><span class="built_in">bind</span> G swap-window</span><br><span class="line"><span class="comment"># 跳到之前的窗口 l -&gt; b</span></span><br><span class="line"><span class="built_in">bind</span> b last-window</span><br><span class="line"><span class="comment"># 跳到之前的会话</span></span><br><span class="line">bind-key -n B switch-client -l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 插件配置</span></span><br><span class="line"><span class="comment">## resurrect 相关配置</span></span><br><span class="line"><span class="comment">#设置保存和恢复的快捷键</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-save <span class="string">&#x27;F&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-restore <span class="string">&#x27;R&#x27;</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-dir <span class="string">&#x27;~/tools/tmux-resurrect/resurrect/session&#x27;</span></span><br><span class="line"><span class="comment"># 保留 vim 会话</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-strategy-vim <span class="string">&#x27;session&#x27;</span></span><br><span class="line"><span class="comment"># 保存窗格内容</span></span><br><span class="line"><span class="built_in">set</span> -g @resurrect-capture-pane-contents <span class="string">&#x27;on&#x27;</span></span><br><span class="line"><span class="comment"># 使用resurrect插件</span></span><br><span class="line">run-shell ~/tools/tmux-resurrect/resurrect.tmux</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 其他配置</span></span><br><span class="line"><span class="comment"># 自定义会话排序方式</span></span><br><span class="line"><span class="built_in">bind</span> s choose-tree -sZ -O name</span><br><span class="line"><span class="comment"># 使用会话组且当前窗口不同时，各自最大化当前窗口</span></span><br><span class="line"><span class="built_in">set</span> -g aggressive-resize off</span><br><span class="line"><span class="comment"># 清除缓冲区，包括滚动条</span></span><br><span class="line">bind-key Q send-keys <span class="string">&#x27;clear &amp;&amp; tmux clear-history&#x27;</span>\; <span class="string">&#x27;Enter&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li>用户手册：<a href="https://man.openbsd.org/OpenBSD-current/man1/tmux.1">https://man.openbsd.org/OpenBSD-current/man1/tmux.1</a></li><li>会话组相关介绍： <a href="https://www.cnblogs.com/bamanzi/p/tmux-share-windows-between-sessions.html">https://www.cnblogs.com/bamanzi/p/tmux-share-windows-between-sessions.html</a></li><li>树模式相关： <a href="https://waylonwalker.com/tmux-choose-tree/">https://waylonwalker.com/tmux-choose-tree/</a></li><li><a href="https://blog.csdn.net/weixin_39510813/article/details/118660802">https://blog.csdn.net/weixin_39510813/article/details/118660802</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;tmux-基础&quot;&gt;&lt;a href=&quot;#tmux-基础&quot; class=&quot;headerlink&quot; title=&quot;tmux 基础&quot;&gt;&lt;/a&gt;tmux 基础&lt;/h1&gt;&lt;h2 id=&quot;普通模式&quot;&gt;&lt;a href=&quot;#普通模式&quot; class=&quot;headerlink&quot; title=&quot;普通模式&quot;&gt;&lt;/a&gt;普通模式&lt;/h2&gt;&lt;p&gt;进入 tmux 后的正常的模式，大部分的操作都在普通模式下完成。&lt;/p&gt;
&lt;h3 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h3&gt;&lt;p&gt;tmux 的一些快捷键（省略Prefix），如果存在相同功能的原生按键，则会说明原生按键是什么。如果存在对原生按键的修改，则会在备注说明原生按键的作用。当前使用配置的前缀键为 &lt;code&gt;C-a&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="tmux" scheme="http://kangqingfei.cn/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>4g路由器维修</title>
    <link href="http://kangqingfei.cn/2023/12/31/repair-4g-router-R102/"/>
    <id>http://kangqingfei.cn/2023/12/31/repair-4g-router-R102/</id>
    <published>2023-12-30T16:00:00.000Z</published>
    <updated>2023-12-30T17:05:14.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障表现"><a href="#故障表现" class="headerlink" title="故障表现"></a>故障表现</h2><p>之前在京东买的4G无线路由器出现了无法充电且无法开机的情况，并且插上电源连充电指示灯都不亮。</p><h2 id="设备详情"><a href="#设备详情" class="headerlink" title="设备详情"></a>设备详情</h2><p><a href="https://item.jd.com/100012899572.html">https://item.jd.com/100012899572.html</a></p><table><thead><tr><th>设备名称</th><th><strong>米攸 R102 全网通工业级CPE 家用4G无线路由器 插卡移动上网宝随身WIFI</strong></th></tr></thead><tbody><tr><td>买入价格</td><td>338.5</td></tr><tr><td>买入时间</td><td>2020-07-26</td></tr><tr><td>电池容量</td><td>6000maH</td></tr><tr><td>电源输入</td><td>12V 2A</td></tr></tbody></table><span id="more"></span><h3 id="设备相关图片"><a href="#设备相关图片" class="headerlink" title="设备相关图片"></a>设备相关图片</h3><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231226223452781.png" alt="image-20231226223452781"></p><h2 id="维修过程"><a href="#维修过程" class="headerlink" title="维修过程"></a>维修过程</h2><h3 id="1-拆机，初步了解内部电路"><a href="#1-拆机，初步了解内部电路" class="headerlink" title="1. 拆机，初步了解内部电路"></a>1. 拆机，初步了解内部电路</h3><p><img src="http://qiniu.kangqingfei.cn/typora/img/IMG20231123220218.jpg" alt="IMG20231123220218"></p><p>从图中可以看出左边三颗是以太网物理层芯片 <strong>B1601S</strong>，中间三颗分别是 </p><ul><li>2.4G wifi 芯片    <strong>MT7628</strong>  <a href="https://www.semiee.com/file2/db27bc015b8f3378e339e7234c1f97fb/MTK/MTK-MT7628.pdf">datasheet</a> ，带GPIO功能<br><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231226232023373.png" alt="image-20231226232023373"></li><li>内存芯片 <strong>Nanya-NT5TU32M16EG-ACI.pdf</strong> <a href="https://www.semiee.com/file2/c1df26728ec14d72456f7ed310f80310/Nanya/Nanya-NT5TU32M16EG-ACI.pdf">datasheet</a> DDR2 512Mb SDRAM</li><li>flash 存储芯片 winbond <strong>w25q128jvsq</strong> <a href="https://www.semiee.com/file2/31132032be95a0ed486e79001f9c8028/Winbond/Winbond-W25Q128JV.pdf">datasheet</a> 128Mbit SERIAL FLASH MEMORY SPI</li></ul><p>右上角带散热的模块是 4G LTE 模块 <strong>SIM 7600 CE</strong> <a href="https://www.semiee.com/file2/fe4118bd591abfcfe5c54cf7e01d85d9/SIMCom/SIMCom-SIM7600.pdf">datasheet</a> 支持USB 串口 SDIO</p><p>右下方未焊接的应该是预留的 5G wifi 芯片及其周围电路</p><h4 id="电源电路"><a href="#电源电路" class="headerlink" title="电源电路"></a>电源电路</h4><p>首先电源输入为12V，然后从两颗有明显型号的芯片入手分别是</p><ul><li><strong>IP3005</strong> 防止过充过放的电池保护芯片</li><li><strong>IP5108E</strong> 1A 充电芯片，并支持电量显示，可以支持3-5颗LED显示电量。芯片还集成了 5V 2A 650KHz 的的DC-DC转换器，用于输出5V电压，同时还支持按键功能：<ul><li>按键持续时间长于 30ms，但小于 2s， 即为短按动作，短按会打开电量显示灯和升压输出。 </li><li>按键持续时间长于 2s， 即为长按动作， 长按会开启或者关闭照明 LED。</li><li>小于30ms的按键动作不会有任何响应。</li><li>在 1s 内连续两次短按键，会关闭升压输出、电量显示和照明 LED</li></ul></li></ul><p>从两颗电池管理芯片加上万用表测试大概可以知道对应丝印 <strong>DDCAE</strong> 的sop-6 封装的是12V转5V的DC-DC。另外两颗丝印为<strong>ADC0G</strong>的sop-5 封装为5V转3.3V(通过flash VCC确定) DC-DC。</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231226235857056.png" alt="image-20231226235857056"></p><p>再通过万用表测试芯片的各个脚的联通大概能得到对应的连接关系</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/IMG_0170.jpeg" alt="IMG_0170"></p><p>输入12V，经过转换变成5V分别给到电池管理和4G模块的dc-dc芯片，电池管理给电池充电并提供5v输出给wifi的dc-dc芯片。wifi的dc-dc 使能管脚一直连接到高电平，只要有输出就会使能，开启转换输出3.3V，但是4G模块的使能管脚应该是连接到了 <strong>MT7628</strong>，只有当系统启动成功后才会尝试开启4G，并且系统中还可以停用&#x2F;重启4G，因此只能是这种方式实现。</p><h3 id="2-测试各个节点电压"><a href="#2-测试各个节点电压" class="headerlink" title="2. 测试各个节点电压"></a>2. 测试各个节点电压</h3><p>拆下电池发现电压低2.8v左右，明确是已经不能充电了。直接通过直流电源输出4.2V，电池的电量指示LED正常，系统正常启动，基本确定是电源电路有问题。拆掉电池测试12V转5V DC-DC 发现输出电压低，怀疑DDCAE有问题</p><h3 id="3-拆除12v转5v"><a href="#3-拆除12v转5v" class="headerlink" title="3. 拆除12v转5v"></a>3. 拆除12v转5v</h3><p>接直流电源4.2V发现可以正常启动，于是出现了第一种维修方案。<strong>放弃前置降压，直接换个电源，只输入5V电压</strong>然后将电源座子跳线到电池管理芯片的输入。经过一顿操作发现系统无法启动，于是有了第二种方案<strong>放弃电池充电电路，将电源座子直连wifi的DC-DC 5V输入</strong>，这时发现输入5V后无法出现过短暂的短路，怀疑有器件被短路了。经过一番摸摸烫大法，发现 wifi的DC-DC 发热严重，怀疑已经烧毁。</p><h3 id="4-拆除5V转3-3V"><a href="#4-拆除5V转3-3V" class="headerlink" title="4. 拆除5V转3.3V"></a>4. 拆除5V转3.3V</h3><p>直接供电3.3V，发现系统能启动但是没有4G网络，后置电路没有烧毁。事后发现是没有插天线导致没有4G网络。至此已经穷途末路，只能寄希望于替换原有芯片来修复。通过不抛弃不放弃的寻找，终于找到两颗DC-DC芯片的型号:</p><ul><li>DDCAE  <strong>RY8132</strong> 4-18V 3A 500KHz 同步 转换器，但是已经停产。<br><img src="http://qiniu.kangqingfei.cn/typora/img/iShot_2023-11-29_00.58.36.png" alt="iShot_2023-11-29_00.58.36"><ul><li>找到下一代替换产品<strong>RY9132</strong>只是升级了 ECOT 其他区别不大，外围参考电路也一致，可以替换，但是立创缺货</li><li>找到<strong>RY9132</strong>同代产品 <strong>RY9122</strong>，相比只是最高电流2A，完全够了，外围参考电路也一致，可以替换，现货，可以购买</li><li>另有同代产品 <strong>RY9133</strong>，相比只是多了PWM模式，其实也可以替换</li></ul></li><li>ADC0G   **RY3420 ** 5.5V 2A 1.2MHz 立创现货可以购买</li></ul><h3 id="5-买芯片，焊接"><a href="#5-买芯片，焊接" class="headerlink" title="5. 买芯片，焊接"></a>5. 买芯片，焊接</h3><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231227004232281.png" alt="image-20231227004232281"></p><p>验证一切OK，收工</p><h2 id="维修收获"><a href="#维修收获" class="headerlink" title="维修收获"></a>维修收获</h2><h3 id="丝印反查芯片型号"><a href="#丝印反查芯片型号" class="headerlink" title="丝印反查芯片型号"></a>丝印反查芯片型号</h3><p>对于部分体积较小的元器件在没有原理图的情况下往往不清楚其型号，如何能够找到其型号呢？主要有以下几种方法：</p><ul><li><p>常见的丝印，j3y ss34 之类的三极管或二极管的丝印</p></li><li><p>上面印有芯片产家的logo，可以通过管脚和产品目录（立创或半导小芯）大概知道，或者通过同系列产品知道</p></li><li><p>淘宝识图搜索芯片，淘宝直接搜丝印（万能的淘宝）</p></li><li><p>通过网站查询丝印，常见于通用的丝印 </p><ul><li><a href="http://www.smdmarkingcodes.com/">http://www.smdmarkingcodes.com/</a></li><li><a href="http://www.smdmark.com/">http://www.smdmark.com/</a></li></ul></li></ul><h4 id="终极方法"><a href="#终极方法" class="headerlink" title="终极方法"></a>终极方法</h4><ol><li><p>先了解芯片的作用</p></li><li><p>筛选芯片的管脚数量，封装，主要功能管脚（VCC GND EN）分布，挨个查看，特别注意pin2pin 一致的品牌</p></li><li><p>筛选品牌查看。也可以google搜品牌附加丝印可能会有不一样的效果：</p></li></ol><p><img src="http://qiniu.kangqingfei.cn/typora/img/WX20231203-223535@2x.png" alt="WX20231203-223535@2x"></p><p>注意丝印的组成，是不是只有生成年份或批次不一样，不一定要完全一致 ，例如 ADC0G 实际只有前两个是型号，后面是生产年份和和出厂编号（可以理解为批次） Lot Code</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231227004040455.png" alt="image-20231227004040455"></p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231227004016046.png" alt="image-20231227004016046"></p><p>关于生产日期的格式的解读，可以参考 <a href="https://www.sohu.com/a/514396363_120498874">https://www.sohu.com/a/514396363_120498874</a> 主要包括：</p><ul><li><strong>YYWW</strong>。指2位数年份，2位的周数，也是最易读的，9106代表1991年第6周，8412代表1984年第12周。</li><li><strong>YWW</strong>。指的是1位数年份，2位周数，上面的STM32芯片641就是YWW格式，代表2016年第41周。</li><li><strong>YMW</strong>。指1位数的年份，1位数的月份，一个月的第几周，如下的3J1，3代表1993，2003等都有可能，需要查芯片的手册。J是月份，月份和英文字母是一一对应，需要注意，没有字母I，是为了避免和数字1类似；最后一位1代表9月的第1周</li><li><strong>YM</strong>。是1位数的年份，1位数的月份，这种格式一般都是很老的芯片了。<br><img src="http://qiniu.kangqingfei.cn/typora/img/8cd5bd88a7784518892591a8582343af.png" alt="img"></li></ul><h3 id="DC-DC-芯片参数"><a href="#DC-DC-芯片参数" class="headerlink" title="DC-DC 芯片参数"></a>DC-DC 芯片参数</h3><p>DC-DC 相比于 LDO 可以支持更大的电流输出，并且通常具有更高的转换效率。输出的电压也可以自行设计待机电流也相对较低，但是带来的是更复杂的电路和更高的成本。</p><p>这是一款 dc-dc 芯片的介绍</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231230234340185.png" alt="image-20231230234340185"></p><p>通常来说DC-DC芯片可以分为转换器和控制器，控制器一般需要外挂MOS管用于电流特别大的应用。而转化器一般内部集成mos管，使用电流相对较小的场景。可以看出上述芯片属于转换器，另外可以看到这款芯片具有 4V-18v 的宽输入电压范围，支持3A的连续输出能力，mos管有500kHz的开关速率的降压(Boost 为升压)芯片。另外还有几个重要的特性包括：</p><ul><li>同步。是指使用mos管替代续流二极管，并且保证导通频率与mos开关频率保持同步，减少转换损耗。</li><li>频率。影响动态响应的速率。</li><li>ECOT。增强型COT。</li></ul><h4 id="COT"><a href="#COT" class="headerlink" title="COT"></a>COT</h4><p>Constant Off Time，即恒定关断时间。传统的电流模式DC&#x2F;DC变换器是将采样电流（红色部分）与电压反馈环路中误差放大器的输出（蓝色部分）进行比较，以生成控制MOSFET的PWM脉冲。</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231231003214135.png" alt="image-20231231003214135"></p><p>传统的这种模式相比COT动态响应会慢很多主要原因有：</p><ul><li>放大器充当了低通滤波器的作用，从而拉长了变换器对输出电压变化的响应时间</li><li>内部时钟引起的开关周期延迟，内部时钟将脉宽调制（PWM）控制反馈至输出MOSFET。在连续电流控制工作模式下，由于其控制频率是固定的，所以MOSFETs的导通时序由时钟周期决定。即使采用PWM占空比控制上管MOSFET的导通时间，在下一个时钟周期开始之前它也无法再次导通。</li></ul><p>与传统电压&#x2F;电流模式控制相比，恒定导通时间控制（COT）结构则非常简单，它通过反馈电阻来采样输出电压，然后将输出电压纹波谷值直接与参考电压进行对比，生成固定的导通时间脉冲来导通上管MOSFET。当导通时间脉冲到期后，上管MOSFET关断（且下管导通）。</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231231004220352.png" alt="image-20231231004220352"></p><p>当负载突变时，输出电压下降，当低于参考电压时会立即打开高侧开关，而不像固定频率控制中必须接收外部时钟信号的触发才开启高侧开关，在TON阶段电感电流上升，如果反馈电压仍低于参考电压，会在一个最小关断时间后再次启动新的TON，高则开关会重复这种连续开启直到输出电压和电感电流都达到预期值，这也是COT快速动态响应的来源，是通过改变开关频率来影响占空比并达到稳定输出的效果。<br><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231231004447295.png" alt="image-20231231004447295"></p><p>简单描述就是：电压低了我开一段时间，又低了我就再开一段时间，低的越快（输出越大）pwm频率越快，相当于一个变频的输出。所以这种方式也有缺点，那就是频率高了会有EMI。</p><h3 id="dc-dc-典型电路"><a href="#dc-dc-典型电路" class="headerlink" title="dc-dc 典型电路"></a>dc-dc 典型电路</h3><p>开关电源是一种高频电能转换装置，主要利用开关器件（MOSFET&#x2F;晶体管），通过周期性控制开关器件的开关，实现对输入电压的脉冲调制，实现电压变换、自动稳压功能。</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231231005831873.png" alt="image-20231231005831873"></p><p>简单来说就是通过mos管进行输出，通过LC电路储能进行维持电压和电流。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.bilibili.com/video/BV1Jv411P7Qc">开关电源原理</a></li><li><a href="https://www.monolithicpower.cn/cn/advantages-of-constant-on-time-control-in-dc-dc-converters">DC&#x2F;DC 变换器中恒定导通时间控制（COT）的优势</a></li><li><a href="https://zhuanlan.zhihu.com/p/645720726">DC-DC转换器中经常会看到COT，你知道COT是什么意思?</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;故障表现&quot;&gt;&lt;a href=&quot;#故障表现&quot; class=&quot;headerlink&quot; title=&quot;故障表现&quot;&gt;&lt;/a&gt;故障表现&lt;/h2&gt;&lt;p&gt;之前在京东买的4G无线路由器出现了无法充电且无法开机的情况，并且插上电源连充电指示灯都不亮。&lt;/p&gt;
&lt;h2 id=&quot;设备详情&quot;&gt;&lt;a href=&quot;#设备详情&quot; class=&quot;headerlink&quot; title=&quot;设备详情&quot;&gt;&lt;/a&gt;设备详情&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://item.jd.com/100012899572.html&quot;&gt;https://item.jd.com/100012899572.html&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设备名称&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;米攸 R102 全网通工业级CPE 家用4G无线路由器 插卡移动上网宝随身WIFI&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;买入价格&lt;/td&gt;
&lt;td&gt;338.5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;买入时间&lt;/td&gt;
&lt;td&gt;2020-07-26&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;电池容量&lt;/td&gt;
&lt;td&gt;6000maH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;电源输入&lt;/td&gt;
&lt;td&gt;12V 2A&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="typora" scheme="http://kangqingfei.cn/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>如何有效且高效积累知识</title>
    <link href="http://kangqingfei.cn/2023/11/22/how-to-manage-knowledge/"/>
    <id>http://kangqingfei.cn/2023/11/22/how-to-manage-knowledge/</id>
    <published>2023-11-21T16:00:00.000Z</published>
    <updated>2023-11-22T16:25:57.749Z</updated>
    
    <content type="html"><![CDATA[<p>将知识归类整理是很重要的积累成长方式，如何记录知识并归档也需要系统且科学的模式。这里梳理这个流程。</p><p>由于各类平台的发展，导致了时间和知识的碎片化，尤其是短视频推荐类的渗透极大浪费了时间。整理一下，目前获取知识主要通过搜索网页，爬优秀博主，b站，微博，rss feed，知乎，贴吧，书籍。梳理了一下，目前花费时间最多的是，微信，微博，b站，淘宝（捡硬件垃圾），股票相关。而目前获取知识的效率极其低下，大部分时间浪费在了垃圾信息中。可能的改进方法可以主要有几点：</p><ul><li>增加 neat-reader，marginNote3 等软件的使用时长，增加纸质书的阅读时长，把书籍作为主要的知识输入源，提高外文书籍阅读能力，积累英语单词量。</li><li>规范知识管理体系，形成有效的知识积累，能够及时沉淀学到的新知识，有效防止反复学习。</li><li>合理分配各类时间，防止时间被浪费。</li></ul><span id="more"></span><h2 id="知识来源"><a href="#知识来源" class="headerlink" title="知识来源"></a>知识来源</h2><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231122235451968.png" alt="image-20231122235451968"></p><p>目前的知识来源包括：</p><ul><li>历史存档数据，长期需要消化的知识</li><li>logseq 中记录的知识，及时归纳整理。平时看到的需要学习的知识及时能够通过TG发送到logseq 以记录</li><li>网页书签，平时看到的好的文章，或者是工程项目</li><li>读书笔记，看纸质书或者电纸书过程形成的读书笔记</li><li>todo，平时突然的脑洞，或者受他人启发的想法记录在TODO中，及时评估是否完成</li></ul><h2 id="知识输出"><a href="#知识输出" class="headerlink" title="知识输出"></a>知识输出</h2><p>知识输出的方式比较简单，主要是网页，因为最方便触达以及传播。另外后期可以输出视频或专题的文档。</p><p>对于网页的笔记主要是markdown格式的，通过gitbook或hexo的blog进行管理。目前有以下几个模板：</p><ul><li>读书笔记。主要包括对书籍中的重要知识点的记录，可以是分篇章输出，最后需要总结书籍的涉及的技术领域，阅读的周期，推荐的指数，</li><li>日常笔记。零散知识点或者提高效能的小工具的记录模板。</li><li>电路分析或拆解笔记。主要涉及硬件产品的电路分析或拆解刷机等内容的记录</li><li>项目笔记。一般涉及一整个完整项目的记录，可以分模块，分软件硬件输出。最后可以形成专题文档。</li></ul><h2 id="知识输出流程"><a href="#知识输出流程" class="headerlink" title="知识输出流程"></a>知识输出流程</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>很简单，直接创建markdown文档，为了适配hexo的发布，需要使用模板，主要需要添加一些meta信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">./image</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&quot;typora config pic save action&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">category:</span> <span class="string">tools</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">typora</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">## 段落标题</span></span><br><span class="line"><span class="string">内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br><span class="line"><span class="comment">### 摘要后的标题</span></span><br><span class="line"><span class="string">内容</span></span><br></pre></td></tr></table></figure><p>然后是编写文档内容，发布前需要处理一下图片，如果文章中的图片是本来就保存在本地的就需要上传到 cdn。如果本来就在cdn了，那就需要把图片保存到本地存一份备份，防止cdn厂商跑路。如果cdn厂商跑路只需要将对应的域名换成本地文件，然后重新传到新的cdn即可。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><h4 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h4><p>将之前创建文件拷贝过来即可记得目标文件需要按照 <code>yyyy-mm-dd-title</code> 的格式进行命名，比较建议一开始就在<code>hexo</code>的<code>_post</code>目录进行撰写。完成拷贝后 <code>hexo s</code> 查看效果即可，没有问题的话即可发布，先备份源文件<code>gaa &amp;&amp; gc -m &quot;add content&quot; &amp;&amp; ggp</code>,然后<code>hexo g &amp;&amp; hexo d</code> 即可发布。</p><h4 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h4><p>gitbook 是主要的大纲型知识存档方案，发布前需要先在目录中创建新文章的索引，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> [<span class="string">MacOS</span>](<span class="link">dev/mac.md</span>)</span><br><span class="line"><span class="bullet">    *</span> [<span class="string">hackintosh</span>](<span class="link">dev/mac/hackintosh.md</span>)</span><br><span class="line"><span class="bullet">      *</span> [<span class="string">opencore</span>](<span class="link">dev/mac/hackintosh/opencore.md</span>)</span><br><span class="line"><span class="bullet">        *</span> [<span class="string">opencore升级</span>](<span class="link">dev/mac/hackintosh/opencore_update.md</span>)</span><br></pre></td></tr></table></figure><p>然后运行 <code>gitbook init</code> 创建对应的文件和目录，如果新建文档的名称和目录中的文件名一致的话直接拖到对应目录覆盖新建文件即可。如果不一致的话还需要把新建的空文件删掉，并重命名为目录中文件名。需要注意如果有图片需要将图片也一并复制到对应目录。最后 <code>gitbook serve --lrport 35729 --port 4000</code> 预览效果即可。</p><p>预览没有问题即可发布： <code>gaa</code> -&gt; <code>gc -m &quot;add content&quot;</code> -&gt; <code>ggp</code> 推到github ，然后触发钩子，会有 Action 发布到vps。</p><h4 id="硬盘存档"><a href="#硬盘存档" class="headerlink" title="硬盘存档"></a>硬盘存档</h4><p>将完成的md以及对应的image文件夹整体打包放在一个父级目录并拷贝到存档文件夹</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>在文件存档目录更新，更新完将最新的文件拷贝到 gitbook 对应的目录覆盖，再拷贝到hexo目录覆盖，在重复发布步骤即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将知识归类整理是很重要的积累成长方式，如何记录知识并归档也需要系统且科学的模式。这里梳理这个流程。&lt;/p&gt;
&lt;p&gt;由于各类平台的发展，导致了时间和知识的碎片化，尤其是短视频推荐类的渗透极大浪费了时间。整理一下，目前获取知识主要通过搜索网页，爬优秀博主，b站，微博，rss feed，知乎，贴吧，书籍。梳理了一下，目前花费时间最多的是，微信，微博，b站，淘宝（捡硬件垃圾），股票相关。而目前获取知识的效率极其低下，大部分时间浪费在了垃圾信息中。可能的改进方法可以主要有几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 neat-reader，marginNote3 等软件的使用时长，增加纸质书的阅读时长，把书籍作为主要的知识输入源，提高外文书籍阅读能力，积累英语单词量。&lt;/li&gt;
&lt;li&gt;规范知识管理体系，形成有效的知识积累，能够及时沉淀学到的新知识，有效防止反复学习。&lt;/li&gt;
&lt;li&gt;合理分配各类时间，防止时间被浪费。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="note" scheme="http://kangqingfei.cn/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>github dependabot</title>
    <link href="http://kangqingfei.cn/2023/11/18/github-depenabot/"/>
    <id>http://kangqingfei.cn/2023/11/18/github-depenabot/</id>
    <published>2023-11-17T16:00:00.000Z</published>
    <updated>2023-11-17T18:26:55.223Z</updated>
    
    <content type="html"><![CDATA[<p>发现在本地执行<code>git branch -a</code> 时多了很多远程的分支，如下图：</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/202311180130588.png"></p><p>研究一番之后发现这是 <code>github</code> 自动创建的分支，并且这个 <code>dependabot</code> 是 GitHub 官方的一款依赖更新工具，拥有强大的功能，包括：</p><ol><li>当使用的依赖包中的有安全漏洞问题时给你发送通知</li><li>当使用的依赖包中的有安全漏洞问题时自动提交PR</li><li>自动拉取依赖包的最先版本，并自动提交PR</li></ol><span id="more"></span><p>可以在<code>Settings</code> -&gt; <code>Code security and analysis</code> 中看到对应的功能配置</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231118020642585.png" alt="image-20231118020642585"></p><p>我们可以看到前面几项功能并没有开启，而这里项目里面新建的分支就是对应的第三项功能。可以发现确实PR里面多了对应的条目</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231118021229351.png" alt="image-20231118021229351"></p><p>点击上面的<code>Configure</code>，可以看到对应的配置如下：</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231118020522702.png" alt="image-20231118020522702"></p><p>大概的意思就是每天会检测一遍，并限制了最多开20个PR，更多的配置选项可以参考资料3。这里我们对其没有兴趣，只想不看见那么多分支，因此只需要将 <code>open-pull-requests-limit</code> 这个字段改成 <code>0</code> 即可。</p><hr><p>参考资料：</p><ol><li><a href="https://docs.github.com/zh/enterprise-server@3.10/code-security/getting-started/dependabot-quickstart-guide">官方中文文档</a></li><li><a href="https://mmdjiji.com/2023/01/3/">GitHub 自动更新依赖</a></li><li><a href="https://m.w3cschool.cn/githubcn/githubcn-5hgb3asc.html">相关字段及配置的详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;发现在本地执行&lt;code&gt;git branch -a&lt;/code&gt; 时多了很多远程的分支，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.kangqingfei.cn/typora/img/202311180130588.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;研究一番之后发现这是 &lt;code&gt;github&lt;/code&gt; 自动创建的分支，并且这个 &lt;code&gt;dependabot&lt;/code&gt; 是 GitHub 官方的一款依赖更新工具，拥有强大的功能，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当使用的依赖包中的有安全漏洞问题时给你发送通知&lt;/li&gt;
&lt;li&gt;当使用的依赖包中的有安全漏洞问题时自动提交PR&lt;/li&gt;
&lt;li&gt;自动拉取依赖包的最先版本，并自动提交PR&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="git" scheme="http://kangqingfei.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Opencore 升级引导三系统</title>
    <link href="http://kangqingfei.cn/2023/03/12/update-opencore/"/>
    <id>http://kangqingfei.cn/2023/03/12/update-opencore/</id>
    <published>2023-03-11T16:00:00.000Z</published>
    <updated>2023-03-12T05:25:41.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencore-升级"><a href="#opencore-升级" class="headerlink" title="opencore 升级"></a>opencore 升级</h1><h2 id="当前版本备份"><a href="#当前版本备份" class="headerlink" title="当前版本备份"></a>当前版本备份</h2><p><code> sudo diskutil mount /dev/disk0s1</code> 挂载EFI分区</p><p><code>cp -rf EFI ~/Desktop/EFI_OLD</code> 备份</p><p><code>sudo diskutil umount /dev/disk0s1</code> 取消挂载</p><p><code>tree -I &quot;config_list_bak|Resources&quot; -L 3</code> 查看当前文件目录结构</p><p>其中 <code>-I</code> 表示忽略对应的文件夹 <code>-L</code> 表示最多查看的层级</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT</span><br><span class="line">│   └── BOOTx64.efi</span><br><span class="line">└── OC</span><br><span class="line">    ├── ACPI</span><br><span class="line">    │   ├── SSDT-AWAC.aml</span><br><span class="line">    │   ├── SSDT-EC-USBX.aml</span><br><span class="line">    │   ├── SSDT-PLUG.aml</span><br><span class="line">    │   ├── SSDT-PMC.aml</span><br><span class="line">    │   └── SSDT-SBUS-MCHC.aml</span><br><span class="line">    ├── Bootstrap</span><br><span class="line">    │   └── Bootstrap.efi</span><br><span class="line">    ├── Drivers</span><br><span class="line">    │   ├── HfsPlus.efi</span><br><span class="line">    │   ├── OpenCanopy.efi</span><br><span class="line">    │   └── OpenRuntime.efi</span><br><span class="line">    ├── Kexts</span><br><span class="line">    │   ├── AirportBrcmFixup.kext</span><br><span class="line">    │   ├── AppleALC.kext</span><br><span class="line">    │   ├── IntelMausi.kext</span><br><span class="line">    │   ├── Lilu.kext</span><br><span class="line">    │   ├── SMCProcessor.kext</span><br><span class="line">    │   ├── SMCSuperIO.kext</span><br><span class="line">    │   ├── USBMap.kext</span><br><span class="line">    │   ├── VirtualSMC.kext</span><br><span class="line">    │   └── WhateverGreen.kext</span><br><span class="line">    ├── OpenCore.efi</span><br><span class="line">    ├── Tools</span><br><span class="line">    │   └── OpenShell.efi</span><br><span class="line">    └── config.plist</span><br><span class="line"></span><br><span class="line">16 directories, 13 files</span><br></pre></td></tr></table></figure><p>上面主要有两个比较重要的文件，一个是 <code>config.plist</code> 记录了黑苹果的配置，一个是 <code>USBMap.kext</code> 这里面有定制USB的信息，错误的usb定制信息会导致睡眠唤醒的异常</p><p>参考文章：<a href="https://www.bugprogrammer.me/2020/05/27/Hackintosh_for_Z490_10900K.html">技嘉Z490 ELITE+i9 10900K+RX 5700 XT Hackintosh构建说明</a></p><h2 id="新版本升级"><a href="#新版本升级" class="headerlink" title="新版本升级"></a>新版本升级</h2><p>旧版本：0.6.0</p><p>新版本：0.8.8</p><p>对于小版本的升级可以使用 <a href="https://github.com/ic005k/OCAuxiliaryTools/releases">OCA工具</a> 进行直接升级，但是这里跨越的版本有点大，使用OCA后出现问题较多便使用了手工升级。</p><p>手工升级的方式就是对照新的配置模板，将旧的配置迁移到新的配置中，如果是新出现的配置就保持默认的配置就好。</p><p>升级前记得备份，如果出现u盘启动盘也无法引导的情况可以使用win的<code>diskgenius</code>把配置进行还原，再进行试错。</p><p>遇到问题，请仔细阅读<strong>官方的configuraion.pdf</strong>，所有的配置项在里面都有详细的描述。</p><p>参考文章：<a href="https://www.a7mac.com/241.html">OpenCore引导版本升级教程</a></p><h2 id="引导多个系统"><a href="#引导多个系统" class="headerlink" title="引导多个系统"></a>引导多个系统</h2><p>需要注意，最好独立按照多个系统到不同的硬盘上面进行操作，不然不同系统的引导可能会相互影响相互识别。在安装新系统时，需要将其他已经安装好的系统的硬盘物理移除了。</p><p>安装好之后就可以通过OpenShell 来获取 引导多个系统所需要的信息</p><p>主要是要找的不同系统所在硬盘的硬件描述信息。不过其实windows 会被目前版本的OC主动识别，不需要手动添加。</p><p>如果对引导的顺序有比较高的要求可以通过<a href="https://heipg.cn/tutorial/delete-opencore-unnecessary-entries.html">https://heipg.cn/tutorial/delete-opencore-unnecessary-entries.html</a> 描述的方法将win的引导屏蔽了，然后手动添加引导来排序。</p><blockquote><p>可以使用隐藏文件（对于 macOS 来说是隐藏的）.contentVisibility 来隐藏引导项。如果启动分区或引导文件目录中包含 .contentVisibility，则 OpenCore 会自动排除这个条目作为可选启动项。需要注意的是，如果该条目的 .contentVisibility 文件包含辅助条目内容（Auxiliary），则该项目会被 OpenCore 视为辅助条目</p></blockquote><p>参考文章<a href="https://kextcache.com/opencore-dualboot-guide/?amp=1">https://kextcache.com/opencore-dualboot-guide/?amp=1</a></p><h2 id="将OC替换为release版本"><a href="#将OC替换为release版本" class="headerlink" title="将OC替换为release版本"></a>将OC替换为release版本</h2><p>按照官方文档说明，只需要替换一下几个文件即可</p><ul><li>EFI&#x2F;BOOT&#x2F;<ul><li><code>BOOTx64.efi</code></li></ul></li><li>EFI&#x2F;OC&#x2F;Drivers&#x2F;<ul><li><code>OpenRuntime.efi</code></li><li><code>OpenCanopy.efi</code>(if you’re using it)</li></ul></li><li>EFI&#x2F;OC&#x2F;<ul><li><code>OpenCore.efi</code></li></ul></li></ul><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol><li><p>启动没有catalina<br>新版本有新字段会屏蔽Catalina 的引导，需要将<code>UEFI-&gt;APFS-&gt;MinDate</code> <code>UEFI-&gt;APFS-&gt;MinVersion</code>两个字段置为 <code>-1</code></p></li><li><p>启动报错，一秒后自动重启到恢复模式<br>升级对应的kext 驱动文件为最新，可以使用 OCA升级</p></li><li><p>随航功能异常，表现为能够正常连接上ipad，但是ipad一直黑屏<br>这是因为BIOS重置后核显未启用导致的，需要在BIOS中启用核显。启用核显后应该如下图所示：<img src="http://qiniu.kangqingfei.cn/typora/img/202303051418712.png" alt="0"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;opencore-升级&quot;&gt;&lt;a href=&quot;#opencore-升级&quot; class=&quot;headerlink&quot; title=&quot;opencore 升级&quot;&gt;&lt;/a&gt;opencore 升级&lt;/h1&gt;&lt;h2 id=&quot;当前版本备份&quot;&gt;&lt;a href=&quot;#当前版本备份&quot; class=&quot;headerlink&quot; title=&quot;当前版本备份&quot;&gt;&lt;/a&gt;当前版本备份&lt;/h2&gt;&lt;p&gt;&lt;code&gt; sudo diskutil mount /dev/disk0s1&lt;/code&gt; 挂载EFI分区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cp -rf EFI ~/Desktop/EFI_OLD&lt;/code&gt; 备份&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo diskutil umount /dev/disk0s1&lt;/code&gt; 取消挂载&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tree -I &amp;quot;config_list_bak|Resources&amp;quot; -L 3&lt;/code&gt; 查看当前文件目录结构&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;-I&lt;/code&gt; 表示忽略对应的文件夹 &lt;code&gt;-L&lt;/code&gt; 表示最多查看的层级&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="hackintosh" scheme="http://kangqingfei.cn/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>typora config pic save action</title>
    <link href="http://kangqingfei.cn/2022/12/11/typora-config-picture-save-action/"/>
    <id>http://kangqingfei.cn/2022/12/11/typora-config-picture-save-action/</id>
    <published>2022-12-10T16:00:00.000Z</published>
    <updated>2022-12-10T16:30:34.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typora-图片存储"><a href="#typora-图片存储" class="headerlink" title="typora 图片存储"></a>typora 图片存储</h2><p>之前在typora里面写笔记的时候是会把图片文件复制到当前文件的同级image目录，并使用<code>![xxx](image/xxx.png)</code>的方式来引用。这样做的好处是可以把不同文本引用的图片源文件保存在不同的目录方便管理和迁移，但是这样有个缺点是如果需要将写完的md发布到例如知乎，掘金等其他平台的时候就需要再操作一次图片上传。发布到自己的hexo blog 也需要重新传一次（这里我使用的是不同的bucket会导致文件重复占用存储）。所以希望的是<code>所拷即所得</code>的方式把md在不同平台的发布方式通用化。</p><span id="more"></span><h3 id="七牛云迁移"><a href="#七牛云迁移" class="headerlink" title="七牛云迁移"></a>七牛云迁移</h3><p>七牛云算是老牌的图床服务商了，第一次使用是在2015年的样子，后面hexo的blog又使用了它，并且之前提供了个性化的域名。但是之前发现自己的blog的图很多都挂了， 看了下应该是自定义域名不可用了，文件都还在。上次重新折腾了一下hexo适配了七牛云。主要需要注意的是如果是之前的文件正常都在国内的区域存储，但是自己的域名又没有备案，就没法绑定国内区域的存储。这时有两个方法，一个是给域名备案；另一个是将文件重新上传（有源文件的情况下）或者通过机房同步的方式转移到海外存储区域，例如<code>亚太-新加坡（原东南亚）</code>。</p><h3 id="typora-图床配置"><a href="#typora-图床配置" class="headerlink" title="typora 图床配置"></a>typora 图床配置</h3><p>研究了一下<code>typora</code>（主要是今天花了¥89）的图片上传组件，是支持<code>Picgo</code>这类图传应用的。而<code>Picgo</code>又是支持 七牛云，正好自己的hexo 也是使用七牛云作为插件，这里就可以实现上面的<code>所拷即所得</code>，大概的方式如下：</p><ul><li>使用 <code>typora</code> 进行文字编写，并使用图片自动上传的功能将图片传到 <code>Picgo</code> 服务，然后将链接插入md文件</li><li><code>Picgo</code>服务将图片上传到七牛云指定的 bucket </li><li>如果需要发布到其他平台只需要将源文件拷贝到指定的平台即可</li></ul><h4 id="Picgo-配置"><a href="#Picgo-配置" class="headerlink" title="Picgo 配置"></a>Picgo 配置</h4><p>Picgo 下载地址： <a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p><p>下载好安装就好，然后配置七牛云，主要是配置aksk，自定义的域名，以及自定义的路径。这里的路径其实是虚拟的路径的概念，因为目前的图片用的都是对象存储，所以所谓的路径只是文件的名称里面多了一个<code>\</code>符号而已。</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20221210232244537.png" alt="image-20221210232244537"></p><p>需要注意的是存储区域的设置，这里在七牛云没看到对应的说明，但是我看好像sdk的日志里面会提示，用提示的区域代码就好，类似下面这种<img src="http://qiniu.kangqingfei.cn/typora/img/20221210184311.png" alt="20221210184311"></p><p>配置好之后可以在typora里面选用 Picgo 作为图片上传应用，并可以测试目前服务是否正常使用。</p><p>上面说了直接上传到图床会把图片源文件都放到云服务商上面，如果服务商跑路就很危险，那么如何避免呢？这里使用了折衷的方式，就是typora对于图片的处理规则还是复制到当前目录，如果这个md文档需要在不同的地方发布的话就在发布前将文件手动点下上传。<img src="http://qiniu.kangqingfei.cn/typora/img/image-20221210235756564.png" alt="image-20221210235756564"></p><p>更多关于typora中图片的操作可以参考：<a href="https://support.typora.io/Images/">https://support.typora.io/Images/</a></p><p>值得一提的是typora还支持使用<code>YAML front matter</code>来指定图片存储的目录，对应的字段是<code>typora-root-url</code>写法可以如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">images</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">upload</span> <span class="comment"># 针对插入文件时应该执行的策略，目录地址或上传</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>YAML 可以放在文件头用来定义文件的一下 meta data，从而可以很好兼容例如 hexo 的分类及tag功能，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">YAML</span> <span class="string">Front</span> <span class="string">Matter</span></span><br><span class="line"><span class="attr">category:</span> <span class="string">how-to</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">typora.io</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">YAML</span>, <span class="string">metadata</span>, <span class="string">tags</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>另外，当将md文件导出成 pdf 或 epub 文件时，这些元信息也将被导出并使用.具体说明参考: <a href="https://support.typora.io/YAML/">https://support.typora.io/YAML/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;typora-图片存储&quot;&gt;&lt;a href=&quot;#typora-图片存储&quot; class=&quot;headerlink&quot; title=&quot;typora 图片存储&quot;&gt;&lt;/a&gt;typora 图片存储&lt;/h2&gt;&lt;p&gt;之前在typora里面写笔记的时候是会把图片文件复制到当前文件的同级image目录，并使用&lt;code&gt;![xxx](image/xxx.png)&lt;/code&gt;的方式来引用。这样做的好处是可以把不同文本引用的图片源文件保存在不同的目录方便管理和迁移，但是这样有个缺点是如果需要将写完的md发布到例如知乎，掘金等其他平台的时候就需要再操作一次图片上传。发布到自己的hexo blog 也需要重新传一次（这里我使用的是不同的bucket会导致文件重复占用存储）。所以希望的是&lt;code&gt;所拷即所得&lt;/code&gt;的方式把md在不同平台的发布方式通用化。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="typora" scheme="http://kangqingfei.cn/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>fix-problems-for-hexo-theme-yilia</title>
    <link href="http://kangqingfei.cn/2022/11/23/fix-problems-for-hexo-theme-yilia/"/>
    <id>http://kangqingfei.cn/2022/11/23/fix-problems-for-hexo-theme-yilia/</id>
    <published>2022-11-23T15:58:46.000Z</published>
    <updated>2022-12-19T14:29:24.696Z</updated>
    
    <content type="html"><![CDATA[<p>从上一篇博文（2018-03-02）到现在已经过去了将近5年的时间了。这5年里经历了秋招找工作，研究生毕业，工作，跳槽等等很多很多的事情。但是时间就像流水一样流过，没有留下任何痕迹。所以最近又重新拾起之前的blog，开始记录，不是说 好记性不如烂笔头。</p><p>作为开局，由于时间有点晚了，先记录一下怎么把blog找回来的吧。</p><span id="more"></span><p>主要解决了下面几个问题：</p><ol><li><p>放在qiniu的图传丢失，域名被废弃，这里需要去七牛重新配一下自定义域名，之前的插件也还能用，更新一下bucket和密钥就好。</p></li><li><p>主题中的js丢失，主要是有些cdn跑路了</p><ul><li><p><a href="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min">http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min</a> 这个cdn没用了，需要把对应的js下载下来，对应的链接分别是 </p><ul><li><a href="https://requirejs.org/docs/release/2.1.6/minified/require.js">https://requirejs.org/docs/release/2.1.6/minified/require.js</a></li><li><a href="https://code.jquery.com/jquery-1.9.1.min.js">https://code.jquery.com/jquery-1.9.1.min.js</a></li></ul><p>可以放到qiniu的cdn，也可以放在站内，本着主题和资源分开的考虑没有放到cdn，放在了主题的<code>/source/js/</code>目录下面。</p><p>然后还需要更改一下<code>layout/_partial/after-footer.ejs</code>文件中引入的方式：</p><ul><li><code>&lt;%- js(&#39;http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min&#39;) %&gt;</code></li></ul><p>改为</p><ul><li><code>&lt;%- js(&#39;js/jquery-1.9.1.min&#39;) %&gt;</code></li><li><code>&lt;%- js(&#39;js/require-2.1.6&#39;) %&gt;</code></li></ul></li></ul></li><li><p>卜算子的文章pv统计功能丢失了，主要原因也是cdn失效了，找一个代替的就好，修改文件<code>layout/_partial/after-footer.ejs</code></p><ul><li><p><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p><p>改为</p></li><li><p><code>&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p></li></ul></li><li><p>前进后退按钮出现了问题</p><ul><li>这个是由于解析<code>&amp;laquo</code>出现问题导致，直接把对应的字符改成<code>«</code> 以及 <code>»</code> 参考：<a href="https://wuyi2.github.io/2020/02/14/hexo-yilia%E4%B8%BB%E9%A2%98%E7%BF%BB%E9%A1%B5%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3/">博客翻页键bug</a></li></ul></li><li><p>修复了部分错别字和加载问题</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上一篇博文（2018-03-02）到现在已经过去了将近5年的时间了。这5年里经历了秋招找工作，研究生毕业，工作，跳槽等等很多很多的事情。但是时间就像流水一样流过，没有留下任何痕迹。所以最近又重新拾起之前的blog，开始记录，不是说 好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;作为开局，由于时间有点晚了，先记录一下怎么把blog找回来的吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://kangqingfei.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>c++ lambda 表达式</title>
    <link href="http://kangqingfei.cn/2018/03/02/c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://kangqingfei.cn/2018/03/02/c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2018-03-02T00:56:16.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录lambda表达式的-基本语法-以及-常见的应用场景"><a href="#记录lambda表达式的-基本语法-以及-常见的应用场景" class="headerlink" title="记录lambda表达式的 基本语法 以及 常见的应用场景"></a>记录lambda表达式的 <code>基本语法</code> 以及 <code>常见的应用场景</code></h3><span id="more"></span><h3 id="Lambda的基本形式"><a href="#Lambda的基本形式" class="headerlink" title="Lambda的基本形式"></a>Lambda的基本形式</h3><ol><li>Lambda 表达式，也叫 Lambda 函数，也就是cpp中的匿名函数。 其实就是一个匿名函数 然后返回函数的调用地址</li><li>基本语法<br><code>[ captures ] &lt;tparams&gt;(可选)(C++20) ( params ) specifiers(可选) exception attr -&gt; ret requires(可选)(C++20) &#123; body &#125;</code><br>例如<code>auto glambda = []&lt;class T&gt;(T a, auto&amp;&amp; b) &#123; return a &lt; b; &#125;;</code></li></ol><ul><li>captures 为捕获列表</li><li>tparams 提供模板形参 用于 实参 确定数据类型</li><li>params 参数列表 不允许默认参数 因此形参的个数和实参的个数一定是一样的。<br>从C++14开始，lambda表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。这就如同函数模板一样，参数要使用类型自动推断功能，只需要将其类型指定为auto，类型推断规则与函数模板一样。这里给出一个简单例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 5</span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>);  <span class="comment">// 6.0</span></span><br></pre></td></tr></table></figure></li><li>specifiers 捕获限定符 一般情况下lambda不会改变使用值捕获的变量的值，如果我们想改变这个值，那么我们必须在参数列表后面跟上关键词mutable</li><li>exception 异常规定</li><li>attr 指定运算符 () 的属性 可以是 <code>const</code> <code>auto &amp; </code> 之类的指定符</li><li>ret requires 返回类型 若缺失，则由函数的 return 语句所隐含（或若函数不返回任何值则为 void ）<br>const lambda 声明：<br><code>[ captures ] ( params ) -&gt; ret &#123; body &#125;</code><br>省略返回值：<br><code>[ captures ] ( params ) &#123; body &#125;</code><br>省略参数列表<br><code>[ captures ] &#123; body &#125;</code></li></ul><p>举几个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br><span class="line">[](<span class="type">int</span>&amp; x) &#123; ++x; &#125;   <span class="comment">// 没有return语句 -&gt; lambda 函数的返回类型是&#x27;void&#x27;</span></span><br><span class="line">[]() &#123; ++global_x; &#125;  <span class="comment">// 没有参数,仅访问某个全局变量</span></span><br><span class="line">[]&#123; ++global_x; &#125;     <span class="comment">// 与上一个相同,省略了()</span></span><br></pre></td></tr></table></figure><h3 id="Lambda-的捕获"><a href="#Lambda-的捕获" class="headerlink" title="Lambda 的捕获"></a>Lambda 的捕获</h3><p>在Lambda中是可以使用局部形参以及全局变量的，但是试图使用任何未捕获的外部变量都是错误的。<br>为此，我们可以使用捕获列表来捕获外部的局部变量并用于lambda中，形式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//未定义变量.试图在Lambda内使用任何外部变量都是错误的.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x 按值捕获, y 按引用捕获 x y 都是外部的函数的局部变量名</span></span><br><span class="line">[&amp;]       <span class="comment">//用到的任何外部变量都隐式按引用捕获</span></span><br><span class="line">[=]       <span class="comment">//用到的任何外部变量都隐式按值捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x显式地按值捕获. 其它变量按引用捕获</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z按引用捕获. 其它变量按值捕获</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; some_list;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) some_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">std::for_each(<span class="built_in">begin</span>(some_list), <span class="built_in">end</span>(some_list), [&amp;total](<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    total += x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;记录lambda表达式的-基本语法-以及-常见的应用场景&quot;&gt;&lt;a href=&quot;#记录lambda表达式的-基本语法-以及-常见的应用场景&quot; class=&quot;headerlink&quot; title=&quot;记录lambda表达式的 基本语法 以及 常见的应用场景&quot;&gt;&lt;/a&gt;记录lambda表达式的 &lt;code&gt;基本语法&lt;/code&gt; 以及 &lt;code&gt;常见的应用场景&lt;/code&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="cpp" scheme="http://kangqingfei.cn/tags/cpp/"/>
    
    <category term="lambda" scheme="http://kangqingfei.cn/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>C++初始化</title>
    <link href="http://kangqingfei.cn/2018/03/01/C-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://kangqingfei.cn/2018/03/01/C-%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2018-03-01T06:45:15.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>默认初始化<br>  这是在不使用初始化器构造变量时执行的初始化</p></li><li><p>使用初始化器进行初始化<br>  按照语境，初始化器可以调用：</p></li><li><p>值初始化，例如 std::string s{};<br>  这是在变量以空初始化器构造时进行的初始化。</p></li><li><p>直接初始化，例如 std::string s(“hello”);<br>  从构造函数参数的显式集合初始化对象</p><span id="more"></span></li><li><p>复制初始化，例如 std::string s &#x3D; “hello”;<br>  从另一对象初始化对象</p></li><li><p>列表初始化，例如 std::string s{‘a’, ‘b’, ‘c’};<br>  从花括号初始化器列表初始化对象</p></li><li><p>聚合初始化，例如 char a[3] &#x3D; {‘a’, ‘b’};<br>  从花括号初始化器列表初始化聚合体<br>聚合初始化是一种初始化聚合体的列表初始化</p></li><li><p>引用初始化，例如 char&amp; c &#x3D; a[0];<br>  绑定引用到对象<br>  包括左值引用的初始化和右值引用的初始化</p></li><li><p>静态初始化</p></li></ul><ol><li>若受允许，则首先发生常量初始化（这些情形见常量初始化）。 实践上，常量初始化通常在编译期进行，而预计算的对象表示作为程序映像的一部分存储。若编译器没有这么做，则亦保证此初始化发生先于任何动态初始化。</li><li>对于所有其他 非局部 静态 及 线程局域变量 ，发生零初始化。 实现中，要被零初始化的变量置于程序映像的 .bss 段，它不占据磁盘空间，并在加载程序时为操作系统以零填充。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">&#125;; <span class="comment">// 隐式默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T2</span>(<span class="type">const</span> T2&amp;) &#123; &#125; <span class="comment">// 用户提供的复制构造函数</span></span><br><span class="line">&#125;;                    <span class="comment">// 无默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T3</span>() &#123; &#125; <span class="comment">// 用户提供的默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> n)</span> : mem(n) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1; <span class="comment">// 静态非类，进行二段初始化： 1) 零初始化初始化 n 为零  2) 默认初始化不做任何事，令 n 为零</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//// 默认初始化  一般是定义变量后未进行任何的操作则触发</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i11; <span class="comment">// 默认初始化 非类 值不确定</span></span><br><span class="line">    <span class="type">int</span>* a11 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 数组 =&gt; 每个元素 默认初始化 每个元素的值为不确定</span></span><br><span class="line">    string str11; <span class="comment">// 默认初始化 类，调用默认构造函数，值是 &quot;&quot; （空字符串）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  int&amp; r;           // 错误：引用</span></span><br><span class="line">    <span class="comment">//  const int n;      // 错误： const 的非类 必须初始化</span></span><br><span class="line">    <span class="comment">//  const T1 t1;      // 错误： const 类带隐式默认构造函数 无法初始化 必须用户提供显式默认构造函数</span></span><br><span class="line"></span><br><span class="line">    T1 t11; <span class="comment">// 类：调用隐式默认构造函数 t1.mem1 值初始化为未确定</span></span><br><span class="line">    <span class="type">const</span> T3 t13;  <span class="comment">// const 类，调用用户提供的默认构造函数 t3.mem1 被默认初始化（为不确定值）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 值初始化 有 () &#123;&#125; 两种空括号形式会触发 值初始化</span></span><br><span class="line">    <span class="type">int</span> n&#123;&#125;;                <span class="comment">// 标量 =&gt; 零初始化，值为 0</span></span><br><span class="line">    <span class="type">double</span> f = <span class="built_in">double</span>();    <span class="comment">// 标量 =&gt; 零初始化，值为 0.0</span></span><br><span class="line">    <span class="type">int</span>* a21 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">// 数组 =&gt; 每个元素的值初始化 每个元素的值为 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    T1 t21&#123;&#125;;                <span class="comment">// 有隐式默认构造函数的类 =&gt; t1.mem1 被零初始化，值为 0  t1.mem2 被默认初始化，值为 &quot;&quot;</span></span><br><span class="line">    <span class="comment">//  T2 t22&#123;&#125;;            // 错误：类无默认构造函数</span></span><br><span class="line">    T3 t23&#123;&#125;;                <span class="comment">// 有用户提供默认构造函数的类 =&gt; t3.mem1 被默认初始化为不确定值  t3.mem2 被默认初始化，值为 &quot;&quot;</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v21</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 值初始化每个元素 每个元素的值为 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 直接初始化 直接调用构造函数的形式会触发直接初始化 以 object(kkk) new object(kkk) object():men(kkk)（构造函数初始化器列表） [arg]()&#123;&#125; 等形式触发</span></span><br><span class="line">    <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>; <span class="comment">// 自 const char* 的构造函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK ：允许 explicit 构造函数</span></span><br><span class="line">    <span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // 错误：构造函数为 explicit</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// f 被直接初始化： 构造函数参数 n 从右值 2 复制初始化  f.mem 从参数 n 直接初始化</span></span><br><span class="line">    <span class="comment">//  Foo f2 = 2; // 错误：构造函数为 explicit 会阻止复制初始化的发生</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 复制初始化 以（ 等号 传参 抛出异常 返回值 ）的形式用一个对象初始化另一个对象</span></span><br><span class="line">    <span class="comment">//// explicit 可以禁止复制初始化的发生</span></span><br><span class="line">    <span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // 错误：unique_ptr 构造函数为 explicit 试图进行复制初始化</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK ：直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 列表初始化  以花括号的形式触发 一般触发列表初始化后 会触发 复制初始化( obj ttt=&#123;kkk&#125; )或者是值初始化( obj(&#123;kkk&#125;) )</span></span><br><span class="line">    <span class="type">double</span> d = <span class="type">double</span>&#123;<span class="number">1.2</span>&#125;; <span class="comment">// 临时量的列表初始化，然后复制初始化</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123; <span class="comment">// 嵌套列表初始化</span></span><br><span class="line">      &#123;<span class="number">1</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125; &#125;,</span><br><span class="line">      &#123;<span class="number">3</span>, s1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认初始化&lt;br&gt;  这是在不使用初始化器构造变量时执行的初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用初始化器进行初始化&lt;br&gt;  按照语境，初始化器可以调用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;值初始化，例如 std::string s{};&lt;br&gt;  这是在变量以空初始化器构造时进行的初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接初始化，例如 std::string s(“hello”);&lt;br&gt;  从构造函数参数的显式集合初始化对象&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="cpp" scheme="http://kangqingfei.cn/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题解</title>
    <link href="http://kangqingfei.cn/2018/02/28/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/"/>
    <id>http://kangqingfei.cn/2018/02/28/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/</id>
    <published>2018-02-28T01:28:23.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指Offer刷题-链接"><a href="#剑指Offer刷题-链接" class="headerlink" title="剑指Offer刷题 链接"></a>剑指Offer刷题 <a href="https://www.nowcoder.com/ta/coding-interviews?page=1">链接</a></h2><h3 id="共66题-历时-2018-02-28-2018-03-01-共2天"><a href="#共66题-历时-2018-02-28-2018-03-01-共2天" class="headerlink" title="共66题 历时 2018.02.28-2018.03.01 共2天"></a>共66题 历时 2018.02.28-2018.03.01 共2天</h3><span id="more"></span><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.28</p><ol><li><p>二维数组中的查找 较为简单<br>类似于二分的思路，先找到中间的数（广义中位数），然后每次缩小一大块空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> line = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(line == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> row = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = line - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; array[i][j])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>替换空格<br>从尾部进行处理以防止头部数据被覆盖 简单字符串处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> nonspace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *tmp = str;</span><br><span class="line">    <span class="keyword">while</span>(*tmp != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            nonspace++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(str+i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span><span class="number">-2</span>) = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span><span class="number">-1</span>) = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span>) = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            nonspace--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *(str+nonspace*<span class="number">2</span>+i) = *(str+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从尾到头打印链表<br>简单递归处理链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; re;</span><br><span class="line">    <span class="built_in">printList</span>(head,re);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode *node,vector&lt;<span class="type">int</span> &gt; &amp;re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printList</span>(node-&gt;next,re);</span><br><span class="line">    re.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重建二叉树<br>中等难度的 递归问题，记得划分子问题的时候，子问题的解决方法应该与原问题一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//// 记住 递归类的问题的子问题一定是与原问题给出的信息等价 也就是 子问题与原问题完全一致</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">reCon</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin, <span class="type">int</span> pLeft, <span class="type">int</span> pRight, <span class="type">int</span> vStart, <span class="type">int</span> vEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pLeft &gt; pRight || vStart &gt; vEnd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;pLeft&lt;&lt;&quot; &quot;&lt;&lt;pRight&lt;&lt;&quot; &quot;&lt;&lt;vStart&lt;&lt;&quot; &quot;&lt;&lt;vEnd&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[pLeft]);</span><br><span class="line">    <span class="keyword">if</span>(pLeft == pRight || vStart == vEnd)<span class="comment">//到达叶子节点,不需要寻找左右节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = vStart; i &lt;= vEnd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[pLeft] == vin[i])<span class="comment">// 找到在中序遍历中的下标进行划分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">reCon</span>(pre,vin,pLeft+<span class="number">1</span>,pLeft+count,vStart,vStart+count<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">reCon</span>(pre,vin,pLeft+count+<span class="number">1</span>,pRight,vStart+count+<span class="number">1</span>,vEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">    TreeNode* root = <span class="built_in">reCon</span>(pre,vin,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,vin.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; pre = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; vin = &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">reConstructBinaryTree</span>(pre,vin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>用两个栈实现队列<br>简单的栈处理 一个用于push 一个用于pop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>旋转数组的最小数字<br>简单的二分思想的运用，当一个序列可以用函数的单调性来描述的时候就会使用二分<br>但是要注意单调不减 所以注意等号的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rArr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end - start &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rArr[start],rArr[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(rArr[middle] &gt;= rArr[start] &amp;&amp; rArr[middle] &gt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rArr,middle,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rArr[middle] &lt;= rArr[start] &amp;&amp; rArr[middle] &lt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rArr,start,middle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rArr[middle] &lt;= rArr[start] &amp;&amp; rArr[middle] &gt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> rArr[middle];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rotateArray,<span class="number">0</span>,rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列<br>非常简单的递归转动态规划(或迭代)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> tmp;</span><br><span class="line">   <span class="keyword">while</span>(i++ &lt;= n)</span><br><span class="line">   &#123;</span><br><span class="line">       tmp = f2;</span><br><span class="line">       f2 = f1 + f2;</span><br><span class="line">       f1 = tmp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>跳台阶<br>上题的变种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tmp, index = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(index++ &lt;= number)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = f2;</span><br><span class="line">        f2 = f1+f2;</span><br><span class="line">        f1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变态跳台阶<br>数学归纳法找规律的题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,number<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩形覆盖<br>斐波那契数列变种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> tmp,f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt;= number)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = f2;</span><br><span class="line">            f2 = f1+f2;</span><br><span class="line">            f1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二进制中1的个数<br>简单的数值处理 记得有负数不能用移位然后与1与的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(n)</span><br><span class="line">     &#123;</span><br><span class="line">         count++;</span><br><span class="line">         n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>数值的整数次方<br>简单数值处理（也是二分） 注意细节 指数为0 指数为负 指数为奇数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> neg = exponent &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ood = exponent % <span class="number">2</span>;</span><br><span class="line">    exponent = <span class="built_in">abs</span>(exponent);</span><br><span class="line">    <span class="type">double</span> re = base;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(exponent != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            re = re*re;</span><br><span class="line">            exponent/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ood)</span><br><span class="line">            re = re*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neg ? <span class="number">1</span>/re : re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调整数组顺序使奇数位于偶数前面<br>数组 处理 在空间不允许的情况下（不要求位置不变） 可以 用两个指针 指向头和尾，然后交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    array = re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表中倒数第k个结点<br>简单的链表处理，头尾两个指针进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* tmp = pListHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        pListHead = pListHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pListHead;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反转链表<br>中等难度的链表处理，千万要注意细节，就是指针为空的时候<br>然后有递归（难理解 简洁）和迭代两种方式来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 反转链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) :</span><br><span class="line">        <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现，注意空指针的判断，否则直接段错误</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>,*tmp2;</span><br><span class="line">    <span class="keyword">while</span>(pHead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp2 = pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next = pre;</span><br><span class="line">        pre = pHead;</span><br><span class="line">        pHead = tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    pHead-&gt;next = pre;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="function">ListNode* <span class="title">RecReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">nullptr</span> || pHead == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *pre = <span class="built_in">RecReverseList</span>(pHead-&gt;next);</span><br><span class="line">    <span class="comment">// 注意每次 pHead 这个局部变量的存在，都是指向之前的指针，相当于每次pHead 的值是栈顶的值</span></span><br><span class="line">    pHead-&gt;next-&gt;next = pHead;</span><br><span class="line">    pHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *pHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *ptmp = pHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        ptmp = ptmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RecReverseList</span>(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>合并两个排序的链表<br>简单的链表处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> &amp;&amp; pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead1 != <span class="literal">nullptr</span> &amp;&amp; pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> &amp;&amp; pHead2 != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line"></span><br><span class="line">    ListNode *head, *tmp;</span><br><span class="line">    <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head = pHead1;</span><br><span class="line">        pHead1 = pHead1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pHead2;</span><br><span class="line">        pHead2 = pHead2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(pHead1 != <span class="literal">nullptr</span> &amp;&amp; pHead2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = pHead1;</span><br><span class="line">            tmp = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = pHead2;</span><br><span class="line">            tmp = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next = pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next = pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>树的子结构<br>aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>二叉树的镜像<br>aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 3.1</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指Offer刷题-链接&quot;&gt;&lt;a href=&quot;#剑指Offer刷题-链接&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer刷题 链接&quot;&gt;&lt;/a&gt;剑指Offer刷题 &lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;链接&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;共66题-历时-2018-02-28-2018-03-01-共2天&quot;&gt;&lt;a href=&quot;#共66题-历时-2018-02-28-2018-03-01-共2天&quot; class=&quot;headerlink&quot; title=&quot;共66题 历时 2018.02.28-2018.03.01 共2天&quot;&gt;&lt;/a&gt;共66题 历时 2018.02.28-2018.03.01 共2天&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>腾讯 2017 暑期实习生编程题</title>
    <link href="http://kangqingfei.cn/2018/02/26/%E8%85%BE%E8%AE%AF-2017-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/02/26/%E8%85%BE%E8%AE%AF-2017-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <published>2018-02-26T02:06:34.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="腾讯2017暑期实习生编程题"><a href="#腾讯2017暑期实习生编程题" class="headerlink" title="腾讯2017暑期实习生编程题"></a>腾讯2017暑期实习生编程题</h3><p><a href="https://www.nowcoder.com/test/1725829/summary">链接</a></p><span id="more"></span><ol><li>构造回文子串</li></ol><p>按照 回文字符串的性质 可以知道 此题 就是求 原串与翻转后的字符串的 lcs 的值。</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcs</span><span class="params">(string &amp;str1, string &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> dp[len+<span class="number">1</span>][len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDelStr</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = str;</span><br><span class="line">    <span class="built_in">reverse</span>(str1.<span class="built_in">begin</span>(),str1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()-<span class="built_in">lcs</span>(str,str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">minDelStr</span>(str)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这题比较奇葩，首先想到的就是冒泡排序的思想，但是看到有人遍历了两遍然后输出的奇淫技巧只能大喊666</li></ol><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AkleBiCeilD</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = str.<span class="built_in">length</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; str.<span class="built_in">length</span>() &amp;&amp; str[j+<span class="number">1</span>] &gt;= <span class="string">&#x27;a&#x27;</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>这个题咋看简单其实还是很多错误的思路的。比如 当最小差为0 时 便不能应用最小差不为0的求解方法，因为当前数字可能与之前的之前的数字进行组合</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>链接：<a href="https://www.nowcoder.net/questionTerminal/af709ab9ca57430886632022e543d4c6">https://www.nowcoder.net/questionTerminal/af709ab9ca57430886632022e543d4c6</a><br>来源：牛客网</p><p>1.先排序<br>     特殊情况：如果排完序之后发现数组中所有数都相同，直接输出结果<br>         结果为：差最大个数 &#x3D; 差最小个数 &#x3D; （n * (n-1))&#x2F;2;(两两组合)<br>2.统计数组中每种数字的个数（这里用的map）<br>3.计算差最小个数<br>    3.1.如果数组中没有重复数字，说明最小差不为0，最小差肯定是数组中相邻两个数的差<br>        因此，遍历一边数组，计算并统计最小差。<br>    3.2.如果数组中有重复数字，说明最小差是0，此时，遍历一边map，数字个数不为0的<br>        数字会产生最小差0，利用公式计算即可<br>4.计算差最大个数     <br>    只有一种情况，最大值与最小值的两两组合，即最大值个数 * 最小值个数<br>        算法复杂度：排序O(nlogn), 统计O(n)</p><h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span> &gt; arr;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>,maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX, minCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">                minCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == min)</span><br><span class="line">            &#123;</span><br><span class="line">                minCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == max)</span><br><span class="line">            &#123;</span><br><span class="line">                maxCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> minTmp = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sameCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>()<span class="number">-1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] &lt; minTmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sameCount = <span class="number">1</span>;</span><br><span class="line">                minTmp = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] == minTmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sameCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minTmp == <span class="number">0</span>)<span class="comment">//最小差为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> repCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] == arr[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++repCount;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;repCount&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxCount*minCount&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;sameCount&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxCount*minCount&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;腾讯2017暑期实习生编程题&quot;&gt;&lt;a href=&quot;#腾讯2017暑期实习生编程题&quot; class=&quot;headerlink&quot; title=&quot;腾讯2017暑期实习生编程题&quot;&gt;&lt;/a&gt;腾讯2017暑期实习生编程题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/test/1725829/summary&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="tencent" scheme="http://kangqingfei.cn/tags/tencent/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://kangqingfei.cn/2018/02/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://kangqingfei.cn/2018/02/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2018-02-26T01:48:13.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>一种方法是通过翻转字符串，然后依靠最长公共子串（而不是子序列，子序列可以用来构造回文子串）的方法来求解</p><span id="more"></span><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><ul><li>首先通过向字符中添加 # 把原字符需要划分奇数偶数的处理变成了 统一处理</li><li>其次 维护 一个 P[i] 表示 以当前为中心向两边扩展的回文长度，id 当前最长的回文子串的中心， mx &#x3D; id + P[id] 为字符串的边界。</li><li>关键思想是P[i]的更新是需要技巧的。  若 mx &gt; i 则 P[i] &gt;&#x3D; min(P[2*id-i],mx-i) 若 mx &lt;&#x3D; i 则 P[i] &#x3D; 1</li><li>该思想是通过 <code>对称点来初始化 P[i]</code> 若对称点的 回文子串包含在 目前最长串内 则初始化为与对称点一致 P[i] &#x3D; P[2*id-1] 否则 对称点的回文子串超出最长子串界限，则P[i]在最长回文子串内的那段（长度mx-i）必定是回文的， 但后续情况未知，P[i] &#x3D; mx-i<br><a href="https://www.felix021.com/blog/read.php?2040">参考</a></li></ul><p>参考代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>,mx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> P[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        P[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx - i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            P[i] = <span class="built_in">min</span>(P[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i+P[i]] == str[i-P[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有两种情况需要更新 一种是 找到了更长的回文子串，一种是当前的遍历下标已经超过了最长的那个回文子串的边界(开始新的一轮) 分别对应 P[i] 大 和 i 大</span></span><br><span class="line">        <span class="keyword">if</span>(P[i]+i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            mx = P[i]+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp = P[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> index =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(P[i] &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = P[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    <span class="type">int</span> start = index/<span class="number">2</span> - tmp/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = index/<span class="number">2</span> + (tmp<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    re.<span class="built_in">push_back</span>(start);</span><br><span class="line">    re.<span class="built_in">push_back</span>(end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">preProcess</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string reStr = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        reStr += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        reStr += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    reStr += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> reStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="string">&quot;abccba&quot;</span>;</span><br><span class="line">        string str1 = <span class="built_in">preProcess</span>(str);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">manacher</span>(str1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tmp[<span class="number">0</span>]; i &lt; tmp[<span class="number">1</span>]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;str[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h2&gt;&lt;p&gt;一种方法是通过翻转字符串，然后依靠最长公共子串（而不是子序列，子序列可以用来构造回文子串）的方法来求解&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LCS与编辑距离以及MCSS</title>
    <link href="http://kangqingfei.cn/2018/02/04/LCS%E4%B8%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://kangqingfei.cn/2018/02/04/LCS%E4%B8%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2018-02-04T08:02:09.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。"><a href="#LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。" class="headerlink" title="LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 子序列 而不是 子串 的最大的长度。"></a>LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 <code>子序列</code> 而不是 <code>子串</code> 的最大的长度。</h2><p>之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。</p><span id="more"></span><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>设定 dp[i][j] 为str(0…i) 与 patten(0…j) 的最长子公共子序列的长度</li></ul><ol><li>初始化 数组的 0 下标为零，然后更新 dp[i][j];</li><li>若 <code>str[i] == patten[j]</code> 则<code>dp[i][j] = dp[i-1][j-1]</code>，若 <code>str[i] != patten[j]</code> 则 <code>dp[i][j] = max(dp[i][j-1],dp[i-1][j])</code></li><li>迭代更新 dp[i][j]</li></ol><h3 id="最长子序列输出"><a href="#最长子序列输出" class="headerlink" title="最长子序列输出"></a>最长子序列输出</h3><ol><li>若 <code>str[i] == patten[j]</code>，则输出 str[i] （导致反向输出）</li><li>若 <code>str[i] != patten[j]</code>，则判断 dp[i][j] 是等于上方的(i–)还是下方的(j–)，然后移到该方向。</li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LCS 问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcs</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> string &amp;patten)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> strSize = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pattenSize = patten.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[strSize+<span class="number">1</span>][pattenSize+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= strSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pattenSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-1</span>] == patten[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = strSize;</span><br><span class="line">    <span class="type">int</span> j = pattenSize;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; re;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i<span class="number">-1</span>] == patten[j<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(str[i<span class="number">-1</span>]);</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(re.<span class="built_in">begin</span>(),re.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:re)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;kangqingfei&quot;</span>;</span><br><span class="line">    string patten = <span class="string">&quot;ng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lcs</span>(str,patten);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编辑距离问题-Edit-Distance"><a href="#编辑距离问题-Edit-Distance" class="headerlink" title="编辑距离问题(Edit Distance)"></a>编辑距离问题(Edit Distance)</h2><p>编辑距离和LCS很像，只是更新 dp[i][j] 的时候略有不同而已</p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>设定 dp[i][j] 为 str1(0…i) 与 str2(0…j) 的编辑距离</li></ul><ol><li>初始化 dp[0][j] 和 dp[i][0] 为 j 和 i  其含义为，一个字符串与一个空串的编辑距离为字符串本身的长度</li><li>更新dp[i][j],更新规则为，若 str1[i] &#x3D;&#x3D; str2[j] 则dp[i][j] &#x3D; dp[i-1][j-1] 若 str1[i] !&#x3D; str2[j] 则考虑 str1 不变，str2 可以通过 增加(dp[i-1][j] + 1) 删除(dp[i][j-1] + 1) 替换(dp[i-1][j-1] + 1) 变到str1</li><li>迭代更新 dp[i][j], 输出dp[iMax][jMax] 即为编辑距离</li></ol><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">editDistance</span>(string str1, string str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length1 = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length2 = str2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[length1+<span class="number">1</span>][length2+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= length2; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//                     增加       删除          替换</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[length1][length2]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;kangqingfei&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;kangqingfeng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">editDistance</span>(str1,str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h2><p>该问题与 LCS 问题的区别就在于 是否连续<br>若可以连续就是<code>子串</code> 否则就是<code>子序列</code>。<br>对于子串的解法与子序列的解法基本一致 区别就在于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str1[i] != str2[j])</span><br><span class="line">    dp[i][j] = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后通过 遍历 dp[i][j] 来获得最大的子串长度，然后得到子串<br>在空间优化上面可以通过滚动数组来节省空间</p><h2 id="最大连续序列求和（Maximum-Contiguous-Subsequence-Sum）MCSS-问题"><a href="#最大连续序列求和（Maximum-Contiguous-Subsequence-Sum）MCSS-问题" class="headerlink" title="最大连续序列求和（Maximum Contiguous Subsequence Sum）MCSS 问题"></a>最大连续序列求和（Maximum Contiguous Subsequence Sum）MCSS 问题</h2><p>该问题为求一个序列的所有子序列中 和最大 的那个子序列。<br>该问题为简单的动态规划问题</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcss</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dp[len];</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> ? arr[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>]:arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; maxSum)</span><br><span class="line">            maxSum = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcssPlus</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span><span class="comment">//空间优化版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmpDp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmpDp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpDp += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpDp = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpDp &gt; maxSum)</span><br><span class="line">            maxSum = tmpDp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 -2 11 -4 13 -5 -2 -&gt; 20</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count,tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">mcssPlus</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。&quot;&gt;&lt;a href=&quot;#LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。&quot; class=&quot;headerlink&quot; title=&quot;LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 子序列 而不是 子串 的最大的长度。&quot;&gt;&lt;/a&gt;LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 &lt;code&gt;子序列&lt;/code&gt; 而不是 &lt;code&gt;子串&lt;/code&gt; 的最大的长度。&lt;/h2&gt;&lt;p&gt;之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="编辑距离" scheme="http://kangqingfei.cn/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>最长无重复子串</title>
    <link href="http://kangqingfei.cn/2018/01/27/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <id>http://kangqingfei.cn/2018/01/27/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</id>
    <published>2018-01-27T07:24:09.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<p>与 <code>最长重复子串</code> 不一样的是，此问题要求所有子串中 没有重复字母的 子串中长度最长为多少。</p><p>题目来源 为 Leetcode 第三题 <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Longest Substring Without Repeating Characters</a></p><span id="more"></span><ul><li>基本思路是用的滑动窗口来遍历每个起始点的 无重复子串的 长度 ， 然后取得最大的长度。</li></ul><p>首先来个简单易懂的  每次清空hash表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str = s;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">            map[str[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; str.<span class="built_in">length</span>() &amp;&amp; map[str[j]] != <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                map[str[j]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j - i &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                 max = j - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样的思路，来个升级版 时间复杂度 O(2n) <code>abababababab</code>这种为最坏情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string str = s;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len &amp;&amp; j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(map[str[j]] == <span class="number">1</span>)<span class="comment">//左边前移 区间变短</span></span><br><span class="line">        &#123;</span><br><span class="line">            map[str[i++]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右边前移 区间变长 更新 max</span></span><br><span class="line">        &#123;</span><br><span class="line">            map[str[j++]]++;</span><br><span class="line">            <span class="keyword">if</span>(j - i &gt; max)</span><br><span class="line">                max = j - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;与 &lt;code&gt;最长重复子串&lt;/code&gt; 不一样的是，此问题要求所有子串中 没有重复字母的 子串中长度最长为多少。&lt;/p&gt;
&lt;p&gt;题目来源 为 Leetcode 第三题 &lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/description/&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="hash" scheme="http://kangqingfei.cn/tags/hash/"/>
    
    <category term="滑动窗口" scheme="http://kangqingfei.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>最长重复子串-LRS</title>
    <link href="http://kangqingfei.cn/2018/01/25/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2-LRS/"/>
    <id>http://kangqingfei.cn/2018/01/25/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2-LRS/</id>
    <published>2018-01-25T11:06:52.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS"><a href="#此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS" class="headerlink" title="此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS"></a>此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS</h3><span id="more"></span><p>针对子串是否重叠，又可以分为<code>可重叠的最长重复子串</code> 和 <code>不可重叠的重复子串</code>。</p><ul><li>可重叠的最长重复子串   参考<a href="http://www.voidcn.com/article/p-yjvdpysb-bee.html">后缀数组求最长重复子串</a><br>有关更多后缀数组的题 参考 vjudge-&gt;<a href="https://vjudge.net/contest/58608#overview">后缀数组入门</a></li></ul><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><ol><li>通过后缀数组找到所有的子串</li><li>排序得到前后关联比较大的子串序列。注意排序完成后 <em>对于一个子串，一个与其重复最多的字符串肯定是紧挨着自己的两个字符串</em></li><li>遍历每个子串，将其与前后两个子串相比较，得到两者相同长度较大的一者</li><li>遍历所有得到的相同的长度，取最大的就是最长的公共子串</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例如： banana 可以重复的最长子串是 ana<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCommonLnegth</span><span class="params">(string &amp;self, string &amp;compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">min</span>(self.<span class="built_in">length</span>(),compare.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(self[j] != compare[j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string words = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    vector&lt;string &gt; suffix;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = words.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//int count = len;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        suffix.<span class="built_in">push_back</span>(words.<span class="built_in">substr</span>(i,len-i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对后缀数组进行排序</span></span><br><span class="line">    <span class="comment">// 注意到 排序完成之后 每个子序列的最长重复的另一子序列要么在其前面，要么在其后面</span></span><br><span class="line">    <span class="built_in">sort</span>(suffix.<span class="built_in">begin</span>(),suffix.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">commonLen</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到每个子序列的最长重复长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != len <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             commonLen[i] = <span class="built_in">max</span>(<span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i<span class="number">-1</span>]),<span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            commonLen[i] = <span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == len <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            commonLen[i] = <span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>,maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; commonLen[i])</span><br><span class="line">        &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxLen = commonLen[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;suffix[index][i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不可重叠最长重复子串<br>顾名思义，前后的子串是在不能重叠的情况下面的最长的重复的长度</li></ul><h3 id="类似题型变种还有"><a href="#类似题型变种还有" class="headerlink" title="类似题型变种还有:"></a>类似题型变种还有:</h3><ol start="0"><li><a href="http://blog.csdn.net/qinzhenhua100/article/details/39968291">最长不重叠重复子串 POJ 1743</a></li><li><a href="http://blog.csdn.net/ACdreamers/article/details/9121117">可重叠的K次最长重复子串(POJ 3261)</a></li><li><a href="http://forever97.is-programmer.com/2016/8/12/spoj687.204992.html">重复次数最多的连续重复子串的长度(SPOJ 687)</a></li><li><a href="http://blog.csdn.net/ZouCharming/article/details/46699583">求重复次数最多的子串 POJ 3693</a></li><li><a href="http://blog.csdn.net/u013351484/article/details/43113201">至少重复k次的可重叠的最长重复子串 POJ 3882</a></li><li><a href="http://www.cnblogs.com/zichi/p/4841878.html">RMQ (Range Minimum&#x2F;Maximum Query) 求解中的 ST 算法</a></li><li><a href="http://dongxicheng.org/structure/lca-rmq/">LCA 与 RMQ</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS&quot;&gt;&lt;a href=&quot;#此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS&quot; class=&quot;headerlink&quot; title=&quot;此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS&quot;&gt;&lt;/a&gt;此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="后缀数组" scheme="http://kangqingfei.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="LRS" scheme="http://kangqingfei.cn/tags/LRS/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列-LIS</title>
    <link href="http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/"/>
    <id>http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/</id>
    <published>2018-01-22T13:45:57.000Z</published>
    <updated>2022-09-14T18:03:38.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题"><a href="#LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题" class="headerlink" title="LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题"></a>LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题</h3><p>简单来讲就是要找到一个序列中，所有递增子序列中长度最长的子序列的长度。子序列的取值不要求在原序列中连续。</p><span id="more"></span><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>dp[i] 记录： 以arr[i]结尾的递增子序列的最大长度。<br>dp[i] 的更新：遍历 arr[0] 到 arr[i - 1] 中 小于 arr[i] 的数，并找到所有满足条件的arr[x] 中 dp[x] 最大的那个dp[n]，则dp[i] &#x3D; dp[n] + 1<br>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lis 动态规划 复杂度 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lis</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = length;</span><br><span class="line">    <span class="type">int</span> dp[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])</span><br><span class="line">                tmpMax = <span class="built_in">max</span>(dp[j],tmpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = tmpMax + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; tmpMax)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpMax = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种递增，即必须严格递增，不能相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格递增不能相等lis</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-二分"><a href="#动态规划-二分" class="headerlink" title="动态规划 + 二分"></a>动态规划 + 二分</h3><p>dp[i] 记录：当前最长的递增子序列的值<br>dp[i] 更新：把arr[i] 放入到 dp[i] 中，其放置方法为，从arr[0] 到 arr[len] 找到第一个大于等于arr[i]的位置pos，dp[pos] &#x3D; arr[i]。并更新len &#x3D; max(len,pos+1);<br>len增加（len &lt; pos +1）的情况只有一种，便是在当前序列的末尾增加了一个数(pos &#x3D; len)，反之如果只是在中间进行替换并不会改变len的大小。<br>注意到这里对 pos 的查找是对一个有序的序列的查找，可以使用二分查到达到log(n) 的复杂度。</p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分+动态规划</span></span><br><span class="line"><span class="built_in">lisDich</span>(<span class="type">int</span> *arr, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> l = length;</span><br><span class="line">    <span class="type">int</span> dp[l] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(dp,dp+len,arr[i]) - dp;<span class="comment">//二分查找，节省时间</span></span><br><span class="line">        dp[pos] = arr[i];</span><br><span class="line">        len = <span class="built_in">max</span>(len,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到的函数函数<code>lower_bound()</code> 用于在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置</p><h3 id="华为机试题-24题-合唱队"><a href="#华为机试题-24题-合唱队" class="headerlink" title="华为机试题 24题 合唱队"></a>华为机试题 24题 合唱队</h3><p>一种LIS的变种，通过正向与反向两次dp得到arr[i]左侧递增和右侧递减的长度，将两者相加得到一个满足条件的最大长度。<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calLis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpf</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpr</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">lis</span>(arr,dpf);</span><br><span class="line">    <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">lis</span>(arr,dpr);</span><br><span class="line">    <span class="built_in">reverse</span>(dpr.<span class="built_in">begin</span>(),dpr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dpf[i] + dpr[i];</span><br><span class="line">        <span class="keyword">if</span>(max &lt; dp[i])</span><br><span class="line">            max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; arr;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        arr.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>() - <span class="built_in">calLis</span>(arr);</span><br><span class="line">        cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考<a href="https://xuanwo.org/2015/07/31/dp-lis/">动态规划——最长上升子序列问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题&quot;&gt;&lt;a href=&quot;#LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题&quot; class=&quot;headerlink&quot; title=&quot;LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题&quot;&gt;&lt;/a&gt;LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题&lt;/h3&gt;&lt;p&gt;简单来讲就是要找到一个序列中，所有递增子序列中长度最长的子序列的长度。子序列的取值不要求在原序列中连续。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LIS" scheme="http://kangqingfei.cn/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>今日头条2018校招算法方向 第一批</title>
    <link href="http://kangqingfei.cn/2018/01/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E6%96%B9%E5%90%91-%E7%AC%AC%E4%B8%80%E6%89%B9/"/>
    <id>http://kangqingfei.cn/2018/01/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E6%96%B9%E5%90%91-%E7%AC%AC%E4%B8%80%E6%89%B9/</id>
    <published>2018-01-07T12:45:24.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日头条2018校招算法方向-第一批-链接：here"><a href="#今日头条2018校招算法方向-第一批-链接：here" class="headerlink" title="今日头条2018校招算法方向 第一批 链接：here"></a>今日头条2018校招算法方向 第一批 链接：<a href="https://www.nowcoder.com/test/8537290/summary">here</a></h1><h2 id="三道编程题，难度循序渐进，第三题做了很久还是有问题"><a href="#三道编程题，难度循序渐进，第三题做了很久还是有问题" class="headerlink" title="三道编程题，难度循序渐进，第三题做了很久还是有问题"></a>三道编程题，难度循序渐进，第三题做了很久还是有问题</h2><span id="more"></span><ol><li>一道求外围点的题<h3 id="P为给定的二维平面整数点集。定义-P-中某点x，如果x满足-P-中任意点都不在-x-的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复-坐标轴范围在-0-1e9-内）"><a href="#P为给定的二维平面整数点集。定义-P-中某点x，如果x满足-P-中任意点都不在-x-的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复-坐标轴范围在-0-1e9-内）" class="headerlink" title="P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）"></a>P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）</h3> 如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。 <img src="/assest/images/2018010701.jpg" class=""><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3> 第一行输入点集的个数 N， 接下来 N 行，每行两个数字代表点的 X 轴和 Y 轴。<br> 对于 50%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 10000;<br> 对于 100%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 500000;<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出“最大的” 点集合， 按照 X 轴从小到大的方式输出，每行两个数字分别代表点的 X 轴和 Y轴。<h3 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 5<br> 1 2<br> 5 3<br> 4 6<br> 7 5<br> 9 0<h3 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 4 6<br> 7 5<br> 9 0<h3 id="思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代"><a href="#思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代" class="headerlink" title="思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代"></a>思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代</h3> 还有一个坑就是，输入输出的方式，这里一开始用 cin 和 cout 发现一直是80%AC 改成scanf 和 printf后就是100% :(<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今日头条实习生 第一题 100% AC cin 与 cout 太浪费时间（80%AC） 改用 scanf 和 printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;   <span class="comment">//升序排列，如果改为return a&gt;b，则为降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; <span class="built_in">points</span>(count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;points[i].first, &amp;points[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),compare);</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pointTmp = points[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; goodPoints;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i].first &gt;= pointTmp.first)</span><br><span class="line">        &#123;</span><br><span class="line">            goodPoints.<span class="built_in">push_back</span>(i);</span><br><span class="line">            pointTmp = points[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : goodPoints)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, points[c].first,points[c].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一道很像动态规划的单调栈题<h3 id="给定一个数组序列-需要求选出一个区间-使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数-区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列-6-2-1-则根据上述公式-可得到所有可以选定各个区间的计算值"><a href="#给定一个数组序列-需要求选出一个区间-使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数-区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列-6-2-1-则根据上述公式-可得到所有可以选定各个区间的计算值" class="headerlink" title="给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:"></a>给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:</h3><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3> 第一行输入数组序列长度n，第二行输入数组序列。<br> 对于 50%的数据, 1 &lt;&#x3D; n &lt;&#x3D; 10000;<br> 对于 100%的数据, 1 &lt;&#x3D; n &lt;&#x3D; 500000;<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出数组经过计算后的最大值。<h3 id="输入例子1-1"><a href="#输入例子1-1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 3<br> 6 2 1<h3 id="输出例子1-1"><a href="#输出例子1-1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 36<h3 id="思路，有一种动态规划的思路，但是AC好像只有40-原因是内存超出限制"><a href="#思路，有一种动态规划的思路，但是AC好像只有40-原因是内存超出限制" class="headerlink" title="思路，有一种动态规划的思路，但是AC好像只有40% 原因是内存超出限制"></a>思路，有一种动态规划的思路，但是AC好像只有40% 原因是内存超出限制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 动态规划解法 40% AC 内存超出限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">mindp</span>(num,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; num; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                mindp[i][j] = arr[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mindp[i][j] = <span class="built_in">min</span>(mindp[i][j<span class="number">-1</span>],arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum,mindp[i][j] * (sum[j+<span class="number">1</span>] - sum[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值"><a href="#第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值" class="headerlink" title="第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值"></a>第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈解法 100% AC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vecSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i = begin; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        re += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; upStack;</span><br><span class="line"></span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// 先添加一个小于0 的数作为比较，以去除每次非空的判断</span></span><br><span class="line">    upStack.<span class="built_in">push</span>(num); <span class="comment">// 将 最后的那个自行添加的数的下标添加到栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt;= arr[upStack.<span class="built_in">top</span>()])<span class="comment">// 如果比当前的栈顶的元素要大的话就直接压栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            upStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则的话就先弹出栈顶的元素，直到满足上面的压栈条件，</span></span><br><span class="line">        <span class="comment">// 并且 计算 栈顶元素的单调区间（以栈顶元素开始往前单调递减 但 不小于当前值的 整个区间）的值</span></span><br><span class="line">        <span class="comment">// 然后更新 maxSum 的值 并压栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt; arr[upStack.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                top = upStack.<span class="built_in">top</span>();</span><br><span class="line">                upStack.<span class="built_in">pop</span>();</span><br><span class="line">                maxSum = <span class="built_in">max</span>(maxSum,arr[top] * <span class="built_in">vecSum</span>(arr,upStack.<span class="built_in">top</span>()+<span class="number">1</span>,i<span class="number">-1</span>));<span class="comment">//弹出栈并更新最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">             upStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> topEnd = upStack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">while</span>(upStack.<span class="built_in">top</span>() != num)</span><br><span class="line">    &#123;</span><br><span class="line">        top = upStack.<span class="built_in">top</span>();</span><br><span class="line">        upStack.<span class="built_in">pop</span>();</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum,arr[top] * <span class="built_in">vecSum</span>(arr,upStack.<span class="built_in">top</span>()+<span class="number">1</span>,topEnd));<span class="comment">//弹出栈并更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一道任务调度的题 该题较难，没有AC 但是我感觉思路是死的，也没想到啥高端的算法<h3 id="产品经理-PM-有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个-idea，每个-idea-有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有-PM-会在同一时刻提出两个-idea。"><a href="#产品经理-PM-有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个-idea，每个-idea-有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有-PM-会在同一时刻提出两个-idea。" class="headerlink" title="产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。"></a>产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。</h3> 同时有M个程序员，每个程序员空闲的时候就会查看每个PM尚未执行并且最想完成的一个idea,然后从中挑选出所需时间最小的一个idea独立实现，如果所需时间相同则选择PM序号最小的。直到完成了idea才会重复上述操作。如果有多个同时处于空闲状态的程序员，那么他们会依次进行查看idea的操作。<br> 求每个idea实现的时间。<br> 输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。输出P行，分别表示每个idea实现的时间点。<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3> 输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。全部数据范围 [1, 3000]。<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出P行，分别表示每个idea实现的时间点。<h3 id="输入例子1-2"><a href="#输入例子1-2" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 2 2 5<br> 1 1 1 2<br> 1 2 1 1<br> 1 3 2 2<br> 2 1 1 2<br> 2 3 5 5<h3 id="输出例子1-2"><a href="#输出例子1-2" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 3<br> 4<br> 5<br> 3<br> 9<h3 id="能有的思路就是一个死的思路，但是没有AC-贴上代码-这里有个10-AC的代码"><a href="#能有的思路就是一个死的思路，但是没有AC-贴上代码-这里有个10-AC的代码" class="headerlink" title="能有的思路就是一个死的思路，但是没有AC 贴上代码,这里有个10%AC的代码"></a>能有的思路就是一个死的思路，但是没有AC 贴上代码,<a href="http://blog.csdn.net/Geng19930909/article/details/77506945">这里</a>有个10%AC的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> idealId;</span><br><span class="line">    <span class="type">int</span> pmId;</span><br><span class="line">    <span class="type">int</span> timeStart;</span><br><span class="line">    <span class="type">int</span> pority;</span><br><span class="line">    <span class="type">int</span> timeCost;</span><br><span class="line">    <span class="type">int</span> timeFinish;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Task t1,Task t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.pority == t2.pority)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(t1.timeCost == t2.timeCost)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> t1.timeStart &lt; t2.timeStart;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> t1.timeCost &lt; t2.timeCost;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.pority &lt; t2.pority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTask</span><span class="params">(Task t1,Task t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.timeCost == t2.timeCost)</span><br><span class="line">        <span class="keyword">return</span> t1.pmId &lt; t2.pmId;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t1.pmId &lt; t2.pmId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPmTask</span><span class="params">( vector&lt;vector&lt;Task &gt; &gt; &amp; pmdata, vector&lt;Task&gt; &amp; taskPerPm, vector&lt;<span class="type">int</span>&gt; &amp;selectIndex, <span class="type">int</span> &amp; coder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    taskPerPm.<span class="built_in">clear</span>();</span><br><span class="line">    Task tmpTask;</span><br><span class="line">    <span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pmdata.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pmdata[i].<span class="built_in">size</span>() == <span class="number">0</span>)<span class="comment">//该pm已经没有任务可以调度了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coder &lt; pmdata[i][<span class="number">0</span>].timeStart)<span class="comment">//如果优先级高的需要等待，则优先选择不需要等待的次高优先级的任务 情况一</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpTask = pmdata[i][<span class="number">0</span>];</span><br><span class="line">                select = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; pmdata[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pmdata[i][j].timeStart &lt; tmpTask.timeStart)<span class="comment">//待定任务</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        tmpTask = pmdata[i][j];<span class="comment">//更新需要等待时间最少的任务</span></span><br><span class="line">                        select = j;</span><br><span class="line">                        <span class="keyword">if</span>(coder &gt;= pmdata[i][j].timeStart)<span class="comment">//找到优先级最高的那个不需要等待的任务</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            taskPerPm.<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">                            selectIndex[i] = select;<span class="comment">//更新当先加入队列中的任务</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                taskPerPm.<span class="built_in">push_back</span>(tmpTask);<span class="comment">//该pm找不到不需要等待的任务</span></span><br><span class="line">                selectIndex[i] = select;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//高优先级，不需要等待，直接进入队列 情况二</span></span><br><span class="line">            &#123;</span><br><span class="line">                taskPerPm.<span class="built_in">push_back</span>(pmdata[i][<span class="number">0</span>]);</span><br><span class="line">                selectIndex[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tasklt</span><span class="params">(<span class="type">int</span> &amp; coder, vector&lt;<span class="type">int</span>&gt; &amp; selectIndex, vector&lt;Task&gt; &amp; taskPerPm, vector&lt;vector&lt;Task &gt; &gt; &amp; pmdata, vector&lt;Task&gt; &amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选出需要完成的最高优先级任务</span></span><br><span class="line">    Task tmpTask = taskPerPm[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 并判断coder空闲的时间任务有没有产生，如果没有产生就去获取最先产生的次优先级的任务</span></span><br><span class="line">    <span class="keyword">if</span>(coder &lt; tmpTask.timeStart)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; taskPerPm.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpTask.timeStart &gt; taskPerPm[i].timeStart)<span class="comment">// 选取最先产生的任务</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpTask = taskPerPm[i];</span><br><span class="line">                <span class="keyword">if</span>(coder &gt;= tmpTask.timeStart)<span class="comment">//在满足已经产生的情况下，优先级最高的任务 找到了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成一个任务 然后更新它的 timeFinish</span></span><br><span class="line">    data[tmpTask.idealId].timeFinish = tmpTask.timeCost + (tmpTask.timeStart &gt; coder ? tmpTask.timeStart : coder);</span><br><span class="line">    <span class="comment">// 更新coder的工作时长</span></span><br><span class="line">    coder += tmpTask.timeStart &gt; coder ? tmpTask.timeStart : <span class="number">0</span>;<span class="comment">//加上等待时间</span></span><br><span class="line">    coder += tmpTask.timeCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从pm的待解决任务中移除已经调度的任务</span></span><br><span class="line">    vector&lt;Task&gt;::iterator it =  pmdata[tmpTask.pmId].<span class="built_in">begin</span>()+selectIndex[tmpTask.pmId];</span><br><span class="line">    pmdata[tmpTask.pmId].<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pmNum, coderNum, idealNum;</span><br><span class="line">    cin&gt;&gt;pmNum&gt;&gt;coderNum&gt;&gt;idealNum;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;Task &gt; &gt; <span class="built_in">pmdata</span>(pmNum);</span><br><span class="line">    vector&lt;Task &gt; data;</span><br><span class="line">    Task tmpTask;</span><br><span class="line"></span><br><span class="line">    tmpTask.timeFinish = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idealNumtmp = idealNum;</span><br><span class="line">    <span class="keyword">while</span>(idealNumtmp-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmpTask.pmId&gt;&gt;tmpTask.timeStart&gt;&gt;tmpTask.pority&gt;&gt;tmpTask.timeCost;</span><br><span class="line">        tmpTask.idealId = idealNum - idealNumtmp<span class="number">-1</span>;</span><br><span class="line">        tmpTask.pmId -= <span class="number">1</span>;</span><br><span class="line">        data.<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">        pmdata[tmpTask.pmId].<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先不考虑产生时间， 按照固定的优先级进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pmNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(pmdata[i].<span class="built_in">begin</span>(),pmdata[i].<span class="built_in">end</span>(),compare);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">coder</span><span class="params">(coderNum)</span></span>; <span class="comment">// 程序员的当前时间点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : coder)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">selectIndex</span><span class="params">(pmNum)</span></span>;<span class="comment">//当前进入选择队列的下标</span></span><br><span class="line">    vector&lt;Task&gt; taskPerPm;<span class="comment">//里面是每个pm最想完成的任务</span></span><br><span class="line">    idealNumtmp = idealNum;</span><br><span class="line">    <span class="keyword">while</span>(idealNumtmp-- &gt; <span class="number">0</span>) <span class="comment">// 对每个任务进行调度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先从pm处获取任务，分为两种情况，coder空闲时 任务已经产生还是没有产生</span></span><br><span class="line">        <span class="built_in">getPmTask</span>(pmdata,taskPerPm,selectIndex,coder[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">sort</span>(taskPerPm.<span class="built_in">begin</span>(),taskPerPm.<span class="built_in">end</span>(),getTask);<span class="comment">// 获取优先级最高的任务</span></span><br><span class="line">        <span class="built_in">tasklt</span>(coder[<span class="number">0</span>],selectIndex,taskPerPm,pmdata,data);<span class="comment">// 寻找优先级最高的任务给 最先完成的程序员进行调度</span></span><br><span class="line">        <span class="built_in">sort</span>(coder.<span class="built_in">begin</span>(),coder.<span class="built_in">end</span>());<span class="comment">//重新进行排序 以获取先完成的任务coder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : data)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c.timeFinish&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;今日头条2018校招算法方向-第一批-链接：here&quot;&gt;&lt;a href=&quot;#今日头条2018校招算法方向-第一批-链接：here&quot; class=&quot;headerlink&quot; title=&quot;今日头条2018校招算法方向 第一批 链接：here&quot;&gt;&lt;/a&gt;今日头条2018校招算法方向 第一批 链接：&lt;a href=&quot;https://www.nowcoder.com/test/8537290/summary&quot;&gt;here&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;三道编程题，难度循序渐进，第三题做了很久还是有问题&quot;&gt;&lt;a href=&quot;#三道编程题，难度循序渐进，第三题做了很久还是有问题&quot; class=&quot;headerlink&quot; title=&quot;三道编程题，难度循序渐进，第三题做了很久还是有问题&quot;&gt;&lt;/a&gt;三道编程题，难度循序渐进，第三题做了很久还是有问题&lt;/h2&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="头条" scheme="http://kangqingfei.cn/tags/%E5%A4%B4%E6%9D%A1/"/>
    
  </entry>
  
</feed>
