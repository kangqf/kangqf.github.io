<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kblog</title>
  
  
  <link href="http://kangqingfei.cn/atom.xml" rel="self"/>
  
  <link href="http://kangqingfei.cn/"/>
  <updated>2023-11-22T16:25:57.749Z</updated>
  <id>http://kangqingfei.cn/</id>
  
  <author>
    <name>kangqingfei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何有效且高效积累知识</title>
    <link href="http://kangqingfei.cn/2023/11/22/how-to-manage-knowledge/"/>
    <id>http://kangqingfei.cn/2023/11/22/how-to-manage-knowledge/</id>
    <published>2023-11-21T16:00:00.000Z</published>
    <updated>2023-11-22T16:25:57.749Z</updated>
    
    <content type="html"><![CDATA[<p>将知识归类整理是很重要的积累成长方式，如何记录知识并归档也需要系统且科学的模式。这里梳理这个流程。</p><p>由于各类平台的发展，导致了时间和知识的碎片化，尤其是短视频推荐类的渗透极大浪费了时间。整理一下，目前获取知识主要通过搜索网页，爬优秀博主，b站，微博，rss feed，知乎，贴吧，书籍。梳理了一下，目前花费时间最多的是，微信，微博，b站，淘宝（捡硬件垃圾），股票相关。而目前获取知识的效率极其低下，大部分时间浪费在了垃圾信息中。可能的改进方法可以主要有几点：</p><ul><li>增加 neat-reader，marginNote3 等软件的使用时长，增加纸质书的阅读时长，把书籍作为主要的知识输入源，提高外文书籍阅读能力，积累英语单词量。</li><li>规范知识管理体系，形成有效的知识积累，能够及时沉淀学到的新知识，有效防止反复学习。</li><li>合理分配各类时间，防止时间被浪费。</li></ul><span id="more"></span><h2 id="知识来源"><a href="#知识来源" class="headerlink" title="知识来源"></a>知识来源</h2><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231122235451968.png" alt="image-20231122235451968"></p><p>目前的知识来源包括：</p><ul><li>历史存档数据，长期需要消化的知识</li><li>logseq 中记录的知识，及时归纳整理。平时看到的需要学习的知识及时能够通过TG发送到logseq 以记录</li><li>网页书签，平时看到的好的文章，或者是工程项目</li><li>读书笔记，看纸质书或者电纸书过程形成的读书笔记</li><li>todo，平时突然的脑洞，或者受他人启发的想法记录在TODO中，及时评估是否完成</li></ul><h2 id="知识输出"><a href="#知识输出" class="headerlink" title="知识输出"></a>知识输出</h2><p>知识输出的方式比较简单，主要是网页，因为最方便触达以及传播。另外后期可以输出视频或专题的文档。</p><p>对于网页的笔记主要是markdown格式的，通过gitbook或hexo的blog进行管理。目前有以下几个模板：</p><ul><li>读书笔记。主要包括对书籍中的重要知识点的记录，可以是分篇章输出，最后需要总结书籍的涉及的技术领域，阅读的周期，推荐的指数，</li><li>日常笔记。零散知识点或者提高效能的小工具的记录模板。</li><li>电路分析或拆解笔记。主要涉及硬件产品的电路分析或拆解刷机等内容的记录</li><li>项目笔记。一般涉及一整个完整项目的记录，可以分模块，分软件硬件输出。最后可以形成专题文档。</li></ul><h2 id="知识输出流程"><a href="#知识输出流程" class="headerlink" title="知识输出流程"></a>知识输出流程</h2><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p>很简单，直接创建markdown文档，为了适配hexo的发布，需要使用模板，主要需要添加一些meta信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">./image</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">&quot;typora config pic save action&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">category:</span> <span class="string">tools</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">typora</span>]</span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="comment">## 段落标题</span></span><br><span class="line"><span class="string">内容</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;!--more--&gt;</span></span><br><span class="line"><span class="comment">### 摘要后的标题</span></span><br><span class="line"><span class="string">内容</span></span><br></pre></td></tr></table></figure><p>然后是编写文档内容，发布前需要处理一下图片，如果文章中的图片是本来就保存在本地的就需要上传到 cdn。如果本来就在cdn了，那就需要把图片保存到本地存一份备份，防止cdn厂商跑路。如果cdn厂商跑路只需要将对应的域名换成本地文件，然后重新传到新的cdn即可。</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><h4 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h4><p>将之前创建文件拷贝过来即可记得目标文件需要按照 <code>yyyy-mm-dd-title</code> 的格式进行命名，比较建议一开始就在<code>hexo</code>的<code>_post</code>目录进行撰写。完成拷贝后 <code>hexo s</code> 查看效果即可，没有问题的话即可发布，先备份源文件<code>gaa &amp;&amp; gc -m &quot;add content&quot; &amp;&amp; ggp</code>,然后<code>hexo g &amp;&amp; hexo d</code> 即可发布。</p><h4 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h4><p>gitbook 是主要的大纲型知识存档方案，发布前需要先在目录中创建新文章的索引，例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> [<span class="string">MacOS</span>](<span class="link">dev/mac.md</span>)</span><br><span class="line"><span class="bullet">    *</span> [<span class="string">hackintosh</span>](<span class="link">dev/mac/hackintosh.md</span>)</span><br><span class="line"><span class="bullet">      *</span> [<span class="string">opencore</span>](<span class="link">dev/mac/hackintosh/opencore.md</span>)</span><br><span class="line"><span class="bullet">        *</span> [<span class="string">opencore升级</span>](<span class="link">dev/mac/hackintosh/opencore_update.md</span>)</span><br></pre></td></tr></table></figure><p>然后运行 <code>gitbook init</code> 创建对应的文件和目录，如果新建文档的名称和目录中的文件名一致的话直接拖到对应目录覆盖新建文件即可。如果不一致的话还需要把新建的空文件删掉，并重命名为目录中文件名。需要注意如果有图片需要将图片也一并复制到对应目录。最后 <code>gitbook serve --lrport 35729 --port 4000</code> 预览效果即可。</p><p>预览没有问题即可发布： <code>gaa</code> -&gt; <code>gc -m &quot;add content&quot;</code> -&gt; <code>ggp</code> 推到github ，然后触发钩子，会有 Action 发布到vps。</p><h4 id="硬盘存档"><a href="#硬盘存档" class="headerlink" title="硬盘存档"></a>硬盘存档</h4><p>将完成的md以及对应的image文件夹整体打包放在一个父级目录并拷贝到存档文件夹</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>在文件存档目录更新，更新完将最新的文件拷贝到 gitbook 对应的目录覆盖，再拷贝到hexo目录覆盖，在重复发布步骤即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将知识归类整理是很重要的积累成长方式，如何记录知识并归档也需要系统且科学的模式。这里梳理这个流程。&lt;/p&gt;
&lt;p&gt;由于各类平台的发展，导致了时间和知识的碎片化，尤其是短视频推荐类的渗透极大浪费了时间。整理一下，目前获取知识主要通过搜索网页，爬优秀博主，b站，微博，rss feed，知乎，贴吧，书籍。梳理了一下，目前花费时间最多的是，微信，微博，b站，淘宝（捡硬件垃圾），股票相关。而目前获取知识的效率极其低下，大部分时间浪费在了垃圾信息中。可能的改进方法可以主要有几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加 neat-reader，marginNote3 等软件的使用时长，增加纸质书的阅读时长，把书籍作为主要的知识输入源，提高外文书籍阅读能力，积累英语单词量。&lt;/li&gt;
&lt;li&gt;规范知识管理体系，形成有效的知识积累，能够及时沉淀学到的新知识，有效防止反复学习。&lt;/li&gt;
&lt;li&gt;合理分配各类时间，防止时间被浪费。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="note" scheme="http://kangqingfei.cn/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>github dependabot</title>
    <link href="http://kangqingfei.cn/2023/11/18/github-depenabot/"/>
    <id>http://kangqingfei.cn/2023/11/18/github-depenabot/</id>
    <published>2023-11-17T16:00:00.000Z</published>
    <updated>2023-11-17T18:26:55.223Z</updated>
    
    <content type="html"><![CDATA[<p>发现在本地执行<code>git branch -a</code> 时多了很多远程的分支，如下图：</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/202311180130588.png"></p><p>研究一番之后发现这是 <code>github</code> 自动创建的分支，并且这个 <code>dependabot</code> 是 GitHub 官方的一款依赖更新工具，拥有强大的功能，包括：</p><ol><li>当使用的依赖包中的有安全漏洞问题时给你发送通知</li><li>当使用的依赖包中的有安全漏洞问题时自动提交PR</li><li>自动拉取依赖包的最先版本，并自动提交PR</li></ol><span id="more"></span><p>可以在<code>Settings</code> -&gt; <code>Code security and analysis</code> 中看到对应的功能配置</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231118020642585.png" alt="image-20231118020642585"></p><p>我们可以看到前面几项功能并没有开启，而这里项目里面新建的分支就是对应的第三项功能。可以发现确实PR里面多了对应的条目</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231118021229351.png" alt="image-20231118021229351"></p><p>点击上面的<code>Configure</code>，可以看到对应的配置如下：</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20231118020522702.png" alt="image-20231118020522702"></p><p>大概的意思就是每天会检测一遍，并限制了最多开20个PR，更多的配置选项可以参考资料3。这里我们对其没有兴趣，只想不看见那么多分支，因此只需要将 <code>open-pull-requests-limit</code> 这个字段改成 <code>0</code> 即可。</p><hr><p>参考资料：</p><ol><li><a href="https://docs.github.com/zh/enterprise-server@3.10/code-security/getting-started/dependabot-quickstart-guide">官方中文文档</a></li><li><a href="https://mmdjiji.com/2023/01/3/">GitHub 自动更新依赖</a></li><li><a href="https://m.w3cschool.cn/githubcn/githubcn-5hgb3asc.html">相关字段及配置的详解</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;发现在本地执行&lt;code&gt;git branch -a&lt;/code&gt; 时多了很多远程的分支，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.kangqingfei.cn/typora/img/202311180130588.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;研究一番之后发现这是 &lt;code&gt;github&lt;/code&gt; 自动创建的分支，并且这个 &lt;code&gt;dependabot&lt;/code&gt; 是 GitHub 官方的一款依赖更新工具，拥有强大的功能，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当使用的依赖包中的有安全漏洞问题时给你发送通知&lt;/li&gt;
&lt;li&gt;当使用的依赖包中的有安全漏洞问题时自动提交PR&lt;/li&gt;
&lt;li&gt;自动拉取依赖包的最先版本，并自动提交PR&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="git" scheme="http://kangqingfei.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Opencore 升级引导三系统</title>
    <link href="http://kangqingfei.cn/2023/03/12/update-opencore/"/>
    <id>http://kangqingfei.cn/2023/03/12/update-opencore/</id>
    <published>2023-03-11T16:00:00.000Z</published>
    <updated>2023-03-12T05:25:41.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="opencore-升级"><a href="#opencore-升级" class="headerlink" title="opencore 升级"></a>opencore 升级</h1><h2 id="当前版本备份"><a href="#当前版本备份" class="headerlink" title="当前版本备份"></a>当前版本备份</h2><p><code> sudo diskutil mount /dev/disk0s1</code> 挂载EFI分区</p><p><code>cp -rf EFI ~/Desktop/EFI_OLD</code> 备份</p><p><code>sudo diskutil umount /dev/disk0s1</code> 取消挂载</p><p><code>tree -I &quot;config_list_bak|Resources&quot; -L 3</code> 查看当前文件目录结构</p><p>其中 <code>-I</code> 表示忽略对应的文件夹 <code>-L</code> 表示最多查看的层级</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT</span><br><span class="line">│   └── BOOTx64.efi</span><br><span class="line">└── OC</span><br><span class="line">    ├── ACPI</span><br><span class="line">    │   ├── SSDT-AWAC.aml</span><br><span class="line">    │   ├── SSDT-EC-USBX.aml</span><br><span class="line">    │   ├── SSDT-PLUG.aml</span><br><span class="line">    │   ├── SSDT-PMC.aml</span><br><span class="line">    │   └── SSDT-SBUS-MCHC.aml</span><br><span class="line">    ├── Bootstrap</span><br><span class="line">    │   └── Bootstrap.efi</span><br><span class="line">    ├── Drivers</span><br><span class="line">    │   ├── HfsPlus.efi</span><br><span class="line">    │   ├── OpenCanopy.efi</span><br><span class="line">    │   └── OpenRuntime.efi</span><br><span class="line">    ├── Kexts</span><br><span class="line">    │   ├── AirportBrcmFixup.kext</span><br><span class="line">    │   ├── AppleALC.kext</span><br><span class="line">    │   ├── IntelMausi.kext</span><br><span class="line">    │   ├── Lilu.kext</span><br><span class="line">    │   ├── SMCProcessor.kext</span><br><span class="line">    │   ├── SMCSuperIO.kext</span><br><span class="line">    │   ├── USBMap.kext</span><br><span class="line">    │   ├── VirtualSMC.kext</span><br><span class="line">    │   └── WhateverGreen.kext</span><br><span class="line">    ├── OpenCore.efi</span><br><span class="line">    ├── Tools</span><br><span class="line">    │   └── OpenShell.efi</span><br><span class="line">    └── config.plist</span><br><span class="line"></span><br><span class="line">16 directories, 13 files</span><br></pre></td></tr></table></figure><p>上面主要有两个比较重要的文件，一个是 <code>config.plist</code> 记录了黑苹果的配置，一个是 <code>USBMap.kext</code> 这里面有定制USB的信息，错误的usb定制信息会导致睡眠唤醒的异常</p><p>参考文章：<a href="https://www.bugprogrammer.me/2020/05/27/Hackintosh_for_Z490_10900K.html">技嘉Z490 ELITE+i9 10900K+RX 5700 XT Hackintosh构建说明</a></p><h2 id="新版本升级"><a href="#新版本升级" class="headerlink" title="新版本升级"></a>新版本升级</h2><p>旧版本：0.6.0</p><p>新版本：0.8.8</p><p>对于小版本的升级可以使用 <a href="https://github.com/ic005k/OCAuxiliaryTools/releases">OCA工具</a> 进行直接升级，但是这里跨越的版本有点大，使用OCA后出现问题较多便使用了手工升级。</p><p>手工升级的方式就是对照新的配置模板，将旧的配置迁移到新的配置中，如果是新出现的配置就保持默认的配置就好。</p><p>升级前记得备份，如果出现u盘启动盘也无法引导的情况可以使用win的<code>diskgenius</code>把配置进行还原，再进行试错。</p><p>遇到问题，请仔细阅读<strong>官方的configuraion.pdf</strong>，所有的配置项在里面都有详细的描述。</p><p>参考文章：<a href="https://www.a7mac.com/241.html">OpenCore引导版本升级教程</a></p><h2 id="引导多个系统"><a href="#引导多个系统" class="headerlink" title="引导多个系统"></a>引导多个系统</h2><p>需要注意，最好独立按照多个系统到不同的硬盘上面进行操作，不然不同系统的引导可能会相互影响相互识别。在安装新系统时，需要将其他已经安装好的系统的硬盘物理移除了。</p><p>安装好之后就可以通过OpenShell 来获取 引导多个系统所需要的信息</p><p>主要是要找的不同系统所在硬盘的硬件描述信息。不过其实windows 会被目前版本的OC主动识别，不需要手动添加。</p><p>如果对引导的顺序有比较高的要求可以通过<a href="https://heipg.cn/tutorial/delete-opencore-unnecessary-entries.html">https://heipg.cn/tutorial/delete-opencore-unnecessary-entries.html</a> 描述的方法将win的引导屏蔽了，然后手动添加引导来排序。</p><blockquote><p>可以使用隐藏文件（对于 macOS 来说是隐藏的）.contentVisibility 来隐藏引导项。如果启动分区或引导文件目录中包含 .contentVisibility，则 OpenCore 会自动排除这个条目作为可选启动项。需要注意的是，如果该条目的 .contentVisibility 文件包含辅助条目内容（Auxiliary），则该项目会被 OpenCore 视为辅助条目</p></blockquote><p>参考文章<a href="https://kextcache.com/opencore-dualboot-guide/?amp=1">https://kextcache.com/opencore-dualboot-guide/?amp=1</a></p><h2 id="将OC替换为release版本"><a href="#将OC替换为release版本" class="headerlink" title="将OC替换为release版本"></a>将OC替换为release版本</h2><p>按照官方文档说明，只需要替换一下几个文件即可</p><ul><li>EFI&#x2F;BOOT&#x2F;<ul><li><code>BOOTx64.efi</code></li></ul></li><li>EFI&#x2F;OC&#x2F;Drivers&#x2F;<ul><li><code>OpenRuntime.efi</code></li><li><code>OpenCanopy.efi</code>(if you’re using it)</li></ul></li><li>EFI&#x2F;OC&#x2F;<ul><li><code>OpenCore.efi</code></li></ul></li></ul><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol><li><p>启动没有catalina<br>新版本有新字段会屏蔽Catalina 的引导，需要将<code>UEFI-&gt;APFS-&gt;MinDate</code> <code>UEFI-&gt;APFS-&gt;MinVersion</code>两个字段置为 <code>-1</code></p></li><li><p>启动报错，一秒后自动重启到恢复模式<br>升级对应的kext 驱动文件为最新，可以使用 OCA升级</p></li><li><p>随航功能异常，表现为能够正常连接上ipad，但是ipad一直黑屏<br>这是因为BIOS重置后核显未启用导致的，需要在BIOS中启用核显。启用核显后应该如下图所示：<img src="http://qiniu.kangqingfei.cn/typora/img/202303051418712.png" alt="0"></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;opencore-升级&quot;&gt;&lt;a href=&quot;#opencore-升级&quot; class=&quot;headerlink&quot; title=&quot;opencore 升级&quot;&gt;&lt;/a&gt;opencore 升级&lt;/h1&gt;&lt;h2 id=&quot;当前版本备份&quot;&gt;&lt;a href=&quot;#当前版本备份&quot; class=&quot;headerlink&quot; title=&quot;当前版本备份&quot;&gt;&lt;/a&gt;当前版本备份&lt;/h2&gt;&lt;p&gt;&lt;code&gt; sudo diskutil mount /dev/disk0s1&lt;/code&gt; 挂载EFI分区&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cp -rf EFI ~/Desktop/EFI_OLD&lt;/code&gt; 备份&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo diskutil umount /dev/disk0s1&lt;/code&gt; 取消挂载&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tree -I &amp;quot;config_list_bak|Resources&amp;quot; -L 3&lt;/code&gt; 查看当前文件目录结构&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;-I&lt;/code&gt; 表示忽略对应的文件夹 &lt;code&gt;-L&lt;/code&gt; 表示最多查看的层级&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="hackintosh" scheme="http://kangqingfei.cn/tags/hackintosh/"/>
    
  </entry>
  
  <entry>
    <title>typora config pic save action</title>
    <link href="http://kangqingfei.cn/2022/12/11/typora-config-picture-save-action/"/>
    <id>http://kangqingfei.cn/2022/12/11/typora-config-picture-save-action/</id>
    <published>2022-12-10T16:00:00.000Z</published>
    <updated>2022-12-10T16:30:34.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="typora-图片存储"><a href="#typora-图片存储" class="headerlink" title="typora 图片存储"></a>typora 图片存储</h2><p>之前在typora里面写笔记的时候是会把图片文件复制到当前文件的同级image目录，并使用<code>![xxx](image/xxx.png)</code>的方式来引用。这样做的好处是可以把不同文本引用的图片源文件保存在不同的目录方便管理和迁移，但是这样有个缺点是如果需要将写完的md发布到例如知乎，掘金等其他平台的时候就需要再操作一次图片上传。发布到自己的hexo blog 也需要重新传一次（这里我使用的是不同的bucket会导致文件重复占用存储）。所以希望的是<code>所拷即所得</code>的方式把md在不同平台的发布方式通用化。</p><span id="more"></span><h3 id="七牛云迁移"><a href="#七牛云迁移" class="headerlink" title="七牛云迁移"></a>七牛云迁移</h3><p>七牛云算是老牌的图床服务商了，第一次使用是在2015年的样子，后面hexo的blog又使用了它，并且之前提供了个性化的域名。但是之前发现自己的blog的图很多都挂了， 看了下应该是自定义域名不可用了，文件都还在。上次重新折腾了一下hexo适配了七牛云。主要需要注意的是如果是之前的文件正常都在国内的区域存储，但是自己的域名又没有备案，就没法绑定国内区域的存储。这时有两个方法，一个是给域名备案；另一个是将文件重新上传（有源文件的情况下）或者通过机房同步的方式转移到海外存储区域，例如<code>亚太-新加坡（原东南亚）</code>。</p><h3 id="typora-图床配置"><a href="#typora-图床配置" class="headerlink" title="typora 图床配置"></a>typora 图床配置</h3><p>研究了一下<code>typora</code>（主要是今天花了¥89）的图片上传组件，是支持<code>Picgo</code>这类图传应用的。而<code>Picgo</code>又是支持 七牛云，正好自己的hexo 也是使用七牛云作为插件，这里就可以实现上面的<code>所拷即所得</code>，大概的方式如下：</p><ul><li>使用 <code>typora</code> 进行文字编写，并使用图片自动上传的功能将图片传到 <code>Picgo</code> 服务，然后将链接插入md文件</li><li><code>Picgo</code>服务将图片上传到七牛云指定的 bucket </li><li>如果需要发布到其他平台只需要将源文件拷贝到指定的平台即可</li></ul><h4 id="Picgo-配置"><a href="#Picgo-配置" class="headerlink" title="Picgo 配置"></a>Picgo 配置</h4><p>Picgo 下载地址： <a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p><p>下载好安装就好，然后配置七牛云，主要是配置aksk，自定义的域名，以及自定义的路径。这里的路径其实是虚拟的路径的概念，因为目前的图片用的都是对象存储，所以所谓的路径只是文件的名称里面多了一个<code>\</code>符号而已。</p><p><img src="http://qiniu.kangqingfei.cn/typora/img/image-20221210232244537.png" alt="image-20221210232244537"></p><p>需要注意的是存储区域的设置，这里在七牛云没看到对应的说明，但是我看好像sdk的日志里面会提示，用提示的区域代码就好，类似下面这种<img src="http://qiniu.kangqingfei.cn/typora/img/20221210184311.png" alt="20221210184311"></p><p>配置好之后可以在typora里面选用 Picgo 作为图片上传应用，并可以测试目前服务是否正常使用。</p><p>上面说了直接上传到图床会把图片源文件都放到云服务商上面，如果服务商跑路就很危险，那么如何避免呢？这里使用了折衷的方式，就是typora对于图片的处理规则还是复制到当前目录，如果这个md文档需要在不同的地方发布的话就在发布前将文件手动点下上传。<img src="http://qiniu.kangqingfei.cn/typora/img/image-20221210235756564.png" alt="image-20221210235756564"></p><p>更多关于typora中图片的操作可以参考：<a href="https://support.typora.io/Images/">https://support.typora.io/Images/</a></p><p>值得一提的是typora还支持使用<code>YAML front matter</code>来指定图片存储的目录，对应的字段是<code>typora-root-url</code>写法可以如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">typora-root-url:</span> <span class="string">images</span></span><br><span class="line"><span class="attr">typora-copy-images-to:</span> <span class="string">upload</span> <span class="comment"># 针对插入文件时应该执行的策略，目录地址或上传</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>YAML 可以放在文件头用来定义文件的一下 meta data，从而可以很好兼容例如 hexo 的分类及tag功能，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">YAML</span> <span class="string">Front</span> <span class="string">Matter</span></span><br><span class="line"><span class="attr">category:</span> <span class="string">how-to</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">typora.io</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">YAML</span>, <span class="string">metadata</span>, <span class="string">tags</span>]</span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>另外，当将md文件导出成 pdf 或 epub 文件时，这些元信息也将被导出并使用.具体说明参考: <a href="https://support.typora.io/YAML/">https://support.typora.io/YAML/</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;typora-图片存储&quot;&gt;&lt;a href=&quot;#typora-图片存储&quot; class=&quot;headerlink&quot; title=&quot;typora 图片存储&quot;&gt;&lt;/a&gt;typora 图片存储&lt;/h2&gt;&lt;p&gt;之前在typora里面写笔记的时候是会把图片文件复制到当前文件的同级image目录，并使用&lt;code&gt;![xxx](image/xxx.png)&lt;/code&gt;的方式来引用。这样做的好处是可以把不同文本引用的图片源文件保存在不同的目录方便管理和迁移，但是这样有个缺点是如果需要将写完的md发布到例如知乎，掘金等其他平台的时候就需要再操作一次图片上传。发布到自己的hexo blog 也需要重新传一次（这里我使用的是不同的bucket会导致文件重复占用存储）。所以希望的是&lt;code&gt;所拷即所得&lt;/code&gt;的方式把md在不同平台的发布方式通用化。&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="typora" scheme="http://kangqingfei.cn/tags/typora/"/>
    
  </entry>
  
  <entry>
    <title>fix-problems-for-hexo-theme-yilia</title>
    <link href="http://kangqingfei.cn/2022/11/23/fix-problems-for-hexo-theme-yilia/"/>
    <id>http://kangqingfei.cn/2022/11/23/fix-problems-for-hexo-theme-yilia/</id>
    <published>2022-11-23T15:58:46.000Z</published>
    <updated>2022-12-19T14:29:24.696Z</updated>
    
    <content type="html"><![CDATA[<p>从上一篇博文（2018-03-02）到现在已经过去了将近5年的时间了。这5年里经历了秋招找工作，研究生毕业，工作，跳槽等等很多很多的事情。但是时间就像流水一样流过，没有留下任何痕迹。所以最近又重新拾起之前的blog，开始记录，不是说 好记性不如烂笔头。</p><p>作为开局，由于时间有点晚了，先记录一下怎么把blog找回来的吧。</p><span id="more"></span><p>主要解决了下面几个问题：</p><ol><li><p>放在qiniu的图传丢失，域名被废弃，这里需要去七牛重新配一下自定义域名，之前的插件也还能用，更新一下bucket和密钥就好。</p></li><li><p>主题中的js丢失，主要是有些cdn跑路了</p><ul><li><p><a href="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min">http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min</a> 这个cdn没用了，需要把对应的js下载下来，对应的链接分别是 </p><ul><li><a href="https://requirejs.org/docs/release/2.1.6/minified/require.js">https://requirejs.org/docs/release/2.1.6/minified/require.js</a></li><li><a href="https://code.jquery.com/jquery-1.9.1.min.js">https://code.jquery.com/jquery-1.9.1.min.js</a></li></ul><p>可以放到qiniu的cdn，也可以放在站内，本着主题和资源分开的考虑没有放到cdn，放在了主题的<code>/source/js/</code>目录下面。</p><p>然后还需要更改一下<code>layout/_partial/after-footer.ejs</code>文件中引入的方式：</p><ul><li><code>&lt;%- js(&#39;http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min&#39;) %&gt;</code></li></ul><p>改为</p><ul><li><code>&lt;%- js(&#39;js/jquery-1.9.1.min&#39;) %&gt;</code></li><li><code>&lt;%- js(&#39;js/require-2.1.6&#39;) %&gt;</code></li></ul></li></ul></li><li><p>卜算子的文章pv统计功能丢失了，主要原因也是cdn失效了，找一个代替的就好，修改文件<code>layout/_partial/after-footer.ejs</code></p><ul><li><p><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p><p>改为</p></li><li><p><code>&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p></li></ul></li><li><p>前进后退按钮出现了问题</p><ul><li>这个是由于解析<code>&amp;laquo</code>出现问题导致，直接把对应的字符改成<code>«</code> 以及 <code>»</code> 参考：<a href="https://wuyi2.github.io/2020/02/14/hexo-yilia%E4%B8%BB%E9%A2%98%E7%BF%BB%E9%A1%B5%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3/">博客翻页键bug</a></li></ul></li><li><p>修复了部分错别字和加载问题</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上一篇博文（2018-03-02）到现在已经过去了将近5年的时间了。这5年里经历了秋招找工作，研究生毕业，工作，跳槽等等很多很多的事情。但是时间就像流水一样流过，没有留下任何痕迹。所以最近又重新拾起之前的blog，开始记录，不是说 好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;作为开局，由于时间有点晚了，先记录一下怎么把blog找回来的吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://kangqingfei.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>c++ lambda 表达式</title>
    <link href="http://kangqingfei.cn/2018/03/02/c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://kangqingfei.cn/2018/03/02/c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2018-03-02T00:56:16.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录lambda表达式的-基本语法-以及-常见的应用场景"><a href="#记录lambda表达式的-基本语法-以及-常见的应用场景" class="headerlink" title="记录lambda表达式的 基本语法 以及 常见的应用场景"></a>记录lambda表达式的 <code>基本语法</code> 以及 <code>常见的应用场景</code></h3><span id="more"></span><h3 id="Lambda的基本形式"><a href="#Lambda的基本形式" class="headerlink" title="Lambda的基本形式"></a>Lambda的基本形式</h3><ol><li>Lambda 表达式，也叫 Lambda 函数，也就是cpp中的匿名函数。 其实就是一个匿名函数 然后返回函数的调用地址</li><li>基本语法<br><code>[ captures ] &lt;tparams&gt;(可选)(C++20) ( params ) specifiers(可选) exception attr -&gt; ret requires(可选)(C++20) &#123; body &#125;</code><br>例如<code>auto glambda = []&lt;class T&gt;(T a, auto&amp;&amp; b) &#123; return a &lt; b; &#125;;</code></li></ol><ul><li>captures 为捕获列表</li><li>tparams 提供模板形参 用于 实参 确定数据类型</li><li>params 参数列表 不允许默认参数 因此形参的个数和实参的个数一定是一样的。<br>从C++14开始，lambda表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。这就如同函数模板一样，参数要使用类型自动推断功能，只需要将其类型指定为auto，类型推断规则与函数模板一样。这里给出一个简单例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 5</span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>);  <span class="comment">// 6.0</span></span><br></pre></td></tr></table></figure></li><li>specifiers 捕获限定符 一般情况下lambda不会改变使用值捕获的变量的值，如果我们想改变这个值，那么我们必须在参数列表后面跟上关键词mutable</li><li>exception 异常规定</li><li>attr 指定运算符 () 的属性 可以是 <code>const</code> <code>auto &amp; </code> 之类的指定符</li><li>ret requires 返回类型 若缺失，则由函数的 return 语句所隐含（或若函数不返回任何值则为 void ）<br>const lambda 声明：<br><code>[ captures ] ( params ) -&gt; ret &#123; body &#125;</code><br>省略返回值：<br><code>[ captures ] ( params ) &#123; body &#125;</code><br>省略参数列表<br><code>[ captures ] &#123; body &#125;</code></li></ul><p>举几个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br><span class="line">[](<span class="type">int</span>&amp; x) &#123; ++x; &#125;   <span class="comment">// 没有return语句 -&gt; lambda 函数的返回类型是&#x27;void&#x27;</span></span><br><span class="line">[]() &#123; ++global_x; &#125;  <span class="comment">// 没有参数,仅访问某个全局变量</span></span><br><span class="line">[]&#123; ++global_x; &#125;     <span class="comment">// 与上一个相同,省略了()</span></span><br></pre></td></tr></table></figure><h3 id="Lambda-的捕获"><a href="#Lambda-的捕获" class="headerlink" title="Lambda 的捕获"></a>Lambda 的捕获</h3><p>在Lambda中是可以使用局部形参以及全局变量的，但是试图使用任何未捕获的外部变量都是错误的。<br>为此，我们可以使用捕获列表来捕获外部的局部变量并用于lambda中，形式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//未定义变量.试图在Lambda内使用任何外部变量都是错误的.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x 按值捕获, y 按引用捕获 x y 都是外部的函数的局部变量名</span></span><br><span class="line">[&amp;]       <span class="comment">//用到的任何外部变量都隐式按引用捕获</span></span><br><span class="line">[=]       <span class="comment">//用到的任何外部变量都隐式按值捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x显式地按值捕获. 其它变量按引用捕获</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z按引用捕获. 其它变量按值捕获</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; some_list;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) some_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">std::for_each(<span class="built_in">begin</span>(some_list), <span class="built_in">end</span>(some_list), [&amp;total](<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    total += x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;记录lambda表达式的-基本语法-以及-常见的应用场景&quot;&gt;&lt;a href=&quot;#记录lambda表达式的-基本语法-以及-常见的应用场景&quot; class=&quot;headerlink&quot; title=&quot;记录lambda表达式的 基本语法 以及 常见的应用场景&quot;&gt;&lt;/a&gt;记录lambda表达式的 &lt;code&gt;基本语法&lt;/code&gt; 以及 &lt;code&gt;常见的应用场景&lt;/code&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="cpp" scheme="http://kangqingfei.cn/tags/cpp/"/>
    
    <category term="lambda" scheme="http://kangqingfei.cn/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>C++初始化</title>
    <link href="http://kangqingfei.cn/2018/03/01/C-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://kangqingfei.cn/2018/03/01/C-%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2018-03-01T06:45:15.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>默认初始化<br>  这是在不使用初始化器构造变量时执行的初始化</p></li><li><p>使用初始化器进行初始化<br>  按照语境，初始化器可以调用：</p></li><li><p>值初始化，例如 std::string s{};<br>  这是在变量以空初始化器构造时进行的初始化。</p></li><li><p>直接初始化，例如 std::string s(“hello”);<br>  从构造函数参数的显式集合初始化对象</p><span id="more"></span></li><li><p>复制初始化，例如 std::string s &#x3D; “hello”;<br>  从另一对象初始化对象</p></li><li><p>列表初始化，例如 std::string s{‘a’, ‘b’, ‘c’};<br>  从花括号初始化器列表初始化对象</p></li><li><p>聚合初始化，例如 char a[3] &#x3D; {‘a’, ‘b’};<br>  从花括号初始化器列表初始化聚合体<br>聚合初始化是一种初始化聚合体的列表初始化</p></li><li><p>引用初始化，例如 char&amp; c &#x3D; a[0];<br>  绑定引用到对象<br>  包括左值引用的初始化和右值引用的初始化</p></li><li><p>静态初始化</p></li></ul><ol><li>若受允许，则首先发生常量初始化（这些情形见常量初始化）。 实践上，常量初始化通常在编译期进行，而预计算的对象表示作为程序映像的一部分存储。若编译器没有这么做，则亦保证此初始化发生先于任何动态初始化。</li><li>对于所有其他 非局部 静态 及 线程局域变量 ，发生零初始化。 实现中，要被零初始化的变量置于程序映像的 .bss 段，它不占据磁盘空间，并在加载程序时为操作系统以零填充。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">&#125;; <span class="comment">// 隐式默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T2</span>(<span class="type">const</span> T2&amp;) &#123; &#125; <span class="comment">// 用户提供的复制构造函数</span></span><br><span class="line">&#125;;                    <span class="comment">// 无默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T3</span>() &#123; &#125; <span class="comment">// 用户提供的默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> n)</span> : mem(n) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1; <span class="comment">// 静态非类，进行二段初始化： 1) 零初始化初始化 n 为零  2) 默认初始化不做任何事，令 n 为零</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//// 默认初始化  一般是定义变量后未进行任何的操作则触发</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i11; <span class="comment">// 默认初始化 非类 值不确定</span></span><br><span class="line">    <span class="type">int</span>* a11 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 数组 =&gt; 每个元素 默认初始化 每个元素的值为不确定</span></span><br><span class="line">    string str11; <span class="comment">// 默认初始化 类，调用默认构造函数，值是 &quot;&quot; （空字符串）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  int&amp; r;           // 错误：引用</span></span><br><span class="line">    <span class="comment">//  const int n;      // 错误： const 的非类 必须初始化</span></span><br><span class="line">    <span class="comment">//  const T1 t1;      // 错误： const 类带隐式默认构造函数 无法初始化 必须用户提供显式默认构造函数</span></span><br><span class="line"></span><br><span class="line">    T1 t11; <span class="comment">// 类：调用隐式默认构造函数 t1.mem1 值初始化为未确定</span></span><br><span class="line">    <span class="type">const</span> T3 t13;  <span class="comment">// const 类，调用用户提供的默认构造函数 t3.mem1 被默认初始化（为不确定值）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 值初始化 有 () &#123;&#125; 两种空括号形式会触发 值初始化</span></span><br><span class="line">    <span class="type">int</span> n&#123;&#125;;                <span class="comment">// 标量 =&gt; 零初始化，值为 0</span></span><br><span class="line">    <span class="type">double</span> f = <span class="built_in">double</span>();    <span class="comment">// 标量 =&gt; 零初始化，值为 0.0</span></span><br><span class="line">    <span class="type">int</span>* a21 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">// 数组 =&gt; 每个元素的值初始化 每个元素的值为 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    T1 t21&#123;&#125;;                <span class="comment">// 有隐式默认构造函数的类 =&gt; t1.mem1 被零初始化，值为 0  t1.mem2 被默认初始化，值为 &quot;&quot;</span></span><br><span class="line">    <span class="comment">//  T2 t22&#123;&#125;;            // 错误：类无默认构造函数</span></span><br><span class="line">    T3 t23&#123;&#125;;                <span class="comment">// 有用户提供默认构造函数的类 =&gt; t3.mem1 被默认初始化为不确定值  t3.mem2 被默认初始化，值为 &quot;&quot;</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v21</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 值初始化每个元素 每个元素的值为 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 直接初始化 直接调用构造函数的形式会触发直接初始化 以 object(kkk) new object(kkk) object():men(kkk)（构造函数初始化器列表） [arg]()&#123;&#125; 等形式触发</span></span><br><span class="line">    <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>; <span class="comment">// 自 const char* 的构造函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK ：允许 explicit 构造函数</span></span><br><span class="line">    <span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // 错误：构造函数为 explicit</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// f 被直接初始化： 构造函数参数 n 从右值 2 复制初始化  f.mem 从参数 n 直接初始化</span></span><br><span class="line">    <span class="comment">//  Foo f2 = 2; // 错误：构造函数为 explicit 会阻止复制初始化的发生</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 复制初始化 以（ 等号 传参 抛出异常 返回值 ）的形式用一个对象初始化另一个对象</span></span><br><span class="line">    <span class="comment">//// explicit 可以禁止复制初始化的发生</span></span><br><span class="line">    <span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // 错误：unique_ptr 构造函数为 explicit 试图进行复制初始化</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK ：直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 列表初始化  以花括号的形式触发 一般触发列表初始化后 会触发 复制初始化( obj ttt=&#123;kkk&#125; )或者是值初始化( obj(&#123;kkk&#125;) )</span></span><br><span class="line">    <span class="type">double</span> d = <span class="type">double</span>&#123;<span class="number">1.2</span>&#125;; <span class="comment">// 临时量的列表初始化，然后复制初始化</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123; <span class="comment">// 嵌套列表初始化</span></span><br><span class="line">      &#123;<span class="number">1</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125; &#125;,</span><br><span class="line">      &#123;<span class="number">3</span>, s1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认初始化&lt;br&gt;  这是在不使用初始化器构造变量时执行的初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用初始化器进行初始化&lt;br&gt;  按照语境，初始化器可以调用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;值初始化，例如 std::string s{};&lt;br&gt;  这是在变量以空初始化器构造时进行的初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接初始化，例如 std::string s(“hello”);&lt;br&gt;  从构造函数参数的显式集合初始化对象&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="cpp" scheme="http://kangqingfei.cn/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题解</title>
    <link href="http://kangqingfei.cn/2018/02/28/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/"/>
    <id>http://kangqingfei.cn/2018/02/28/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/</id>
    <published>2018-02-28T01:28:23.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指Offer刷题-链接"><a href="#剑指Offer刷题-链接" class="headerlink" title="剑指Offer刷题 链接"></a>剑指Offer刷题 <a href="https://www.nowcoder.com/ta/coding-interviews?page=1">链接</a></h2><h3 id="共66题-历时-2018-02-28-2018-03-01-共2天"><a href="#共66题-历时-2018-02-28-2018-03-01-共2天" class="headerlink" title="共66题 历时 2018.02.28-2018.03.01 共2天"></a>共66题 历时 2018.02.28-2018.03.01 共2天</h3><span id="more"></span><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.28</p><ol><li><p>二维数组中的查找 较为简单<br>类似于二分的思路，先找到中间的数（广义中位数），然后每次缩小一大块空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> line = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(line == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> row = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = line - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; array[i][j])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>替换空格<br>从尾部进行处理以防止头部数据被覆盖 简单字符串处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> nonspace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *tmp = str;</span><br><span class="line">    <span class="keyword">while</span>(*tmp != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            nonspace++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(str+i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span><span class="number">-2</span>) = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span><span class="number">-1</span>) = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span>) = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            nonspace--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *(str+nonspace*<span class="number">2</span>+i) = *(str+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从尾到头打印链表<br>简单递归处理链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; re;</span><br><span class="line">    <span class="built_in">printList</span>(head,re);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode *node,vector&lt;<span class="type">int</span> &gt; &amp;re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printList</span>(node-&gt;next,re);</span><br><span class="line">    re.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重建二叉树<br>中等难度的 递归问题，记得划分子问题的时候，子问题的解决方法应该与原问题一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//// 记住 递归类的问题的子问题一定是与原问题给出的信息等价 也就是 子问题与原问题完全一致</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">reCon</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin, <span class="type">int</span> pLeft, <span class="type">int</span> pRight, <span class="type">int</span> vStart, <span class="type">int</span> vEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pLeft &gt; pRight || vStart &gt; vEnd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;pLeft&lt;&lt;&quot; &quot;&lt;&lt;pRight&lt;&lt;&quot; &quot;&lt;&lt;vStart&lt;&lt;&quot; &quot;&lt;&lt;vEnd&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[pLeft]);</span><br><span class="line">    <span class="keyword">if</span>(pLeft == pRight || vStart == vEnd)<span class="comment">//到达叶子节点,不需要寻找左右节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = vStart; i &lt;= vEnd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[pLeft] == vin[i])<span class="comment">// 找到在中序遍历中的下标进行划分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">reCon</span>(pre,vin,pLeft+<span class="number">1</span>,pLeft+count,vStart,vStart+count<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">reCon</span>(pre,vin,pLeft+count+<span class="number">1</span>,pRight,vStart+count+<span class="number">1</span>,vEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">    TreeNode* root = <span class="built_in">reCon</span>(pre,vin,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,vin.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; pre = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; vin = &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">reConstructBinaryTree</span>(pre,vin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>用两个栈实现队列<br>简单的栈处理 一个用于push 一个用于pop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>旋转数组的最小数字<br>简单的二分思想的运用，当一个序列可以用函数的单调性来描述的时候就会使用二分<br>但是要注意单调不减 所以注意等号的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rArr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end - start &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rArr[start],rArr[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(rArr[middle] &gt;= rArr[start] &amp;&amp; rArr[middle] &gt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rArr,middle,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rArr[middle] &lt;= rArr[start] &amp;&amp; rArr[middle] &lt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rArr,start,middle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rArr[middle] &lt;= rArr[start] &amp;&amp; rArr[middle] &gt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> rArr[middle];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rotateArray,<span class="number">0</span>,rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列<br>非常简单的递归转动态规划(或迭代)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> tmp;</span><br><span class="line">   <span class="keyword">while</span>(i++ &lt;= n)</span><br><span class="line">   &#123;</span><br><span class="line">       tmp = f2;</span><br><span class="line">       f2 = f1 + f2;</span><br><span class="line">       f1 = tmp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>跳台阶<br>上题的变种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tmp, index = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(index++ &lt;= number)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = f2;</span><br><span class="line">        f2 = f1+f2;</span><br><span class="line">        f1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变态跳台阶<br>数学归纳法找规律的题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,number<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩形覆盖<br>斐波那契数列变种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> tmp,f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt;= number)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = f2;</span><br><span class="line">            f2 = f1+f2;</span><br><span class="line">            f1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二进制中1的个数<br>简单的数值处理 记得有负数不能用移位然后与1与的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(n)</span><br><span class="line">     &#123;</span><br><span class="line">         count++;</span><br><span class="line">         n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>数值的整数次方<br>简单数值处理（也是二分） 注意细节 指数为0 指数为负 指数为奇数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> neg = exponent &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ood = exponent % <span class="number">2</span>;</span><br><span class="line">    exponent = <span class="built_in">abs</span>(exponent);</span><br><span class="line">    <span class="type">double</span> re = base;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(exponent != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            re = re*re;</span><br><span class="line">            exponent/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ood)</span><br><span class="line">            re = re*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neg ? <span class="number">1</span>/re : re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调整数组顺序使奇数位于偶数前面<br>数组 处理 在空间不允许的情况下（不要求位置不变） 可以 用两个指针 指向头和尾，然后交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    array = re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表中倒数第k个结点<br>简单的链表处理，头尾两个指针进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* tmp = pListHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        pListHead = pListHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pListHead;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反转链表<br>中等难度的链表处理，千万要注意细节，就是指针为空的时候<br>然后有递归（难理解 简洁）和迭代两种方式来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 反转链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) :</span><br><span class="line">        <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现，注意空指针的判断，否则直接段错误</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>,*tmp2;</span><br><span class="line">    <span class="keyword">while</span>(pHead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp2 = pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next = pre;</span><br><span class="line">        pre = pHead;</span><br><span class="line">        pHead = tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    pHead-&gt;next = pre;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="function">ListNode* <span class="title">RecReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">nullptr</span> || pHead == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *pre = <span class="built_in">RecReverseList</span>(pHead-&gt;next);</span><br><span class="line">    <span class="comment">// 注意每次 pHead 这个局部变量的存在，都是指向之前的指针，相当于每次pHead 的值是栈顶的值</span></span><br><span class="line">    pHead-&gt;next-&gt;next = pHead;</span><br><span class="line">    pHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *pHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *ptmp = pHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        ptmp = ptmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RecReverseList</span>(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>合并两个排序的链表<br>简单的链表处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> &amp;&amp; pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead1 != <span class="literal">nullptr</span> &amp;&amp; pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> &amp;&amp; pHead2 != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line"></span><br><span class="line">    ListNode *head, *tmp;</span><br><span class="line">    <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head = pHead1;</span><br><span class="line">        pHead1 = pHead1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pHead2;</span><br><span class="line">        pHead2 = pHead2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(pHead1 != <span class="literal">nullptr</span> &amp;&amp; pHead2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = pHead1;</span><br><span class="line">            tmp = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = pHead2;</span><br><span class="line">            tmp = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next = pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next = pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>树的子结构<br>aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>二叉树的镜像<br>aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 3.1</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指Offer刷题-链接&quot;&gt;&lt;a href=&quot;#剑指Offer刷题-链接&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer刷题 链接&quot;&gt;&lt;/a&gt;剑指Offer刷题 &lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;链接&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;共66题-历时-2018-02-28-2018-03-01-共2天&quot;&gt;&lt;a href=&quot;#共66题-历时-2018-02-28-2018-03-01-共2天&quot; class=&quot;headerlink&quot; title=&quot;共66题 历时 2018.02.28-2018.03.01 共2天&quot;&gt;&lt;/a&gt;共66题 历时 2018.02.28-2018.03.01 共2天&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>腾讯 2017 暑期实习生编程题</title>
    <link href="http://kangqingfei.cn/2018/02/26/%E8%85%BE%E8%AE%AF-2017-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/02/26/%E8%85%BE%E8%AE%AF-2017-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <published>2018-02-26T02:06:34.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="腾讯2017暑期实习生编程题"><a href="#腾讯2017暑期实习生编程题" class="headerlink" title="腾讯2017暑期实习生编程题"></a>腾讯2017暑期实习生编程题</h3><p><a href="https://www.nowcoder.com/test/1725829/summary">链接</a></p><span id="more"></span><ol><li>构造回文子串</li></ol><p>按照 回文字符串的性质 可以知道 此题 就是求 原串与翻转后的字符串的 lcs 的值。</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcs</span><span class="params">(string &amp;str1, string &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> dp[len+<span class="number">1</span>][len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDelStr</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = str;</span><br><span class="line">    <span class="built_in">reverse</span>(str1.<span class="built_in">begin</span>(),str1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()-<span class="built_in">lcs</span>(str,str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">minDelStr</span>(str)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这题比较奇葩，首先想到的就是冒泡排序的思想，但是看到有人遍历了两遍然后输出的奇淫技巧只能大喊666</li></ol><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AkleBiCeilD</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = str.<span class="built_in">length</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; str.<span class="built_in">length</span>() &amp;&amp; str[j+<span class="number">1</span>] &gt;= <span class="string">&#x27;a&#x27;</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>这个题咋看简单其实还是很多错误的思路的。比如 当最小差为0 时 便不能应用最小差不为0的求解方法，因为当前数字可能与之前的之前的数字进行组合</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>链接：<a href="https://www.nowcoder.net/questionTerminal/af709ab9ca57430886632022e543d4c6">https://www.nowcoder.net/questionTerminal/af709ab9ca57430886632022e543d4c6</a><br>来源：牛客网</p><p>1.先排序<br>     特殊情况：如果排完序之后发现数组中所有数都相同，直接输出结果<br>         结果为：差最大个数 &#x3D; 差最小个数 &#x3D; （n * (n-1))&#x2F;2;(两两组合)<br>2.统计数组中每种数字的个数（这里用的map）<br>3.计算差最小个数<br>    3.1.如果数组中没有重复数字，说明最小差不为0，最小差肯定是数组中相邻两个数的差<br>        因此，遍历一边数组，计算并统计最小差。<br>    3.2.如果数组中有重复数字，说明最小差是0，此时，遍历一边map，数字个数不为0的<br>        数字会产生最小差0，利用公式计算即可<br>4.计算差最大个数     <br>    只有一种情况，最大值与最小值的两两组合，即最大值个数 * 最小值个数<br>        算法复杂度：排序O(nlogn), 统计O(n)</p><h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span> &gt; arr;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>,maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX, minCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">                minCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == min)</span><br><span class="line">            &#123;</span><br><span class="line">                minCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == max)</span><br><span class="line">            &#123;</span><br><span class="line">                maxCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> minTmp = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sameCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>()<span class="number">-1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] &lt; minTmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sameCount = <span class="number">1</span>;</span><br><span class="line">                minTmp = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] == minTmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sameCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minTmp == <span class="number">0</span>)<span class="comment">//最小差为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> repCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] == arr[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++repCount;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;repCount&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxCount*minCount&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;sameCount&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxCount*minCount&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;腾讯2017暑期实习生编程题&quot;&gt;&lt;a href=&quot;#腾讯2017暑期实习生编程题&quot; class=&quot;headerlink&quot; title=&quot;腾讯2017暑期实习生编程题&quot;&gt;&lt;/a&gt;腾讯2017暑期实习生编程题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/test/1725829/summary&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="tencent" scheme="http://kangqingfei.cn/tags/tencent/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://kangqingfei.cn/2018/02/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://kangqingfei.cn/2018/02/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2018-02-26T01:48:13.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>一种方法是通过翻转字符串，然后依靠最长公共子串（而不是子序列，子序列可以用来构造回文子串）的方法来求解</p><span id="more"></span><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><ul><li>首先通过向字符中添加 # 把原字符需要划分奇数偶数的处理变成了 统一处理</li><li>其次 维护 一个 P[i] 表示 以当前为中心向两边扩展的回文长度，id 当前最长的回文子串的中心， mx &#x3D; id + P[id] 为字符串的边界。</li><li>关键思想是P[i]的更新是需要技巧的。  若 mx &gt; i 则 P[i] &gt;&#x3D; min(P[2*id-i],mx-i) 若 mx &lt;&#x3D; i 则 P[i] &#x3D; 1</li><li>该思想是通过 <code>对称点来初始化 P[i]</code> 若对称点的 回文子串包含在 目前最长串内 则初始化为与对称点一致 P[i] &#x3D; P[2*id-1] 否则 对称点的回文子串超出最长子串界限，则P[i]在最长回文子串内的那段（长度mx-i）必定是回文的， 但后续情况未知，P[i] &#x3D; mx-i<br><a href="https://www.felix021.com/blog/read.php?2040">参考</a></li></ul><p>参考代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>,mx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> P[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        P[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx - i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            P[i] = <span class="built_in">min</span>(P[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i+P[i]] == str[i-P[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有两种情况需要更新 一种是 找到了更长的回文子串，一种是当前的遍历下标已经超过了最长的那个回文子串的边界(开始新的一轮) 分别对应 P[i] 大 和 i 大</span></span><br><span class="line">        <span class="keyword">if</span>(P[i]+i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            mx = P[i]+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp = P[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> index =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(P[i] &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = P[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    <span class="type">int</span> start = index/<span class="number">2</span> - tmp/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = index/<span class="number">2</span> + (tmp<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    re.<span class="built_in">push_back</span>(start);</span><br><span class="line">    re.<span class="built_in">push_back</span>(end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">preProcess</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string reStr = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        reStr += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        reStr += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    reStr += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> reStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="string">&quot;abccba&quot;</span>;</span><br><span class="line">        string str1 = <span class="built_in">preProcess</span>(str);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">manacher</span>(str1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tmp[<span class="number">0</span>]; i &lt; tmp[<span class="number">1</span>]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;str[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h2&gt;&lt;p&gt;一种方法是通过翻转字符串，然后依靠最长公共子串（而不是子序列，子序列可以用来构造回文子串）的方法来求解&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LCS与编辑距离以及MCSS</title>
    <link href="http://kangqingfei.cn/2018/02/04/LCS%E4%B8%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://kangqingfei.cn/2018/02/04/LCS%E4%B8%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2018-02-04T08:02:09.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。"><a href="#LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。" class="headerlink" title="LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 子序列 而不是 子串 的最大的长度。"></a>LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 <code>子序列</code> 而不是 <code>子串</code> 的最大的长度。</h2><p>之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。</p><span id="more"></span><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>设定 dp[i][j] 为str(0…i) 与 patten(0…j) 的最长子公共子序列的长度</li></ul><ol><li>初始化 数组的 0 下标为零，然后更新 dp[i][j];</li><li>若 <code>str[i] == patten[j]</code> 则<code>dp[i][j] = dp[i-1][j-1]</code>，若 <code>str[i] != patten[j]</code> 则 <code>dp[i][j] = max(dp[i][j-1],dp[i-1][j])</code></li><li>迭代更新 dp[i][j]</li></ol><h3 id="最长子序列输出"><a href="#最长子序列输出" class="headerlink" title="最长子序列输出"></a>最长子序列输出</h3><ol><li>若 <code>str[i] == patten[j]</code>，则输出 str[i] （导致反向输出）</li><li>若 <code>str[i] != patten[j]</code>，则判断 dp[i][j] 是等于上方的(i–)还是下方的(j–)，然后移到该方向。</li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LCS 问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcs</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> string &amp;patten)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> strSize = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pattenSize = patten.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[strSize+<span class="number">1</span>][pattenSize+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= strSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pattenSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-1</span>] == patten[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = strSize;</span><br><span class="line">    <span class="type">int</span> j = pattenSize;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; re;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i<span class="number">-1</span>] == patten[j<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(str[i<span class="number">-1</span>]);</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(re.<span class="built_in">begin</span>(),re.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:re)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;kangqingfei&quot;</span>;</span><br><span class="line">    string patten = <span class="string">&quot;ng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lcs</span>(str,patten);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编辑距离问题-Edit-Distance"><a href="#编辑距离问题-Edit-Distance" class="headerlink" title="编辑距离问题(Edit Distance)"></a>编辑距离问题(Edit Distance)</h2><p>编辑距离和LCS很像，只是更新 dp[i][j] 的时候略有不同而已</p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>设定 dp[i][j] 为 str1(0…i) 与 str2(0…j) 的编辑距离</li></ul><ol><li>初始化 dp[0][j] 和 dp[i][0] 为 j 和 i  其含义为，一个字符串与一个空串的编辑距离为字符串本身的长度</li><li>更新dp[i][j],更新规则为，若 str1[i] &#x3D;&#x3D; str2[j] 则dp[i][j] &#x3D; dp[i-1][j-1] 若 str1[i] !&#x3D; str2[j] 则考虑 str1 不变，str2 可以通过 增加(dp[i-1][j] + 1) 删除(dp[i][j-1] + 1) 替换(dp[i-1][j-1] + 1) 变到str1</li><li>迭代更新 dp[i][j], 输出dp[iMax][jMax] 即为编辑距离</li></ol><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">editDistance</span>(string str1, string str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length1 = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length2 = str2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[length1+<span class="number">1</span>][length2+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= length2; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//                     增加       删除          替换</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[length1][length2]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;kangqingfei&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;kangqingfeng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">editDistance</span>(str1,str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h2><p>该问题与 LCS 问题的区别就在于 是否连续<br>若可以连续就是<code>子串</code> 否则就是<code>子序列</code>。<br>对于子串的解法与子序列的解法基本一致 区别就在于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str1[i] != str2[j])</span><br><span class="line">    dp[i][j] = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后通过 遍历 dp[i][j] 来获得最大的子串长度，然后得到子串<br>在空间优化上面可以通过滚动数组来节省空间</p><h2 id="最大连续序列求和（Maximum-Contiguous-Subsequence-Sum）MCSS-问题"><a href="#最大连续序列求和（Maximum-Contiguous-Subsequence-Sum）MCSS-问题" class="headerlink" title="最大连续序列求和（Maximum Contiguous Subsequence Sum）MCSS 问题"></a>最大连续序列求和（Maximum Contiguous Subsequence Sum）MCSS 问题</h2><p>该问题为求一个序列的所有子序列中 和最大 的那个子序列。<br>该问题为简单的动态规划问题</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcss</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dp[len];</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> ? arr[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>]:arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; maxSum)</span><br><span class="line">            maxSum = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcssPlus</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span><span class="comment">//空间优化版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmpDp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmpDp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpDp += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpDp = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpDp &gt; maxSum)</span><br><span class="line">            maxSum = tmpDp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 -2 11 -4 13 -5 -2 -&gt; 20</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count,tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">mcssPlus</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。&quot;&gt;&lt;a href=&quot;#LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。&quot; class=&quot;headerlink&quot; title=&quot;LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 子序列 而不是 子串 的最大的长度。&quot;&gt;&lt;/a&gt;LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 &lt;code&gt;子序列&lt;/code&gt; 而不是 &lt;code&gt;子串&lt;/code&gt; 的最大的长度。&lt;/h2&gt;&lt;p&gt;之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="编辑距离" scheme="http://kangqingfei.cn/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>最长无重复子串</title>
    <link href="http://kangqingfei.cn/2018/01/27/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <id>http://kangqingfei.cn/2018/01/27/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</id>
    <published>2018-01-27T07:24:09.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<p>与 <code>最长重复子串</code> 不一样的是，此问题要求所有子串中 没有重复字母的 子串中长度最长为多少。</p><p>题目来源 为 Leetcode 第三题 <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Longest Substring Without Repeating Characters</a></p><span id="more"></span><ul><li>基本思路是用的滑动窗口来遍历每个起始点的 无重复子串的 长度 ， 然后取得最大的长度。</li></ul><p>首先来个简单易懂的  每次清空hash表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str = s;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">            map[str[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; str.<span class="built_in">length</span>() &amp;&amp; map[str[j]] != <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                map[str[j]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j - i &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                 max = j - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样的思路，来个升级版 时间复杂度 O(2n) <code>abababababab</code>这种为最坏情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string str = s;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len &amp;&amp; j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(map[str[j]] == <span class="number">1</span>)<span class="comment">//左边前移 区间变短</span></span><br><span class="line">        &#123;</span><br><span class="line">            map[str[i++]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右边前移 区间变长 更新 max</span></span><br><span class="line">        &#123;</span><br><span class="line">            map[str[j++]]++;</span><br><span class="line">            <span class="keyword">if</span>(j - i &gt; max)</span><br><span class="line">                max = j - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;与 &lt;code&gt;最长重复子串&lt;/code&gt; 不一样的是，此问题要求所有子串中 没有重复字母的 子串中长度最长为多少。&lt;/p&gt;
&lt;p&gt;题目来源 为 Leetcode 第三题 &lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/description/&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="hash" scheme="http://kangqingfei.cn/tags/hash/"/>
    
    <category term="滑动窗口" scheme="http://kangqingfei.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>最长重复子串-LRS</title>
    <link href="http://kangqingfei.cn/2018/01/25/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2-LRS/"/>
    <id>http://kangqingfei.cn/2018/01/25/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2-LRS/</id>
    <published>2018-01-25T11:06:52.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS"><a href="#此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS" class="headerlink" title="此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS"></a>此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS</h3><span id="more"></span><p>针对子串是否重叠，又可以分为<code>可重叠的最长重复子串</code> 和 <code>不可重叠的重复子串</code>。</p><ul><li>可重叠的最长重复子串   参考<a href="http://www.voidcn.com/article/p-yjvdpysb-bee.html">后缀数组求最长重复子串</a><br>有关更多后缀数组的题 参考 vjudge-&gt;<a href="https://vjudge.net/contest/58608#overview">后缀数组入门</a></li></ul><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><ol><li>通过后缀数组找到所有的子串</li><li>排序得到前后关联比较大的子串序列。注意排序完成后 <em>对于一个子串，一个与其重复最多的字符串肯定是紧挨着自己的两个字符串</em></li><li>遍历每个子串，将其与前后两个子串相比较，得到两者相同长度较大的一者</li><li>遍历所有得到的相同的长度，取最大的就是最长的公共子串</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例如： banana 可以重复的最长子串是 ana<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCommonLnegth</span><span class="params">(string &amp;self, string &amp;compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">min</span>(self.<span class="built_in">length</span>(),compare.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(self[j] != compare[j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string words = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    vector&lt;string &gt; suffix;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = words.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//int count = len;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        suffix.<span class="built_in">push_back</span>(words.<span class="built_in">substr</span>(i,len-i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对后缀数组进行排序</span></span><br><span class="line">    <span class="comment">// 注意到 排序完成之后 每个子序列的最长重复的另一子序列要么在其前面，要么在其后面</span></span><br><span class="line">    <span class="built_in">sort</span>(suffix.<span class="built_in">begin</span>(),suffix.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">commonLen</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到每个子序列的最长重复长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != len <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             commonLen[i] = <span class="built_in">max</span>(<span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i<span class="number">-1</span>]),<span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            commonLen[i] = <span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == len <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            commonLen[i] = <span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>,maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; commonLen[i])</span><br><span class="line">        &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxLen = commonLen[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;suffix[index][i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不可重叠最长重复子串<br>顾名思义，前后的子串是在不能重叠的情况下面的最长的重复的长度</li></ul><h3 id="类似题型变种还有"><a href="#类似题型变种还有" class="headerlink" title="类似题型变种还有:"></a>类似题型变种还有:</h3><ol start="0"><li><a href="http://blog.csdn.net/qinzhenhua100/article/details/39968291">最长不重叠重复子串 POJ 1743</a></li><li><a href="http://blog.csdn.net/ACdreamers/article/details/9121117">可重叠的K次最长重复子串(POJ 3261)</a></li><li><a href="http://forever97.is-programmer.com/2016/8/12/spoj687.204992.html">重复次数最多的连续重复子串的长度(SPOJ 687)</a></li><li><a href="http://blog.csdn.net/ZouCharming/article/details/46699583">求重复次数最多的子串 POJ 3693</a></li><li><a href="http://blog.csdn.net/u013351484/article/details/43113201">至少重复k次的可重叠的最长重复子串 POJ 3882</a></li><li><a href="http://www.cnblogs.com/zichi/p/4841878.html">RMQ (Range Minimum&#x2F;Maximum Query) 求解中的 ST 算法</a></li><li><a href="http://dongxicheng.org/structure/lca-rmq/">LCA 与 RMQ</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS&quot;&gt;&lt;a href=&quot;#此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS&quot; class=&quot;headerlink&quot; title=&quot;此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS&quot;&gt;&lt;/a&gt;此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="后缀数组" scheme="http://kangqingfei.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="LRS" scheme="http://kangqingfei.cn/tags/LRS/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列-LIS</title>
    <link href="http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/"/>
    <id>http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/</id>
    <published>2018-01-22T13:45:57.000Z</published>
    <updated>2022-09-14T18:03:38.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题"><a href="#LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题" class="headerlink" title="LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题"></a>LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题</h3><p>简单来讲就是要找到一个序列中，所有递增子序列中长度最长的子序列的长度。子序列的取值不要求在原序列中连续。</p><span id="more"></span><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>dp[i] 记录： 以arr[i]结尾的递增子序列的最大长度。<br>dp[i] 的更新：遍历 arr[0] 到 arr[i - 1] 中 小于 arr[i] 的数，并找到所有满足条件的arr[x] 中 dp[x] 最大的那个dp[n]，则dp[i] &#x3D; dp[n] + 1<br>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lis 动态规划 复杂度 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lis</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = length;</span><br><span class="line">    <span class="type">int</span> dp[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])</span><br><span class="line">                tmpMax = <span class="built_in">max</span>(dp[j],tmpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = tmpMax + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; tmpMax)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpMax = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种递增，即必须严格递增，不能相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格递增不能相等lis</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-二分"><a href="#动态规划-二分" class="headerlink" title="动态规划 + 二分"></a>动态规划 + 二分</h3><p>dp[i] 记录：当前最长的递增子序列的值<br>dp[i] 更新：把arr[i] 放入到 dp[i] 中，其放置方法为，从arr[0] 到 arr[len] 找到第一个大于等于arr[i]的位置pos，dp[pos] &#x3D; arr[i]。并更新len &#x3D; max(len,pos+1);<br>len增加（len &lt; pos +1）的情况只有一种，便是在当前序列的末尾增加了一个数(pos &#x3D; len)，反之如果只是在中间进行替换并不会改变len的大小。<br>注意到这里对 pos 的查找是对一个有序的序列的查找，可以使用二分查到达到log(n) 的复杂度。</p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分+动态规划</span></span><br><span class="line"><span class="built_in">lisDich</span>(<span class="type">int</span> *arr, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> l = length;</span><br><span class="line">    <span class="type">int</span> dp[l] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(dp,dp+len,arr[i]) - dp;<span class="comment">//二分查找，节省时间</span></span><br><span class="line">        dp[pos] = arr[i];</span><br><span class="line">        len = <span class="built_in">max</span>(len,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到的函数函数<code>lower_bound()</code> 用于在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置</p><h3 id="华为机试题-24题-合唱队"><a href="#华为机试题-24题-合唱队" class="headerlink" title="华为机试题 24题 合唱队"></a>华为机试题 24题 合唱队</h3><p>一种LIS的变种，通过正向与反向两次dp得到arr[i]左侧递增和右侧递减的长度，将两者相加得到一个满足条件的最大长度。<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calLis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpf</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpr</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">lis</span>(arr,dpf);</span><br><span class="line">    <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">lis</span>(arr,dpr);</span><br><span class="line">    <span class="built_in">reverse</span>(dpr.<span class="built_in">begin</span>(),dpr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dpf[i] + dpr[i];</span><br><span class="line">        <span class="keyword">if</span>(max &lt; dp[i])</span><br><span class="line">            max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; arr;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        arr.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>() - <span class="built_in">calLis</span>(arr);</span><br><span class="line">        cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考<a href="https://xuanwo.org/2015/07/31/dp-lis/">动态规划——最长上升子序列问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题&quot;&gt;&lt;a href=&quot;#LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题&quot; class=&quot;headerlink&quot; title=&quot;LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题&quot;&gt;&lt;/a&gt;LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题&lt;/h3&gt;&lt;p&gt;简单来讲就是要找到一个序列中，所有递增子序列中长度最长的子序列的长度。子序列的取值不要求在原序列中连续。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LIS" scheme="http://kangqingfei.cn/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>今日头条2018校招算法方向 第一批</title>
    <link href="http://kangqingfei.cn/2018/01/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E6%96%B9%E5%90%91-%E7%AC%AC%E4%B8%80%E6%89%B9/"/>
    <id>http://kangqingfei.cn/2018/01/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E6%96%B9%E5%90%91-%E7%AC%AC%E4%B8%80%E6%89%B9/</id>
    <published>2018-01-07T12:45:24.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日头条2018校招算法方向-第一批-链接：here"><a href="#今日头条2018校招算法方向-第一批-链接：here" class="headerlink" title="今日头条2018校招算法方向 第一批 链接：here"></a>今日头条2018校招算法方向 第一批 链接：<a href="https://www.nowcoder.com/test/8537290/summary">here</a></h1><h2 id="三道编程题，难度循序渐进，第三题做了很久还是有问题"><a href="#三道编程题，难度循序渐进，第三题做了很久还是有问题" class="headerlink" title="三道编程题，难度循序渐进，第三题做了很久还是有问题"></a>三道编程题，难度循序渐进，第三题做了很久还是有问题</h2><span id="more"></span><ol><li>一道求外围点的题<h3 id="P为给定的二维平面整数点集。定义-P-中某点x，如果x满足-P-中任意点都不在-x-的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复-坐标轴范围在-0-1e9-内）"><a href="#P为给定的二维平面整数点集。定义-P-中某点x，如果x满足-P-中任意点都不在-x-的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复-坐标轴范围在-0-1e9-内）" class="headerlink" title="P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）"></a>P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）</h3> 如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。 <img src="/assest/images/2018010701.jpg" class=""><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3> 第一行输入点集的个数 N， 接下来 N 行，每行两个数字代表点的 X 轴和 Y 轴。<br> 对于 50%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 10000;<br> 对于 100%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 500000;<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出“最大的” 点集合， 按照 X 轴从小到大的方式输出，每行两个数字分别代表点的 X 轴和 Y轴。<h3 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 5<br> 1 2<br> 5 3<br> 4 6<br> 7 5<br> 9 0<h3 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 4 6<br> 7 5<br> 9 0<h3 id="思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代"><a href="#思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代" class="headerlink" title="思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代"></a>思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代</h3> 还有一个坑就是，输入输出的方式，这里一开始用 cin 和 cout 发现一直是80%AC 改成scanf 和 printf后就是100% :(<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今日头条实习生 第一题 100% AC cin 与 cout 太浪费时间（80%AC） 改用 scanf 和 printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;   <span class="comment">//升序排列，如果改为return a&gt;b，则为降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; <span class="built_in">points</span>(count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;points[i].first, &amp;points[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),compare);</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pointTmp = points[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; goodPoints;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i].first &gt;= pointTmp.first)</span><br><span class="line">        &#123;</span><br><span class="line">            goodPoints.<span class="built_in">push_back</span>(i);</span><br><span class="line">            pointTmp = points[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : goodPoints)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, points[c].first,points[c].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一道很像动态规划的单调栈题<h3 id="给定一个数组序列-需要求选出一个区间-使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数-区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列-6-2-1-则根据上述公式-可得到所有可以选定各个区间的计算值"><a href="#给定一个数组序列-需要求选出一个区间-使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数-区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列-6-2-1-则根据上述公式-可得到所有可以选定各个区间的计算值" class="headerlink" title="给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:"></a>给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:</h3><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3> 第一行输入数组序列长度n，第二行输入数组序列。<br> 对于 50%的数据, 1 &lt;&#x3D; n &lt;&#x3D; 10000;<br> 对于 100%的数据, 1 &lt;&#x3D; n &lt;&#x3D; 500000;<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出数组经过计算后的最大值。<h3 id="输入例子1-1"><a href="#输入例子1-1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 3<br> 6 2 1<h3 id="输出例子1-1"><a href="#输出例子1-1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 36<h3 id="思路，有一种动态规划的思路，但是AC好像只有40-原因是内存超出限制"><a href="#思路，有一种动态规划的思路，但是AC好像只有40-原因是内存超出限制" class="headerlink" title="思路，有一种动态规划的思路，但是AC好像只有40% 原因是内存超出限制"></a>思路，有一种动态规划的思路，但是AC好像只有40% 原因是内存超出限制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 动态规划解法 40% AC 内存超出限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">mindp</span>(num,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; num; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                mindp[i][j] = arr[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mindp[i][j] = <span class="built_in">min</span>(mindp[i][j<span class="number">-1</span>],arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum,mindp[i][j] * (sum[j+<span class="number">1</span>] - sum[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值"><a href="#第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值" class="headerlink" title="第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值"></a>第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈解法 100% AC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vecSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i = begin; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        re += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; upStack;</span><br><span class="line"></span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// 先添加一个小于0 的数作为比较，以去除每次非空的判断</span></span><br><span class="line">    upStack.<span class="built_in">push</span>(num); <span class="comment">// 将 最后的那个自行添加的数的下标添加到栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt;= arr[upStack.<span class="built_in">top</span>()])<span class="comment">// 如果比当前的栈顶的元素要大的话就直接压栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            upStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则的话就先弹出栈顶的元素，直到满足上面的压栈条件，</span></span><br><span class="line">        <span class="comment">// 并且 计算 栈顶元素的单调区间（以栈顶元素开始往前单调递减 但 不小于当前值的 整个区间）的值</span></span><br><span class="line">        <span class="comment">// 然后更新 maxSum 的值 并压栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt; arr[upStack.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                top = upStack.<span class="built_in">top</span>();</span><br><span class="line">                upStack.<span class="built_in">pop</span>();</span><br><span class="line">                maxSum = <span class="built_in">max</span>(maxSum,arr[top] * <span class="built_in">vecSum</span>(arr,upStack.<span class="built_in">top</span>()+<span class="number">1</span>,i<span class="number">-1</span>));<span class="comment">//弹出栈并更新最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">             upStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> topEnd = upStack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">while</span>(upStack.<span class="built_in">top</span>() != num)</span><br><span class="line">    &#123;</span><br><span class="line">        top = upStack.<span class="built_in">top</span>();</span><br><span class="line">        upStack.<span class="built_in">pop</span>();</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum,arr[top] * <span class="built_in">vecSum</span>(arr,upStack.<span class="built_in">top</span>()+<span class="number">1</span>,topEnd));<span class="comment">//弹出栈并更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一道任务调度的题 该题较难，没有AC 但是我感觉思路是死的，也没想到啥高端的算法<h3 id="产品经理-PM-有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个-idea，每个-idea-有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有-PM-会在同一时刻提出两个-idea。"><a href="#产品经理-PM-有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个-idea，每个-idea-有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有-PM-会在同一时刻提出两个-idea。" class="headerlink" title="产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。"></a>产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。</h3> 同时有M个程序员，每个程序员空闲的时候就会查看每个PM尚未执行并且最想完成的一个idea,然后从中挑选出所需时间最小的一个idea独立实现，如果所需时间相同则选择PM序号最小的。直到完成了idea才会重复上述操作。如果有多个同时处于空闲状态的程序员，那么他们会依次进行查看idea的操作。<br> 求每个idea实现的时间。<br> 输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。输出P行，分别表示每个idea实现的时间点。<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3> 输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。全部数据范围 [1, 3000]。<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出P行，分别表示每个idea实现的时间点。<h3 id="输入例子1-2"><a href="#输入例子1-2" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 2 2 5<br> 1 1 1 2<br> 1 2 1 1<br> 1 3 2 2<br> 2 1 1 2<br> 2 3 5 5<h3 id="输出例子1-2"><a href="#输出例子1-2" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 3<br> 4<br> 5<br> 3<br> 9<h3 id="能有的思路就是一个死的思路，但是没有AC-贴上代码-这里有个10-AC的代码"><a href="#能有的思路就是一个死的思路，但是没有AC-贴上代码-这里有个10-AC的代码" class="headerlink" title="能有的思路就是一个死的思路，但是没有AC 贴上代码,这里有个10%AC的代码"></a>能有的思路就是一个死的思路，但是没有AC 贴上代码,<a href="http://blog.csdn.net/Geng19930909/article/details/77506945">这里</a>有个10%AC的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> idealId;</span><br><span class="line">    <span class="type">int</span> pmId;</span><br><span class="line">    <span class="type">int</span> timeStart;</span><br><span class="line">    <span class="type">int</span> pority;</span><br><span class="line">    <span class="type">int</span> timeCost;</span><br><span class="line">    <span class="type">int</span> timeFinish;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Task t1,Task t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.pority == t2.pority)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(t1.timeCost == t2.timeCost)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> t1.timeStart &lt; t2.timeStart;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> t1.timeCost &lt; t2.timeCost;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.pority &lt; t2.pority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTask</span><span class="params">(Task t1,Task t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.timeCost == t2.timeCost)</span><br><span class="line">        <span class="keyword">return</span> t1.pmId &lt; t2.pmId;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t1.pmId &lt; t2.pmId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPmTask</span><span class="params">( vector&lt;vector&lt;Task &gt; &gt; &amp; pmdata, vector&lt;Task&gt; &amp; taskPerPm, vector&lt;<span class="type">int</span>&gt; &amp;selectIndex, <span class="type">int</span> &amp; coder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    taskPerPm.<span class="built_in">clear</span>();</span><br><span class="line">    Task tmpTask;</span><br><span class="line">    <span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pmdata.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pmdata[i].<span class="built_in">size</span>() == <span class="number">0</span>)<span class="comment">//该pm已经没有任务可以调度了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coder &lt; pmdata[i][<span class="number">0</span>].timeStart)<span class="comment">//如果优先级高的需要等待，则优先选择不需要等待的次高优先级的任务 情况一</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpTask = pmdata[i][<span class="number">0</span>];</span><br><span class="line">                select = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; pmdata[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pmdata[i][j].timeStart &lt; tmpTask.timeStart)<span class="comment">//待定任务</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        tmpTask = pmdata[i][j];<span class="comment">//更新需要等待时间最少的任务</span></span><br><span class="line">                        select = j;</span><br><span class="line">                        <span class="keyword">if</span>(coder &gt;= pmdata[i][j].timeStart)<span class="comment">//找到优先级最高的那个不需要等待的任务</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            taskPerPm.<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">                            selectIndex[i] = select;<span class="comment">//更新当先加入队列中的任务</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                taskPerPm.<span class="built_in">push_back</span>(tmpTask);<span class="comment">//该pm找不到不需要等待的任务</span></span><br><span class="line">                selectIndex[i] = select;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//高优先级，不需要等待，直接进入队列 情况二</span></span><br><span class="line">            &#123;</span><br><span class="line">                taskPerPm.<span class="built_in">push_back</span>(pmdata[i][<span class="number">0</span>]);</span><br><span class="line">                selectIndex[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tasklt</span><span class="params">(<span class="type">int</span> &amp; coder, vector&lt;<span class="type">int</span>&gt; &amp; selectIndex, vector&lt;Task&gt; &amp; taskPerPm, vector&lt;vector&lt;Task &gt; &gt; &amp; pmdata, vector&lt;Task&gt; &amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选出需要完成的最高优先级任务</span></span><br><span class="line">    Task tmpTask = taskPerPm[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 并判断coder空闲的时间任务有没有产生，如果没有产生就去获取最先产生的次优先级的任务</span></span><br><span class="line">    <span class="keyword">if</span>(coder &lt; tmpTask.timeStart)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; taskPerPm.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpTask.timeStart &gt; taskPerPm[i].timeStart)<span class="comment">// 选取最先产生的任务</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpTask = taskPerPm[i];</span><br><span class="line">                <span class="keyword">if</span>(coder &gt;= tmpTask.timeStart)<span class="comment">//在满足已经产生的情况下，优先级最高的任务 找到了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成一个任务 然后更新它的 timeFinish</span></span><br><span class="line">    data[tmpTask.idealId].timeFinish = tmpTask.timeCost + (tmpTask.timeStart &gt; coder ? tmpTask.timeStart : coder);</span><br><span class="line">    <span class="comment">// 更新coder的工作时长</span></span><br><span class="line">    coder += tmpTask.timeStart &gt; coder ? tmpTask.timeStart : <span class="number">0</span>;<span class="comment">//加上等待时间</span></span><br><span class="line">    coder += tmpTask.timeCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从pm的待解决任务中移除已经调度的任务</span></span><br><span class="line">    vector&lt;Task&gt;::iterator it =  pmdata[tmpTask.pmId].<span class="built_in">begin</span>()+selectIndex[tmpTask.pmId];</span><br><span class="line">    pmdata[tmpTask.pmId].<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pmNum, coderNum, idealNum;</span><br><span class="line">    cin&gt;&gt;pmNum&gt;&gt;coderNum&gt;&gt;idealNum;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;Task &gt; &gt; <span class="built_in">pmdata</span>(pmNum);</span><br><span class="line">    vector&lt;Task &gt; data;</span><br><span class="line">    Task tmpTask;</span><br><span class="line"></span><br><span class="line">    tmpTask.timeFinish = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idealNumtmp = idealNum;</span><br><span class="line">    <span class="keyword">while</span>(idealNumtmp-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmpTask.pmId&gt;&gt;tmpTask.timeStart&gt;&gt;tmpTask.pority&gt;&gt;tmpTask.timeCost;</span><br><span class="line">        tmpTask.idealId = idealNum - idealNumtmp<span class="number">-1</span>;</span><br><span class="line">        tmpTask.pmId -= <span class="number">1</span>;</span><br><span class="line">        data.<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">        pmdata[tmpTask.pmId].<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先不考虑产生时间， 按照固定的优先级进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pmNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(pmdata[i].<span class="built_in">begin</span>(),pmdata[i].<span class="built_in">end</span>(),compare);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">coder</span><span class="params">(coderNum)</span></span>; <span class="comment">// 程序员的当前时间点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : coder)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">selectIndex</span><span class="params">(pmNum)</span></span>;<span class="comment">//当前进入选择队列的下标</span></span><br><span class="line">    vector&lt;Task&gt; taskPerPm;<span class="comment">//里面是每个pm最想完成的任务</span></span><br><span class="line">    idealNumtmp = idealNum;</span><br><span class="line">    <span class="keyword">while</span>(idealNumtmp-- &gt; <span class="number">0</span>) <span class="comment">// 对每个任务进行调度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先从pm处获取任务，分为两种情况，coder空闲时 任务已经产生还是没有产生</span></span><br><span class="line">        <span class="built_in">getPmTask</span>(pmdata,taskPerPm,selectIndex,coder[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">sort</span>(taskPerPm.<span class="built_in">begin</span>(),taskPerPm.<span class="built_in">end</span>(),getTask);<span class="comment">// 获取优先级最高的任务</span></span><br><span class="line">        <span class="built_in">tasklt</span>(coder[<span class="number">0</span>],selectIndex,taskPerPm,pmdata,data);<span class="comment">// 寻找优先级最高的任务给 最先完成的程序员进行调度</span></span><br><span class="line">        <span class="built_in">sort</span>(coder.<span class="built_in">begin</span>(),coder.<span class="built_in">end</span>());<span class="comment">//重新进行排序 以获取先完成的任务coder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : data)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c.timeFinish&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;今日头条2018校招算法方向-第一批-链接：here&quot;&gt;&lt;a href=&quot;#今日头条2018校招算法方向-第一批-链接：here&quot; class=&quot;headerlink&quot; title=&quot;今日头条2018校招算法方向 第一批 链接：here&quot;&gt;&lt;/a&gt;今日头条2018校招算法方向 第一批 链接：&lt;a href=&quot;https://www.nowcoder.com/test/8537290/summary&quot;&gt;here&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;三道编程题，难度循序渐进，第三题做了很久还是有问题&quot;&gt;&lt;a href=&quot;#三道编程题，难度循序渐进，第三题做了很久还是有问题&quot; class=&quot;headerlink&quot; title=&quot;三道编程题，难度循序渐进，第三题做了很久还是有问题&quot;&gt;&lt;/a&gt;三道编程题，难度循序渐进，第三题做了很久还是有问题&lt;/h2&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="头条" scheme="http://kangqingfei.cn/tags/%E5%A4%B4%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2016研发工程师编程题</title>
    <link href="http://kangqingfei.cn/2018/01/06/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/01/06/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <published>2018-01-06T11:39:44.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯笔试编程题：链接 <a href="http://static.nowcoder.com/pdf/paper/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98.pdf">腾讯2016研发工程师编程题</a></p><span id="more"></span><ol><li><p>格雷码的输出</p><h3 id="在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，-则称这种编码为格雷码-Gray-Code-，请编写一个函数，使用递归的方法生成N位的格雷码。"><a href="#在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，-则称这种编码为格雷码-Gray-Code-，请编写一个函数，使用递归的方法生成N位的格雷码。" class="headerlink" title="在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同， 则称这种编码为格雷码(Gray Code)，请编写一个函数，使用递归的方法生成N位的格雷码。"></a>在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同， 则称这种编码为格雷码(Gray Code)，请编写一个函数，使用递归的方法生成N位的格雷码。</h3><p> 给定一个整数n，请返回n位的格雷码，顺序为从0开始。</p><h3 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h3><p> 输入：1<br> 返回：[“0”,”1”]</p><h2 id="这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可"><a href="#这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可" class="headerlink" title="这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可"></a>这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可</h2></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GrayCode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getGray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getGray</span>(n <span class="number">-1</span>);</span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">tmp</span><span class="params">(result)</span></span>;<span class="comment">//复制两份</span></span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">tmp1</span><span class="params">(result)</span></span>;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) <span class="comment">// 从前往后开始遍历 在首部添加0</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="string">&quot;0&quot;</span>+tmp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = tmp1.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i)<span class="comment">//从后往前开始遍历 在首部添加1</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="string">&quot;1&quot;</span>+tmp1[i]); <span class="comment">//将复制的两份添加数字后放到result中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>寻找出现次数超过一半的红包</p><h3 id="春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。"><a href="#春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。" class="headerlink" title="春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。"></a>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。</h3><h3 id="给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。"><a href="#给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。" class="headerlink" title="给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。"></a>给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。</h3><p> 若没有金额超过总数的一半，返回0。</p><h3 id="测试样例：-1"><a href="#测试样例：-1" class="headerlink" title="测试样例："></a>测试样例：</h3><p> 输入： [1,2,3,2,2],5<br> 返回：2</p><h2 id="思路：-用-count-来维持一个一直出现的红包x的数量，若-x-再次出现则count-若x不再出现则count–-如果count为0了，则重置count并更新-x-这样就能够找到出现次数最多的-x-。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x"><a href="#思路：-用-count-来维持一个一直出现的红包x的数量，若-x-再次出现则count-若x不再出现则count–-如果count为0了，则重置count并更新-x-这样就能够找到出现次数最多的-x-。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x" class="headerlink" title="思路： 用 count 来维持一个一直出现的红包x的数量，若 x 再次出现则count++ 若x不再出现则count– 如果count为0了，则重置count并更新 x 这样就能够找到出现次数最多的 x 。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x"></a>思路： 用 count 来维持一个一直出现的红包x的数量，若 x 再次出现则count++ 若x不再出现则count– 如果count为0了，则重置count并更新 x 这样就能够找到出现次数最多的 x 。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x</h2></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gift</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; gifts, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>,tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = gifts[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp == gifts[i])</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == tmp)</span><br><span class="line">                size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size &gt; n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;腾讯笔试编程题：链接 &lt;a href=&quot;http://static.nowcoder.com/pdf/paper/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98.pdf&quot;&gt;腾讯2016研发工程师编程题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="tencent" scheme="http://kangqingfei.cn/tags/tencent/"/>
    
    <category term="笔试题" scheme="http://kangqingfei.cn/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://kangqingfei.cn/2018/01/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/01/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2018-01-06T08:55:10.000Z</published>
    <updated>2022-09-14T18:03:38.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各类背包问题集锦"><a href="#各类背包问题集锦" class="headerlink" title="各类背包问题集锦"></a>各类背包问题集锦</h2><h3 id="背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识"><a href="#背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识" class="headerlink" title="背包问题都是通过 动态规划 来求解的，在此之前需要了解动态规划的相关知识"></a>背包问题都是通过 <strong>动态规划</strong> 来求解的，在此之前需要了解<a href="http://kangqingfei.cn/">动态规划的相关知识</a></h3><h3 id="网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。"><a href="#网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。" class="headerlink" title="网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。"></a>网上有很好的参考资料：<a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">背包问题九讲</a>，自己也是参考该资料入门的。</h3><span id="more"></span><h3 id="下面列举一些刷题中遇到的实际的背包问题"><a href="#下面列举一些刷题中遇到的实际的背包问题" class="headerlink" title="下面列举一些刷题中遇到的实际的背包问题"></a>下面列举一些刷题中遇到的实际的背包问题</h3><ol><li><p>华为机试 16&#x2F;108 题 -&gt; 购物单</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p> 王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：<br> 主件附件<br> 电脑打印机，扫描仪<br> 书柜图书<br> 书桌台灯，文具<br> 工作椅无<br> 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br> 设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：<br> <code>v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ]</code> 。（其中 <code>*</code> 为乘号）<br> 请你帮助王强设计一个满足要求的购物单。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p> 输入的第 1 行，为两个正整数，用一个空格隔开：N m<br> 其中 N （ &lt;32000 ）表示总钱数， m （ &lt;60 ）为希望购买物品的个数。<br> 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q<br> 其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q&#x3D;0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p> 输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ &lt;200000 ）。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p> 输入<br> 1000 5<br> 800 2 0<br> 400 5 1<br> 300 5 1<br> 400 3 0<br> 500 2 0<br> 输出<br> 2200</p><h2 id="有依赖的背包问题：-将依赖转换为分组的背包问题，通过先后迭代-分组g-容量-v-每个分组中的条目-k-来求解最优解"><a href="#有依赖的背包问题：-将依赖转换为分组的背包问题，通过先后迭代-分组g-容量-v-每个分组中的条目-k-来求解最优解" class="headerlink" title="有依赖的背包问题： 将依赖转换为分组的背包问题，通过先后迭代 分组g 容量 v 每个分组中的条目 k 来求解最优解"></a>有依赖的背包问题： 将依赖转换为分组的背包问题，通过先后迭代 分组g 容量 v 每个分组中的条目 k 来求解最优解</h2></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//物品个数</span></span><br><span class="line">    <span class="type">int</span> N;<span class="comment">//总钱数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    N /= <span class="number">10</span>; <span class="comment">//总钱数是10的倍数，先除以10 以节约空间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> num = c;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> money = N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int price[num][3];//进行分组 事实上 num/3 &lt;= 分组数 &lt;= num 这里浪费了空间 clang++ 与 g++的不兼容的问题</span></span><br><span class="line">    <span class="comment">//int value[num][3];</span></span><br><span class="line">    <span class="type">int</span> price[<span class="number">61</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> value[<span class="number">61</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span>; h &lt; num; ++h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            price[h][j] = <span class="number">0</span>;</span><br><span class="line">            value[h][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,m,n;</span><br><span class="line">    <span class="type">int</span> v,p,q;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">0</span>) <span class="comment">//主件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            price[j][<span class="number">0</span>] = v;</span><br><span class="line">            value[j][<span class="number">0</span>] = v*p;</span><br><span class="line">            n += m; <span class="comment">//记录实际的分组号与q（总的物件数量）的差值</span></span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//附件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(price[j][<span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//第一个附件</span></span><br><span class="line">            &#123;</span><br><span class="line">                price[q-n][<span class="number">1</span>] = v;</span><br><span class="line">                value[q-n][<span class="number">1</span>] = v*p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//第二个附件</span></span><br><span class="line">            &#123;</span><br><span class="line">                price[q-n][<span class="number">2</span>] = v;</span><br><span class="line">                value[q-n][<span class="number">2</span>] = v*p;</span><br><span class="line">            &#125;</span><br><span class="line">            m++;<span class="comment">//附件个数计数,为了正确的分组，即当前主件有多少个附件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> group = j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int dp[group+1][money+1];// 第i个分组 在使用j数量钱 的 最大收益</span></span><br><span class="line">    <span class="type">int</span> dp[<span class="number">61</span>][<span class="number">3201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= group; ++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= money; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= group; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = money; j &gt; <span class="number">0</span>; --j)<span class="comment">//从最大值开始，防止出现 j - price &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 三个if就把分组的背包问题转换成了普通的背包问题</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= price[i][<span class="number">0</span>])<span class="comment">//只购买主件dp[i-1][j-price[i][0]] 为空出这么多钱的情况下的最大收益</span></span><br><span class="line">                dp[i][j] = <span class="built_in">getMax</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-price[i][<span class="number">0</span>]]+value[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= ( price[i][<span class="number">0</span>] + price[i][<span class="number">1</span>] ))<span class="comment">//购买主件和1附件</span></span><br><span class="line">                dp[i][j] = <span class="built_in">getMax</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-price[i][<span class="number">0</span>] - price[i][<span class="number">1</span>]]+value[i][<span class="number">0</span>]+value[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= price[i][<span class="number">0</span>] + price[i][<span class="number">1</span>] + price[i][<span class="number">2</span>])<span class="comment">// 购买主件和 1,2 附件</span></span><br><span class="line">                dp[i][j] = <span class="built_in">getMax</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-price[i][<span class="number">0</span>] - price[i][<span class="number">1</span>] - price[i][<span class="number">2</span>]]+value[i][<span class="number">0</span>]+value[i][<span class="number">1</span>]+value[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">10</span>*dp[group][money]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>背包问题2</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;各类背包问题集锦&quot;&gt;&lt;a href=&quot;#各类背包问题集锦&quot; class=&quot;headerlink&quot; title=&quot;各类背包问题集锦&quot;&gt;&lt;/a&gt;各类背包问题集锦&lt;/h2&gt;&lt;h3 id=&quot;背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识&quot;&gt;&lt;a href=&quot;#背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识&quot; class=&quot;headerlink&quot; title=&quot;背包问题都是通过 动态规划 来求解的，在此之前需要了解动态规划的相关知识&quot;&gt;&lt;/a&gt;背包问题都是通过 &lt;strong&gt;动态规划&lt;/strong&gt; 来求解的，在此之前需要了解&lt;a href=&quot;http://kangqingfei.cn/&quot;&gt;动态规划的相关知识&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。&quot;&gt;&lt;a href=&quot;#网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。&quot; class=&quot;headerlink&quot; title=&quot;网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。&quot;&gt;&lt;/a&gt;网上有很好的参考资料：&lt;a href=&quot;http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/&quot;&gt;背包问题九讲&lt;/a&gt;，自己也是参考该资料入门的。&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="背包问题" scheme="http://kangqingfei.cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>华为机试</title>
    <link href="http://kangqingfei.cn/2018/01/06/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    <id>http://kangqingfei.cn/2018/01/06/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/</id>
    <published>2018-01-06T08:03:07.000Z</published>
    <updated>2022-09-14T18:03:38.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="华为机试题汇总，对于一些比较复杂的题目会单独分析"><a href="#华为机试题汇总，对于一些比较复杂的题目会单独分析" class="headerlink" title="华为机试题汇总，对于一些比较复杂的题目会单独分析"></a>华为机试题汇总，对于一些比较复杂的题目会单独分析</h2><h3 id="链接：https-www-nowcoder-com-ta-huawei-总共-108-道题"><a href="#链接：https-www-nowcoder-com-ta-huawei-总共-108-道题" class="headerlink" title="链接：https://www.nowcoder.com/ta/huawei 总共 108 道题"></a><a href="https://www.nowcoder.com/ta/huawei">链接：https://www.nowcoder.com/ta/huawei</a> 总共 108 道题</h3><span id="more"></span><ol><li><p>字符串最后一个单词的长度  </p><h3 id="处理输入就好"><a href="#处理输入就好" class="headerlink" title="处理输入就好"></a>处理输入就好</h3></li><li><p>计算字符个数</p><h3 id="处理输入以及字符串处理"><a href="#处理输入以及字符串处理" class="headerlink" title="处理输入以及字符串处理"></a>处理输入以及字符串处理</h3><p> 用到 <em>range for</em> <code>for(auto c : str)</code> 以及大小写的转换 <code>toupper(c)</code> <code>tolower(c)</code></p></li><li><p>明明的随机数  </p><h3 id="去重与排序"><a href="#去重与排序" class="headerlink" title="去重与排序"></a>去重与排序</h3><p> 用到 排序 <code>sort(data.begin(),data.end())</code><br> 去重 <code>auto ite = unique(data.begin(),data.end())</code><br> ite为第一个重复元素的迭代器 <code>unique</code> 实际上并没有删除任何元素，而是将无重复的元素复制到序列的前端<br> 删除指定范围的元素 <code>data.erase(ite,data.end())</code></p></li><li><p>字符串分隔</p><h3 id="基本的字符串处理-注意边界条件"><a href="#基本的字符串处理-注意边界条件" class="headerlink" title="基本的字符串处理 注意边界条件"></a>基本的字符串处理 注意边界条件</h3></li><li><p>进制转换</p><h3 id="十六进制转十进制-基本的字符串处理-注意处理循环多组数据的输入"><a href="#十六进制转十进制-基本的字符串处理-注意处理循环多组数据的输入" class="headerlink" title="十六进制转十进制 基本的字符串处理 注意处理循环多组数据的输入"></a>十六进制转十进制 基本的字符串处理 注意处理循环多组数据的输入</h3></li><li><p>质数因子</p><h3 id="这里用到一些数学技巧，数学因子-是-将输入数值除以i-i从2开始-，除到无法整除-可以整除就输出然后做除法-后i-，直到除数平方大于等于输入数值"><a href="#这里用到一些数学技巧，数学因子-是-将输入数值除以i-i从2开始-，除到无法整除-可以整除就输出然后做除法-后i-，直到除数平方大于等于输入数值" class="headerlink" title="这里用到一些数学技巧，数学因子 是 将输入数值除以i(i从2开始)，除到无法整除(可以整除就输出然后做除法)后i++，直到除数平方大于等于输入数值"></a>这里用到一些数学技巧，数学因子 是 将输入数值除以i(i从2开始)，除到无法整除(可以整除就输出然后做除法)后i++，直到除数平方大于等于输入数值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i*i &lt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(tmp1 % i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp1 /= i;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取近似值</p><h3 id="将原数先乘以10-来分析其小数部分"><a href="#将原数先乘以10-来分析其小数部分" class="headerlink" title="将原数先乘以10 来分析其小数部分"></a>将原数先乘以10 来分析其小数部分</h3></li><li><p>合并表记录</p><h3 id="使用-map-处理索引和值，并将相同索引的值相加"><a href="#使用-map-处理索引和值，并将相同索引的值相加" class="headerlink" title="使用 map 处理索引和值，并将相同索引的值相加"></a>使用 map 处理索引和值，并将相同索引的值相加</h3></li><li><p>提取不重复整数</p><h3 id="提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。"><a href="#提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。" class="headerlink" title="提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。"></a>提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。</h3></li><li><p>字符个数判断</p><h3 id="简单的字符串处理-也可以用set-insert-来去重"><a href="#简单的字符串处理-也可以用set-insert-来去重" class="headerlink" title="简单的字符串处理 也可以用set.insert() 来去重"></a>简单的字符串处理 也可以用set.insert() 来去重</h3></li><li><p>数字颠倒</p><h3 id="该题要求字符串的形式逆序输出，-因此要用到-to-string-num-来将数字变为字符串"><a href="#该题要求字符串的形式逆序输出，-因此要用到-to-string-num-来将数字变为字符串" class="headerlink" title="该题要求字符串的形式逆序输出， 因此要用到 to_string(num) 来将数字变为字符串"></a>该题要求字符串的形式逆序输出， 因此要用到 <code>to_string(num)</code> 来将数字变为字符串</h3></li><li><p>字符串反转</p><h3 id="简单的字符串反转"><a href="#简单的字符串反转" class="headerlink" title="简单的字符串反转"></a>简单的字符串反转</h3></li><li><p>句子逆序</p><h3 id="简单的-vector-与-string-的联合使用"><a href="#简单的-vector-与-string-的联合使用" class="headerlink" title="简单的 vector 与 string 的联合使用"></a>简单的 vector 与 string 的联合使用</h3></li><li><p>字串的连接最长路径查找</p><h3 id="对n个字符串按照字典序排列-直接使用-vector-加上-sort"><a href="#对n个字符串按照字典序排列-直接使用-vector-加上-sort" class="headerlink" title="对n个字符串按照字典序排列 直接使用 vector 加上 sort"></a>对n个字符串按照字典序排列 直接使用 vector<string> 加上 sort</h3></li><li><p>求int 型正整数在内存中存储时1的个数</p><h3 id="即求这个数转换成2进制后，输出1的个数-通过移位来解决"><a href="#即求这个数转换成2进制后，输出1的个数-通过移位来解决" class="headerlink" title="即求这个数转换成2进制后，输出1的个数 通过移位来解决"></a>即求这个数转换成2进制后，输出1的个数 通过移位来解决</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">num</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    count += <span class="built_in">num</span> &amp; <span class="number">0x01</span>;</span><br><span class="line">    <span class="built_in">num</span> = <span class="built_in">num</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>购物单</p><h3 id="典型的分组背包问题。具体参考-背包问题"><a href="#典型的分组背包问题。具体参考-背包问题" class="headerlink" title="典型的分组背包问题。具体参考 背包问题"></a>典型的分组背包问题。具体参考 <a href="http://kangqingfei.cn/2018/01/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></h3></li><li><p>坐标移动</p><h3 id="主要是处理输入与输出"><a href="#主要是处理输入与输出" class="headerlink" title="主要是处理输入与输出"></a>主要是处理输入与输出</h3><p>判断是否是数字:<code>isdigit(str[i])</code><br>指定输入的分割符的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">string strt,str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; strt)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="function">istringstream <span class="title">iss</span><span class="params">(strt)</span></span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">getline</span>(iss, str, <span class="string">&#x27;;&#x27;</span>)) <span class="comment">// 以`;`分割来输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指定个数的数字字符转为数字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string strTmp;</span><br><span class="line">strTmp.<span class="built_in">append</span>(str,<span class="number">1</span>,str.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">step = <span class="built_in">stoi</span>(strTmp);</span><br></pre></td></tr></table></figure></li><li><p>识别有效IP地址和掩码并进行分类统计</p><h3 id="字符串处理-主要用到-atoi-str-c-str"><a href="#字符串处理-主要用到-atoi-str-c-str" class="headerlink" title="字符串处理 主要用到 atoi(str.c_str())"></a>字符串处理 主要用到 <code>atoi(str.c_str())</code></h3><p>有个坑就是 有的ip 啥都不是， 比如 127.0.0.1&#x2F;8<br>还有一个坑就是 255.255.255.255 这个掩码是错误的<br>实现了一个string 的 split</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string &amp;str, <span class="type">char</span> sep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">sstr</span><span class="params">(str)</span></span>;</span><br><span class="line">    vector&lt;string&gt; re;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(sstr,tmp,sep))</span><br><span class="line">        re.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单错误记录</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>用到 <code>string.rfind()</code> 反向查找，返回第一个下标的位置<br><code>string.find()</code> 正向查找，返回第一个找到字符的下标<br>还有一个有趣的结构体构造的代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct ErrRecord&#123;</span><br><span class="line">    string <span class="keyword">file</span>;</span><br><span class="line">    <span class="keyword">int</span> lineNo;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">    ErrRecord(string <span class="keyword">file</span>, <span class="keyword">int</span> lineNo)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lineNo = lineNo;</span><br><span class="line">        <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator==(const ErrRecord &amp; a)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">file</span> == a.<span class="keyword">file</span>) &amp;&amp; (lineNo == a.lineNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后利用 <code>ErrRecord record(getFileName(file), lineNo);</code>进行初始化</p></li><li><p>密码验证合格程序</p><h3 id="字符串处理-1"><a href="#字符串处理-1" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>主要难点在 <code>不能有相同长度超2的子串重复</code> 这里涉及一个重复字串的处理 使用的是暴力穷举，但是能AC</p></li><li><p>简单密码</p><h3 id="字符串处理-2"><a href="#字符串处理-2" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>简单的字符串处理，注意多值case语句的使用方法。以及 <code>Z</code> 后移一位是 <code>a</code>。</p></li><li><p>汽水瓶</p><h3 id="简单的数值处理题"><a href="#简单的数值处理题" class="headerlink" title="简单的数值处理题"></a>简单的数值处理题</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">num</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">num</span>/<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count += <span class="built_in">num</span>/<span class="number">3</span>;</span><br><span class="line">        remainder = <span class="built_in">num</span>%<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">num</span> = <span class="built_in">num</span>/<span class="number">3</span> + remainder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">num</span> == <span class="number">2</span>)</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除字符串中出现最少的字符</p><h3 id="简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。"><a href="#简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。" class="headerlink" title="简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。"></a>简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。</h3><p>注意 列表初始化： <code>int flag[3] = &#123;0&#125;</code> &#x3D;&gt; [0 0 0] <code>int flag[3] = &#123;1&#125;</code> &#x3D;&gt; [1 0 0]</p></li><li><p>合唱队</p><h3 id="LIS-的变种-具体参考-最长递增子序列-LIS"><a href="#LIS-的变种-具体参考-最长递增子序列-LIS" class="headerlink" title="LIS 的变种 具体参考 最长递增子序列-LIS"></a>LIS 的变种 具体参考 <a href="http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/">最长递增子序列-LIS</a></h3></li><li><p>数据分类处理</p><h3 id="简单的字符串处理-貌似没有时间的要求-或者时间要求很宽裕，但是有多个case-输入的要求"><a href="#简单的字符串处理-貌似没有时间的要求-或者时间要求很宽裕，但是有多个case-输入的要求" class="headerlink" title="简单的字符串处理 貌似没有时间的要求 或者时间要求很宽裕，但是有多个case 输入的要求"></a>简单的字符串处理 貌似没有时间的要求 或者时间要求很宽裕，但是有多个case 输入的要求</h3><p>用到string的几个函数 <code>to_string( int ).find( string ) != string::npos</code></p></li><li><p>字符串排序</p><h3 id="简单的字符串处理"><a href="#简单的字符串处理" class="headerlink" title="简单的字符串处理"></a>简单的字符串处理</h3></li><li><p>查找兄弟单词</p><h3 id="简单字符串处理"><a href="#简单字符串处理" class="headerlink" title="简单字符串处理"></a>简单字符串处理</h3><p>注意判断是否是兄弟单词的做法是使用排序后的字符串进行比较看是否相等，其次输出很坑的是换行，而且当k大于兄弟单词的总数时只输出兄弟单词的总数</p></li><li><p>素数伴侣</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;华为机试题汇总，对于一些比较复杂的题目会单独分析&quot;&gt;&lt;a href=&quot;#华为机试题汇总，对于一些比较复杂的题目会单独分析&quot; class=&quot;headerlink&quot; title=&quot;华为机试题汇总，对于一些比较复杂的题目会单独分析&quot;&gt;&lt;/a&gt;华为机试题汇总，对于一些比较复杂的题目会单独分析&lt;/h2&gt;&lt;h3 id=&quot;链接：https-www-nowcoder-com-ta-huawei-总共-108-道题&quot;&gt;&lt;a href=&quot;#链接：https-www-nowcoder-com-ta-huawei-总共-108-道题&quot; class=&quot;headerlink&quot; title=&quot;链接：https://www.nowcoder.com/ta/huawei 总共 108 道题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/huawei&quot;&gt;链接：https://www.nowcoder.com/ta/huawei&lt;/a&gt; 总共 108 道题&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="汇总" scheme="http://kangqingfei.cn/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>很久没更新了</title>
    <link href="http://kangqingfei.cn/2018/01/03/%E5%BE%88%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86/"/>
    <id>http://kangqingfei.cn/2018/01/03/%E5%BE%88%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86/</id>
    <published>2018-01-03T02:02:55.000Z</published>
    <updated>2022-09-14T18:03:38.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。"><a href="#荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。" class="headerlink" title="荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。"></a>荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。</h3><p>话说自从上了研究生就没有更博了，因为自己累，心累！</p><p>接下来，我将会更新一系列的笔试面试题，以求在2018的招聘中能有好运。</p><p>苦心人，人不负。</p><p>这是开博的初衷。</p><p>有志者，事竟成。</p><p>这是开博的目标。</p><span id="more"></span><p>网上已经有很多博客有过相关的笔试面试经验，每一个博客都见证了一个人的成长。这里将会列举一些自己曾经参考过的博客，可能这里会有很多与之前重复的地方，因为，<code>纸上得来终觉浅，绝知此事要躬行</code>。</p><ol><li><a href="http://blog.csdn.net/za30312/article/category/6312648">蓝桥杯</a></li><li><a href="http://blog.csdn.net/u013616945">Rock N Roll</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&quot;&gt;&lt;a href=&quot;#荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&quot; class=&quot;headerlink&quot; title=&quot;荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&quot;&gt;&lt;/a&gt;荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&lt;/h3&gt;&lt;p&gt;话说自从上了研究生就没有更博了，因为自己累，心累！&lt;/p&gt;
&lt;p&gt;接下来，我将会更新一系列的笔试面试题，以求在2018的招聘中能有好运。&lt;/p&gt;
&lt;p&gt;苦心人，人不负。&lt;/p&gt;
&lt;p&gt;这是开博的初衷。&lt;/p&gt;
&lt;p&gt;有志者，事竟成。&lt;/p&gt;
&lt;p&gt;这是开博的目标。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="blog" scheme="http://kangqingfei.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 与 make</title>
    <link href="http://kangqingfei.cn/2016/10/23/Makefile-%E4%B8%8E-make/"/>
    <id>http://kangqingfei.cn/2016/10/23/Makefile-%E4%B8%8E-make/</id>
    <published>2016-10-23T11:26:03.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h2><p>Makefile 是一种类似于脚本的，能够自动化执行程序的编译链接工作(甚至命令的执行 py latex 等命令)，从而省去了人工在命令行里输入指令的繁琐过程(并且在vim下对Makefile有着极好的支持)。而make指令(在win是cmake，linux下是gmake)可以自动搜索路径下的Makefile文件，并根据文件内容进行指令的执行，所以Makefile可以看做是一个工程的配置文件，只不过这个工程是用make打开编译。虽然Makefile给我们的程序的编译链接工作省去了很多繁琐的工作，但是偷懒的程序员依然觉得编写Makefile也是一件很是繁琐的工作，因此就诞生了诸多款的make工具用来根据程序员的一些设定自动生成能够执行的Makefile文件，从未又一定程度上减少了编写Makefile文件的重复工作量。这些工具有：</p><span id="more"></span><ul><li><p>cmake cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，比如你可用math表示数学库，而不需要再具体指定到底是math.dll还是libmath.so，在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个IDE定制工程文件。cmake命令执行的CMakeLists.txt文件 参考 <a href="https://www.zhihu.com/question/27455963/answer/36722992">来源：知乎</a></p></li><li><p>qmake qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -&#x3D; qt 就可以了。 参考<a href="https://www.zhihu.com/question/27455963/answer/89770919">辉常哥</a></p></li></ul><h2 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h2><h2 id="cmake-语法"><a href="#cmake-语法" class="headerlink" title="cmake 语法"></a>cmake 语法</h2><h2 id="qmake-语法"><a href="#qmake-语法" class="headerlink" title="qmake 语法"></a>qmake 语法</h2> <script type="text/javascript" src="https://asciinema.org/a/50301.js" id="asciicast-50301" async></script><h2 id="使用make进行程序的编译"><a href="#使用make进行程序的编译" class="headerlink" title="使用make进行程序的编译"></a>使用make进行程序的编译</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Makefile介绍&quot;&gt;&lt;a href=&quot;#Makefile介绍&quot; class=&quot;headerlink&quot; title=&quot;Makefile介绍&quot;&gt;&lt;/a&gt;Makefile介绍&lt;/h2&gt;&lt;p&gt;Makefile 是一种类似于脚本的，能够自动化执行程序的编译链接工作(甚至命令的执行 py latex 等命令)，从而省去了人工在命令行里输入指令的繁琐过程(并且在vim下对Makefile有着极好的支持)。而make指令(在win是cmake，linux下是gmake)可以自动搜索路径下的Makefile文件，并根据文件内容进行指令的执行，所以Makefile可以看做是一个工程的配置文件，只不过这个工程是用make打开编译。虽然Makefile给我们的程序的编译链接工作省去了很多繁琐的工作，但是偷懒的程序员依然觉得编写Makefile也是一件很是繁琐的工作，因此就诞生了诸多款的make工具用来根据程序员的一些设定自动生成能够执行的Makefile文件，从未又一定程度上减少了编写Makefile文件的重复工作量。这些工具有：&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="Makefile" scheme="http://kangqingfei.cn/tags/Makefile/"/>
    
    <category term="make" scheme="http://kangqingfei.cn/tags/make/"/>
    
  </entry>
  
</feed>
