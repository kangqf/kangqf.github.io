<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kblog</title>
  
  
  <link href="http://kangqingfei.cn/atom.xml" rel="self"/>
  
  <link href="http://kangqingfei.cn/"/>
  <updated>2022-11-23T16:23:48.218Z</updated>
  <id>http://kangqingfei.cn/</id>
  
  <author>
    <name>kangqingfei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fix-problems-for-hexo-theme-yilia</title>
    <link href="http://kangqingfei.cn/2022/11/23/fix-problems-for-hexo-theme-yilia/"/>
    <id>http://kangqingfei.cn/2022/11/23/fix-problems-for-hexo-theme-yilia/</id>
    <published>2022-11-23T15:58:46.000Z</published>
    <updated>2022-11-23T16:23:48.218Z</updated>
    
    <content type="html"><![CDATA[<p>从上一篇博文（2018-03-02）到现在已经过去了将近5年的时间了。这5年里经历了秋招找工作，研究生毕业，工作，跳槽等等很多很多的事情。但是时间就像流水一样流过，没有留下任何痕迹。所以最近又重新拾起之前的blog，开始记录，不是说 好记性不如烂笔头。</p><p>作为开局，由于时间有点晚了，先记录一下怎么把blog找回来的吧。</p><span id="more"></span><p>主要解决了下面几个问题：</p><ol><li><p>放在qiniu的图传丢失，域名被废弃，这里需要去七牛重新配一下自定义域名，之前的插件也还能用，更新一下bucket和密钥就好。</p></li><li><p>主题中的js丢失，主要是有些cdn跑路了</p><ul><li><p><a href="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min">http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min</a> 这个cdn没用了，需要把对应的js下载下来，对应的链接分别是 </p><ul><li><a href="https://requirejs.org/docs/release/2.1.6/minified/require.js">https://requirejs.org/docs/release/2.1.6/minified/require.js</a></li><li><a href="https://code.jquery.com/jquery-1.9.1.min.js">https://code.jquery.com/jquery-1.9.1.min.js</a></li></ul><p>可以放到qiniu的cdn，也可以放在站内，本着主题和资源分开的考虑没有放到cdn，放在了主题的<code>/source/js/</code>目录下面。</p><p>然后还需要更改一下<code>layout/_partial/after-footer.ejs</code>文件中引入的方式：</p><ul><li><code>&lt;%- js(&#39;http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min&#39;) %&gt;</code></li></ul><p>改为</p><ul><li><code>&lt;%- js(&#39;js/jquery-1.9.1.min&#39;) %&gt;</code></li><li><code>&lt;%- js(&#39;js/require-2.1.6&#39;) %&gt;</code></li></ul></li></ul></li><li><p>卜算子的文章pv统计功能丢失了，主要原因也是cdn失效了，找一个代替的就好，修改文件<code>layout/_partial/after-footer.ejs</code></p><ul><li><p><code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p><p>改为</p></li><li><p><code>&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code></p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上一篇博文（2018-03-02）到现在已经过去了将近5年的时间了。这5年里经历了秋招找工作，研究生毕业，工作，跳槽等等很多很多的事情。但是时间就像流水一样流过，没有留下任何痕迹。所以最近又重新拾起之前的blog，开始记录，不是说 好记性不如烂笔头。&lt;/p&gt;
&lt;p&gt;作为开局，由于时间有点晚了，先记录一下怎么把blog找回来的吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="http://kangqingfei.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>c++ lambda 表达式</title>
    <link href="http://kangqingfei.cn/2018/03/02/c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://kangqingfei.cn/2018/03/02/c-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2018-03-02T00:56:16.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记录lambda表达式的-基本语法-以及-常见的应用场景"><a href="#记录lambda表达式的-基本语法-以及-常见的应用场景" class="headerlink" title="记录lambda表达式的 基本语法 以及 常见的应用场景"></a>记录lambda表达式的 <code>基本语法</code> 以及 <code>常见的应用场景</code></h3><span id="more"></span><h3 id="Lambda的基本形式"><a href="#Lambda的基本形式" class="headerlink" title="Lambda的基本形式"></a>Lambda的基本形式</h3><ol><li>Lambda 表达式，也叫 Lambda 函数，也就是cpp中的匿名函数。 其实就是一个匿名函数 然后返回函数的调用地址</li><li>基本语法<br><code>[ captures ] &lt;tparams&gt;(可选)(C++20) ( params ) specifiers(可选) exception attr -&gt; ret requires(可选)(C++20) &#123; body &#125;</code><br>例如<code>auto glambda = []&lt;class T&gt;(T a, auto&amp;&amp; b) &#123; return a &lt; b; &#125;;</code></li></ol><ul><li>captures 为捕获列表</li><li>tparams 提供模板形参 用于 实参 确定数据类型</li><li>params 参数列表 不允许默认参数 因此形参的个数和实参的个数一定是一样的。<br>从C++14开始，lambda表达式支持泛型：其参数可以使用自动推断类型的功能，而不需要显示地声明具体类型。这就如同函数模板一样，参数要使用类型自动推断功能，只需要将其类型指定为auto，类型推断规则与函数模板一样。这里给出一个简单例子：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// 5</span></span><br><span class="line"><span class="type">double</span> y = <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">3.5</span>);  <span class="comment">// 6.0</span></span><br></pre></td></tr></table></figure></li><li>specifiers 捕获限定符 一般情况下lambda不会改变使用值捕获的变量的值，如果我们想改变这个值，那么我们必须在参数列表后面跟上关键词mutable</li><li>exception 异常规定</li><li>attr 指定运算符 () 的属性 可以是 <code>const</code> <code>auto &amp; </code> 之类的指定符</li><li>ret requires 返回类型 若缺失，则由函数的 return 语句所隐含（或若函数不返回任何值则为 void ）<br>const lambda 声明：<br><code>[ captures ] ( params ) -&gt; ret &#123; body &#125;</code><br>省略返回值：<br><code>[ captures ] ( params ) &#123; body &#125;</code><br>省略参数列表<br><code>[ captures ] &#123; body &#125;</code></li></ul><p>举几个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 隐式返回类型</span></span><br><span class="line">[](<span class="type">int</span>&amp; x) &#123; ++x; &#125;   <span class="comment">// 没有return语句 -&gt; lambda 函数的返回类型是&#x27;void&#x27;</span></span><br><span class="line">[]() &#123; ++global_x; &#125;  <span class="comment">// 没有参数,仅访问某个全局变量</span></span><br><span class="line">[]&#123; ++global_x; &#125;     <span class="comment">// 与上一个相同,省略了()</span></span><br></pre></td></tr></table></figure><h3 id="Lambda-的捕获"><a href="#Lambda-的捕获" class="headerlink" title="Lambda 的捕获"></a>Lambda 的捕获</h3><p>在Lambda中是可以使用局部形参以及全局变量的，但是试图使用任何未捕获的外部变量都是错误的。<br>为此，我们可以使用捕获列表来捕获外部的局部变量并用于lambda中，形式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">//未定义变量.试图在Lambda内使用任何外部变量都是错误的.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x 按值捕获, y 按引用捕获 x y 都是外部的函数的局部变量名</span></span><br><span class="line">[&amp;]       <span class="comment">//用到的任何外部变量都隐式按引用捕获</span></span><br><span class="line">[=]       <span class="comment">//用到的任何外部变量都隐式按值捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x显式地按值捕获. 其它变量按引用捕获</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z按引用捕获. 其它变量按值捕获</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; some_list;</span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) some_list.<span class="built_in">push_back</span>(i);</span><br><span class="line">std::for_each(<span class="built_in">begin</span>(some_list), <span class="built_in">end</span>(some_list), [&amp;total](<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    total += x;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;记录lambda表达式的-基本语法-以及-常见的应用场景&quot;&gt;&lt;a href=&quot;#记录lambda表达式的-基本语法-以及-常见的应用场景&quot; class=&quot;headerlink&quot; title=&quot;记录lambda表达式的 基本语法 以及 常见的应用场景&quot;&gt;&lt;/a&gt;记录lambda表达式的 &lt;code&gt;基本语法&lt;/code&gt; 以及 &lt;code&gt;常见的应用场景&lt;/code&gt;&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="cpp" scheme="http://kangqingfei.cn/tags/cpp/"/>
    
    <category term="lambda" scheme="http://kangqingfei.cn/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>C++初始化</title>
    <link href="http://kangqingfei.cn/2018/03/01/C-%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://kangqingfei.cn/2018/03/01/C-%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2018-03-01T06:45:15.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>默认初始化<br>  这是在不使用初始化器构造变量时执行的初始化</p></li><li><p>使用初始化器进行初始化<br>  按照语境，初始化器可以调用：</p></li><li><p>值初始化，例如 std::string s{};<br>  这是在变量以空初始化器构造时进行的初始化。</p></li><li><p>直接初始化，例如 std::string s(“hello”);<br>  从构造函数参数的显式集合初始化对象</p><span id="more"></span></li><li><p>复制初始化，例如 std::string s &#x3D; “hello”;<br>  从另一对象初始化对象</p></li><li><p>列表初始化，例如 std::string s{‘a’, ‘b’, ‘c’};<br>  从花括号初始化器列表初始化对象</p></li><li><p>聚合初始化，例如 char a[3] &#x3D; {‘a’, ‘b’};<br>  从花括号初始化器列表初始化聚合体<br>聚合初始化是一种初始化聚合体的列表初始化</p></li><li><p>引用初始化，例如 char&amp; c &#x3D; a[0];<br>  绑定引用到对象<br>  包括左值引用的初始化和右值引用的初始化</p></li><li><p>静态初始化</p></li></ul><ol><li>若受允许，则首先发生常量初始化（这些情形见常量初始化）。 实践上，常量初始化通常在编译期进行，而预计算的对象表示作为程序映像的一部分存储。若编译器没有这么做，则亦保证此初始化发生先于任何动态初始化。</li><li>对于所有其他 非局部 静态 及 线程局域变量 ，发生零初始化。 实现中，要被零初始化的变量置于程序映像的 .bss 段，它不占据磁盘空间，并在加载程序时为操作系统以零填充。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">&#125;; <span class="comment">// 隐式默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T2</span>(<span class="type">const</span> T2&amp;) &#123; &#125; <span class="comment">// 用户提供的复制构造函数</span></span><br><span class="line">&#125;;                    <span class="comment">// 无默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mem1;</span><br><span class="line">    std::string mem2;</span><br><span class="line">    <span class="built_in">T3</span>() &#123; &#125; <span class="comment">// 用户提供的默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="type">int</span> mem;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> n)</span> : mem(n) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1; <span class="comment">// 静态非类，进行二段初始化： 1) 零初始化初始化 n 为零  2) 默认初始化不做任何事，令 n 为零</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//// 默认初始化  一般是定义变量后未进行任何的操作则触发</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i11; <span class="comment">// 默认初始化 非类 值不确定</span></span><br><span class="line">    <span class="type">int</span>* a11 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 数组 =&gt; 每个元素 默认初始化 每个元素的值为不确定</span></span><br><span class="line">    string str11; <span class="comment">// 默认初始化 类，调用默认构造函数，值是 &quot;&quot; （空字符串）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  int&amp; r;           // 错误：引用</span></span><br><span class="line">    <span class="comment">//  const int n;      // 错误： const 的非类 必须初始化</span></span><br><span class="line">    <span class="comment">//  const T1 t1;      // 错误： const 类带隐式默认构造函数 无法初始化 必须用户提供显式默认构造函数</span></span><br><span class="line"></span><br><span class="line">    T1 t11; <span class="comment">// 类：调用隐式默认构造函数 t1.mem1 值初始化为未确定</span></span><br><span class="line">    <span class="type">const</span> T3 t13;  <span class="comment">// const 类，调用用户提供的默认构造函数 t3.mem1 被默认初始化（为不确定值）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 值初始化 有 () &#123;&#125; 两种空括号形式会触发 值初始化</span></span><br><span class="line">    <span class="type">int</span> n&#123;&#125;;                <span class="comment">// 标量 =&gt; 零初始化，值为 0</span></span><br><span class="line">    <span class="type">double</span> f = <span class="built_in">double</span>();    <span class="comment">// 标量 =&gt; 零初始化，值为 0.0</span></span><br><span class="line">    <span class="type">int</span>* a21 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">// 数组 =&gt; 每个元素的值初始化 每个元素的值为 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    T1 t21&#123;&#125;;                <span class="comment">// 有隐式默认构造函数的类 =&gt; t1.mem1 被零初始化，值为 0  t1.mem2 被默认初始化，值为 &quot;&quot;</span></span><br><span class="line">    <span class="comment">//  T2 t22&#123;&#125;;            // 错误：类无默认构造函数</span></span><br><span class="line">    T3 t23&#123;&#125;;                <span class="comment">// 有用户提供默认构造函数的类 =&gt; t3.mem1 被默认初始化为不确定值  t3.mem2 被默认初始化，值为 &quot;&quot;</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v21</span><span class="params">(<span class="number">3</span>)</span></span>;  <span class="comment">// 值初始化每个元素 每个元素的值为 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 直接初始化 直接调用构造函数的形式会触发直接初始化 以 object(kkk) new object(kkk) object():men(kkk)（构造函数初始化器列表） [arg]()&#123;&#125; 等形式触发</span></span><br><span class="line">    <span class="function">std::string <span class="title">s1</span><span class="params">(<span class="string">&quot;test&quot;</span>)</span></span>; <span class="comment">// 自 const char* 的构造函数</span></span><br><span class="line">    <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK ：允许 explicit 构造函数</span></span><br><span class="line">    <span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // 错误：构造函数为 explicit</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(<span class="number">2</span>)</span></span>; <span class="comment">// f 被直接初始化： 构造函数参数 n 从右值 2 复制初始化  f.mem 从参数 n 直接初始化</span></span><br><span class="line">    <span class="comment">//  Foo f2 = 2; // 错误：构造函数为 explicit 会阻止复制初始化的发生</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 复制初始化 以（ 等号 传参 抛出异常 返回值 ）的形式用一个对象初始化另一个对象</span></span><br><span class="line">    <span class="comment">//// explicit 可以禁止复制初始化的发生</span></span><br><span class="line">    <span class="comment">//  std::unique_ptr&lt;int&gt; p = new int(1); // 错误：unique_ptr 构造函数为 explicit 试图进行复制初始化</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>; <span class="comment">// OK ：直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 列表初始化  以花括号的形式触发 一般触发列表初始化后 会触发 复制初始化( obj ttt=&#123;kkk&#125; )或者是值初始化( obj(&#123;kkk&#125;) )</span></span><br><span class="line">    <span class="type">double</span> d = <span class="type">double</span>&#123;<span class="number">1.2</span>&#125;; <span class="comment">// 临时量的列表初始化，然后复制初始化</span></span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123; <span class="comment">// 嵌套列表初始化</span></span><br><span class="line">      &#123;<span class="number">1</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="number">2</span>, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125; &#125;,</span><br><span class="line">      &#123;<span class="number">3</span>, s1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;默认初始化&lt;br&gt;  这是在不使用初始化器构造变量时执行的初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用初始化器进行初始化&lt;br&gt;  按照语境，初始化器可以调用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;值初始化，例如 std::string s{};&lt;br&gt;  这是在变量以空初始化器构造时进行的初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接初始化，例如 std::string s(“hello”);&lt;br&gt;  从构造函数参数的显式集合初始化对象&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="cpp" scheme="http://kangqingfei.cn/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer题解</title>
    <link href="http://kangqingfei.cn/2018/02/28/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/"/>
    <id>http://kangqingfei.cn/2018/02/28/%E5%89%91%E6%8C%87Offer%E9%A2%98%E8%A7%A3/</id>
    <published>2018-02-28T01:28:23.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指Offer刷题-链接"><a href="#剑指Offer刷题-链接" class="headerlink" title="剑指Offer刷题 链接"></a>剑指Offer刷题 <a href="https://www.nowcoder.com/ta/coding-interviews?page=1">链接</a></h2><h3 id="共66题-历时-2018-02-28-2018-03-01-共2天"><a href="#共66题-历时-2018-02-28-2018-03-01-共2天" class="headerlink" title="共66题 历时 2018.02.28-2018.03.01 共2天"></a>共66题 历时 2018.02.28-2018.03.01 共2天</h3><span id="more"></span><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2.28</p><ol><li><p>二维数组中的查找 较为简单<br>类似于二分的思路，先找到中间的数（广义中位数），然后每次缩小一大块空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> line = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(line == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> row = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = line - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; array[i][j])</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; array[i][j])</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>替换空格<br>从尾部进行处理以防止头部数据被覆盖 简单字符串处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="type">char</span> *str,<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> nonspace = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *tmp = str;</span><br><span class="line">    <span class="keyword">while</span>(*tmp != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*tmp == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            nonspace++;</span><br><span class="line">        tmp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = length<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*(str+i) == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span><span class="number">-2</span>) = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span><span class="number">-1</span>) = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            *(str+i+nonspace*<span class="number">2</span>) = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            nonspace--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *(str+nonspace*<span class="number">2</span>+i) = *(str+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从尾到头打印链表<br>简单递归处理链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; re;</span><br><span class="line">    <span class="built_in">printList</span>(head,re);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode *node,vector&lt;<span class="type">int</span> &gt; &amp;re)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printList</span>(node-&gt;next,re);</span><br><span class="line">    re.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重建二叉树<br>中等难度的 递归问题，记得划分子问题的时候，子问题的解决方法应该与原问题一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">//// 记住 递归类的问题的子问题一定是与原问题给出的信息等价 也就是 子问题与原问题完全一致</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">reCon</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin, <span class="type">int</span> pLeft, <span class="type">int</span> pRight, <span class="type">int</span> vStart, <span class="type">int</span> vEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pLeft &gt; pRight || vStart &gt; vEnd)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;pLeft&lt;&lt;&quot; &quot;&lt;&lt;pRight&lt;&lt;&quot; &quot;&lt;&lt;vStart&lt;&lt;&quot; &quot;&lt;&lt;vEnd&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[pLeft]);</span><br><span class="line">    <span class="keyword">if</span>(pLeft == pRight || vStart == vEnd)<span class="comment">//到达叶子节点,不需要寻找左右节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = vStart; i &lt;= vEnd; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre[pLeft] == vin[i])<span class="comment">// 找到在中序遍历中的下标进行划分</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = <span class="built_in">reCon</span>(pre,vin,pLeft+<span class="number">1</span>,pLeft+count,vStart,vStart+count<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = <span class="built_in">reCon</span>(pre,vin,pLeft+count+<span class="number">1</span>,pRight,vStart+count+<span class="number">1</span>,vEnd);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">    TreeNode* root = <span class="built_in">reCon</span>(pre,vin,<span class="number">0</span>,pre.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>,vin.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; pre = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; vin = &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">reConstructBinaryTree</span>(pre,vin);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>用两个栈实现队列<br>简单的栈处理 一个用于push 一个用于pop</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tmp = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>旋转数组的最小数字<br>简单的二分思想的运用，当一个序列可以用函数的单调性来描述的时候就会使用二分<br>但是要注意单调不减 所以注意等号的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinNum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;rArr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end - start &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rArr[start],rArr[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> middle = (start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(rArr[middle] &gt;= rArr[start] &amp;&amp; rArr[middle] &gt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rArr,middle,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rArr[middle] &lt;= rArr[start] &amp;&amp; rArr[middle] &lt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rArr,start,middle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(rArr[middle] &lt;= rArr[start] &amp;&amp; rArr[middle] &gt;= rArr[end])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> rArr[middle];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rotateArray.<span class="built_in">size</span>() &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findMinNum</span>(rotateArray,<span class="number">0</span>,rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>斐波那契数列<br>非常简单的递归转动态规划(或迭代)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">   <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> tmp;</span><br><span class="line">   <span class="keyword">while</span>(i++ &lt;= n)</span><br><span class="line">   &#123;</span><br><span class="line">       tmp = f2;</span><br><span class="line">       f2 = f1 + f2;</span><br><span class="line">       f1 = tmp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>跳台阶<br>上题的变种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> tmp, index = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(index++ &lt;= number)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = f2;</span><br><span class="line">        f2 = f1+f2;</span><br><span class="line">        f1 = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变态跳台阶<br>数学归纳法找规律的题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>,number<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩形覆盖<br>斐波那契数列变种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> tmp,f1 = <span class="number">1</span>, f2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(index++ &lt;= number)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = f2;</span><br><span class="line">            f2 = f1+f2;</span><br><span class="line">            f1 = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二进制中1的个数<br>简单的数值处理 记得有负数不能用移位然后与1与的方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(n)</span><br><span class="line">     &#123;</span><br><span class="line">         count++;</span><br><span class="line">         n&amp;=(n<span class="number">-1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>数值的整数次方<br>简单数值处理（也是二分） 注意细节 指数为0 指数为负 指数为奇数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> neg = exponent &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ood = exponent % <span class="number">2</span>;</span><br><span class="line">    exponent = <span class="built_in">abs</span>(exponent);</span><br><span class="line">    <span class="type">double</span> re = base;</span><br><span class="line">    <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">        re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(exponent != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            re = re*re;</span><br><span class="line">            exponent/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ood)</span><br><span class="line">            re = re*base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> neg ? <span class="number">1</span>/re : re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调整数组顺序使奇数位于偶数前面<br>数组 处理 在空间不允许的情况下（不要求位置不变） 可以 用两个指针 指向头和尾，然后交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            re.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    array = re;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>链表中倒数第k个结点<br>简单的链表处理，头尾两个指针进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="type">unsigned</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* tmp = pListHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tmp!= <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">        pListHead = pListHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pListHead;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反转链表<br>中等难度的链表处理，千万要注意细节，就是指针为空的时候<br>然后有递归（难理解 简洁）和迭代两种方式来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 反转链表</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span> *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) :</span><br><span class="line">        <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非递归实现，注意空指针的判断，否则直接段错误</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *pre = <span class="literal">NULL</span>,*tmp2;</span><br><span class="line">    <span class="keyword">while</span>(pHead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp2 = pHead-&gt;next;</span><br><span class="line">        pHead-&gt;next = pre;</span><br><span class="line">        pre = pHead;</span><br><span class="line">        pHead = tmp2;</span><br><span class="line">    &#125;</span><br><span class="line">    pHead-&gt;next = pre;</span><br><span class="line">    <span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归版</span></span><br><span class="line"><span class="function">ListNode* <span class="title">RecReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead-&gt;next == <span class="literal">nullptr</span> || pHead == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *pre = <span class="built_in">RecReverseList</span>(pHead-&gt;next);</span><br><span class="line">    <span class="comment">// 注意每次 pHead 这个局部变量的存在，都是指向之前的指针，相当于每次pHead 的值是栈顶的值</span></span><br><span class="line">    pHead-&gt;next-&gt;next = pHead;</span><br><span class="line">    pHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *pHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode *ptmp = pHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ptmp-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(i);</span><br><span class="line">        ptmp = ptmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RecReverseList</span>(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>合并两个排序的链表<br>简单的链表处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> &amp;&amp; pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead1 != <span class="literal">nullptr</span> &amp;&amp; pHead2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead1;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pHead1 == <span class="literal">nullptr</span> &amp;&amp; pHead2 != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> pHead2;</span><br><span class="line"></span><br><span class="line">    ListNode *head, *tmp;</span><br><span class="line">    <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        head = pHead1;</span><br><span class="line">        pHead1 = pHead1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head = pHead2;</span><br><span class="line">        pHead2 = pHead2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = head;</span><br><span class="line">    <span class="keyword">while</span>(pHead1 != <span class="literal">nullptr</span> &amp;&amp; pHead2 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = pHead1;</span><br><span class="line">            tmp = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp-&gt;next = pHead2;</span><br><span class="line">            tmp = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;           </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next = pHead1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp-&gt;next = pHead2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>树的子结构<br>aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>二叉树的镜像<br>aaa</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 3.1</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;剑指Offer刷题-链接&quot;&gt;&lt;a href=&quot;#剑指Offer刷题-链接&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer刷题 链接&quot;&gt;&lt;/a&gt;剑指Offer刷题 &lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews?page=1&quot;&gt;链接&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;共66题-历时-2018-02-28-2018-03-01-共2天&quot;&gt;&lt;a href=&quot;#共66题-历时-2018-02-28-2018-03-01-共2天&quot; class=&quot;headerlink&quot; title=&quot;共66题 历时 2018.02.28-2018.03.01 共2天&quot;&gt;&lt;/a&gt;共66题 历时 2018.02.28-2018.03.01 共2天&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
  </entry>
  
  <entry>
    <title>腾讯 2017 暑期实习生编程题</title>
    <link href="http://kangqingfei.cn/2018/02/26/%E8%85%BE%E8%AE%AF-2017-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/02/26/%E8%85%BE%E8%AE%AF-2017-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <published>2018-02-26T02:06:34.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<h3 id="腾讯2017暑期实习生编程题"><a href="#腾讯2017暑期实习生编程题" class="headerlink" title="腾讯2017暑期实习生编程题"></a>腾讯2017暑期实习生编程题</h3><p><a href="https://www.nowcoder.com/test/1725829/summary">链接</a></p><span id="more"></span><ol><li>构造回文子串</li></ol><p>按照 回文字符串的性质 可以知道 此题 就是求 原串与翻转后的字符串的 lcs 的值。</p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcs</span><span class="params">(string &amp;str1, string &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> dp[len+<span class="number">1</span>][len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minDelStr</span><span class="params">(string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = str;</span><br><span class="line">    <span class="built_in">reverse</span>(str1.<span class="built_in">begin</span>(),str1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str.<span class="built_in">length</span>()-<span class="built_in">lcs</span>(str,str1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">minDelStr</span>(str)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这题比较奇葩，首先想到的就是冒泡排序的思想，但是看到有人遍历了两遍然后输出的奇淫技巧只能大喊666</li></ol><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AkleBiCeilD</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = str.<span class="built_in">length</span>()<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; str.<span class="built_in">length</span>() &amp;&amp; str[j+<span class="number">1</span>] &gt;= <span class="string">&#x27;a&#x27;</span>; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">swap</span>(str[j],str[j+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>这个题咋看简单其实还是很多错误的思路的。比如 当最小差为0 时 便不能应用最小差不为0的求解方法，因为当前数字可能与之前的之前的数字进行组合</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>链接：<a href="https://www.nowcoder.net/questionTerminal/af709ab9ca57430886632022e543d4c6">https://www.nowcoder.net/questionTerminal/af709ab9ca57430886632022e543d4c6</a><br>来源：牛客网</p><p>1.先排序<br>     特殊情况：如果排完序之后发现数组中所有数都相同，直接输出结果<br>         结果为：差最大个数 &#x3D; 差最小个数 &#x3D; （n * (n-1))&#x2F;2;(两两组合)<br>2.统计数组中每种数字的个数（这里用的map）<br>3.计算差最小个数<br>    3.1.如果数组中没有重复数字，说明最小差不为0，最小差肯定是数组中相邻两个数的差<br>        因此，遍历一边数组，计算并统计最小差。<br>    3.2.如果数组中有重复数字，说明最小差是0，此时，遍历一边map，数字个数不为0的<br>        数字会产生最小差0，利用公式计算即可<br>4.计算差最大个数     <br>    只有一种情况，最大值与最小值的两两组合，即最大值个数 * 最小值个数<br>        算法复杂度：排序O(nlogn), 统计O(n)</p><h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span> &gt; arr;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max = <span class="number">-1</span>,maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min = INT_MAX, minCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">                minCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == min)</span><br><span class="line">            &#123;</span><br><span class="line">                minCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">                maxCount = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == max)</span><br><span class="line">            &#123;</span><br><span class="line">                maxCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> minTmp = arr[<span class="number">1</span>] - arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sameCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>()<span class="number">-1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] &lt; minTmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sameCount = <span class="number">1</span>;</span><br><span class="line">                minTmp = arr[i+<span class="number">1</span>] - arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i] == minTmp)</span><br><span class="line">            &#123;</span><br><span class="line">                sameCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minTmp == <span class="number">0</span>)<span class="comment">//最小差为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> repCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] == arr[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    ++repCount;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;repCount&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxCount*minCount&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            cout&lt;&lt;sameCount&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;maxCount*minCount&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;腾讯2017暑期实习生编程题&quot;&gt;&lt;a href=&quot;#腾讯2017暑期实习生编程题&quot; class=&quot;headerlink&quot; title=&quot;腾讯2017暑期实习生编程题&quot;&gt;&lt;/a&gt;腾讯2017暑期实习生编程题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/test/1725829/summary&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="tencent" scheme="http://kangqingfei.cn/tags/tencent/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://kangqingfei.cn/2018/02/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://kangqingfei.cn/2018/02/26/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2018-02-26T01:48:13.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>一种方法是通过翻转字符串，然后依靠最长公共子串（而不是子序列，子序列可以用来构造回文子串）的方法来求解</p><span id="more"></span><h3 id="Manacher-算法"><a href="#Manacher-算法" class="headerlink" title="Manacher 算法"></a>Manacher 算法</h3><ul><li>首先通过向字符中添加 # 把原字符需要划分奇数偶数的处理变成了 统一处理</li><li>其次 维护 一个 P[i] 表示 以当前为中心向两边扩展的回文长度，id 当前最长的回文子串的中心， mx &#x3D; id + P[id] 为字符串的边界。</li><li>关键思想是P[i]的更新是需要技巧的。  若 mx &gt; i 则 P[i] &gt;&#x3D; min(P[2*id-i],mx-i) 若 mx &lt;&#x3D; i 则 P[i] &#x3D; 1</li><li>该思想是通过 <code>对称点来初始化 P[i]</code> 若对称点的 回文子串包含在 目前最长串内 则初始化为与对称点一致 P[i] &#x3D; P[2*id-1] 否则 对称点的回文子串超出最长子串界限，则P[i]在最长回文子串内的那段（长度mx-i）必定是回文的， 但后续情况未知，P[i] &#x3D; mx-i<br><a href="https://www.felix021.com/blog/read.php?2040">参考</a></li></ul><p>参考代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">manacher</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> id = <span class="number">0</span>,mx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> P[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        P[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mx - i &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            P[i] = <span class="built_in">min</span>(P[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            P[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(str[i+P[i]] == str[i-P[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            P[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有两种情况需要更新 一种是 找到了更长的回文子串，一种是当前的遍历下标已经超过了最长的那个回文子串的边界(开始新的一轮) 分别对应 P[i] 大 和 i 大</span></span><br><span class="line">        <span class="keyword">if</span>(P[i]+i &gt; mx)</span><br><span class="line">        &#123;</span><br><span class="line">            id = i;</span><br><span class="line">            mx = P[i]+i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tmp = P[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> index =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(P[i] &gt; tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = P[i];</span><br><span class="line">            index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; re;</span><br><span class="line">    <span class="type">int</span> start = index/<span class="number">2</span> - tmp/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> end = index/<span class="number">2</span> + (tmp<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    re.<span class="built_in">push_back</span>(start);</span><br><span class="line">    re.<span class="built_in">push_back</span>(end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">preProcess</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string reStr = <span class="string">&quot;^&quot;</span>;</span><br><span class="line">    <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        reStr += <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        reStr += str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    reStr += <span class="string">&quot;#$&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> reStr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;str)</span><br><span class="line">    &#123;</span><br><span class="line">        str = <span class="string">&quot;abccba&quot;</span>;</span><br><span class="line">        string str1 = <span class="built_in">preProcess</span>(str);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp = <span class="built_in">manacher</span>(str1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tmp[<span class="number">0</span>]; i &lt; tmp[<span class="number">1</span>]; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;str[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h2&gt;&lt;p&gt;一种方法是通过翻转字符串，然后依靠最长公共子串（而不是子序列，子序列可以用来构造回文子串）的方法来求解&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LCS与编辑距离以及MCSS</title>
    <link href="http://kangqingfei.cn/2018/02/04/LCS%E4%B8%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://kangqingfei.cn/2018/02/04/LCS%E4%B8%8E%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2018-02-04T08:02:09.000Z</published>
    <updated>2022-09-14T18:03:38.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。"><a href="#LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。" class="headerlink" title="LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 子序列 而不是 子串 的最大的长度。"></a>LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 <code>子序列</code> 而不是 <code>子串</code> 的最大的长度。</h2><p>之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。</p><span id="more"></span><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>设定 dp[i][j] 为str(0…i) 与 patten(0…j) 的最长子公共子序列的长度</li></ul><ol><li>初始化 数组的 0 下标为零，然后更新 dp[i][j];</li><li>若 <code>str[i] == patten[j]</code> 则<code>dp[i][j] = dp[i-1][j-1]</code>，若 <code>str[i] != patten[j]</code> 则 <code>dp[i][j] = max(dp[i][j-1],dp[i-1][j])</code></li><li>迭代更新 dp[i][j]</li></ol><h3 id="最长子序列输出"><a href="#最长子序列输出" class="headerlink" title="最长子序列输出"></a>最长子序列输出</h3><ol><li>若 <code>str[i] == patten[j]</code>，则输出 str[i] （导致反向输出）</li><li>若 <code>str[i] != patten[j]</code>，则判断 dp[i][j] 是等于上方的(i–)还是下方的(j–)，然后移到该方向。</li></ol><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LCS 问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lcs</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> string &amp;patten)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> strSize = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pattenSize = patten.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[strSize+<span class="number">1</span>][pattenSize+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= strSize; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= pattenSize; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-1</span>] == patten[j<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = strSize;</span><br><span class="line">    <span class="type">int</span> j = pattenSize;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; re;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i<span class="number">-1</span>] == patten[j<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            re.<span class="built_in">push_back</span>(str[i<span class="number">-1</span>]);</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dp[i][j] == dp[i][j<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(re.<span class="built_in">begin</span>(),re.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:re)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;kangqingfei&quot;</span>;</span><br><span class="line">    string patten = <span class="string">&quot;ng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lcs</span>(str,patten);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编辑距离问题-Edit-Distance"><a href="#编辑距离问题-Edit-Distance" class="headerlink" title="编辑距离问题(Edit Distance)"></a>编辑距离问题(Edit Distance)</h2><p>编辑距离和LCS很像，只是更新 dp[i][j] 的时候略有不同而已</p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>设定 dp[i][j] 为 str1(0…i) 与 str2(0…j) 的编辑距离</li></ul><ol><li>初始化 dp[0][j] 和 dp[i][0] 为 j 和 i  其含义为，一个字符串与一个空串的编辑距离为字符串本身的长度</li><li>更新dp[i][j],更新规则为，若 str1[i] &#x3D;&#x3D; str2[j] 则dp[i][j] &#x3D; dp[i-1][j-1] 若 str1[i] !&#x3D; str2[j] 则考虑 str1 不变，str2 可以通过 增加(dp[i-1][j] + 1) 删除(dp[i][j-1] + 1) 替换(dp[i-1][j-1] + 1) 变到str1</li><li>迭代更新 dp[i][j], 输出dp[iMax][jMax] 即为编辑距离</li></ol><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">editDistance</span>(string str1, string str2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length1 = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> length2 = str2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dp[length1+<span class="number">1</span>][length2+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= length1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= length2; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;<span class="comment">//                     增加       删除          替换</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[length1][length2]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;kangqingfei&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;kangqingfeng&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">editDistance</span>(str1,str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h2><p>该问题与 LCS 问题的区别就在于 是否连续<br>若可以连续就是<code>子串</code> 否则就是<code>子序列</code>。<br>对于子串的解法与子序列的解法基本一致 区别就在于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str1[i] != str2[j])</span><br><span class="line">    dp[i][j] = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(str1[i] == str2[j])</span><br><span class="line">    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span></span><br></pre></td></tr></table></figure><p>最后通过 遍历 dp[i][j] 来获得最大的子串长度，然后得到子串<br>在空间优化上面可以通过滚动数组来节省空间</p><h2 id="最大连续序列求和（Maximum-Contiguous-Subsequence-Sum）MCSS-问题"><a href="#最大连续序列求和（Maximum-Contiguous-Subsequence-Sum）MCSS-问题" class="headerlink" title="最大连续序列求和（Maximum Contiguous Subsequence Sum）MCSS 问题"></a>最大连续序列求和（Maximum Contiguous Subsequence Sum）MCSS 问题</h2><p>该问题为求一个序列的所有子序列中 和最大 的那个子序列。<br>该问题为简单的动态规划问题</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcss</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> dp[len];</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> ? arr[i<span class="number">-1</span>]+dp[i<span class="number">-1</span>]:arr[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; maxSum)</span><br><span class="line">            maxSum = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mcssPlus</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span><span class="comment">//空间优化版本</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tmpDp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmpDp &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpDp += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpDp = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpDp &gt; maxSum)</span><br><span class="line">            maxSum = tmpDp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6 -2 11 -4 13 -5 -2 -&gt; 20</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count,tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="built_in">mcssPlus</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。&quot;&gt;&lt;a href=&quot;#LCS-Longest-Common-Subsequence-问题即最长公共子序列问题，就是两个字符串的-子序列-而不是-子串-的最大的长度。&quot; class=&quot;headerlink&quot; title=&quot;LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 子序列 而不是 子串 的最大的长度。&quot;&gt;&lt;/a&gt;LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 &lt;code&gt;子序列&lt;/code&gt; 而不是 &lt;code&gt;子串&lt;/code&gt; 的最大的长度。&lt;/h2&gt;&lt;p&gt;之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="编辑距离" scheme="http://kangqingfei.cn/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>最长无重复子串</title>
    <link href="http://kangqingfei.cn/2018/01/27/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/"/>
    <id>http://kangqingfei.cn/2018/01/27/%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2/</id>
    <published>2018-01-27T07:24:09.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<p>与 <code>最长重复子串</code> 不一样的是，此问题要求所有子串中 没有重复字母的 子串中长度最长为多少。</p><p>题目来源 为 Leetcode 第三题 <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Longest Substring Without Repeating Characters</a></p><span id="more"></span><ul><li>基本思路是用的滑动窗口来遍历每个起始点的 无重复子串的 长度 ， 然后取得最大的长度。</li></ul><p>首先来个简单易懂的  每次清空hash表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str = s;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">            map[str[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>; j &lt; str.<span class="built_in">length</span>() &amp;&amp; map[str[j]] != <span class="number">1</span>; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                map[str[j]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j - i &gt; max)</span><br><span class="line">            &#123;</span><br><span class="line">                 max = j - i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>同样的思路，来个升级版 时间复杂度 O(2n) <code>abababababab</code>这种为最坏情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    string str = s;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len &amp;&amp; j &lt; len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(map[str[j]] == <span class="number">1</span>)<span class="comment">//左边前移 区间变短</span></span><br><span class="line">        &#123;</span><br><span class="line">            map[str[i++]]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右边前移 区间变长 更新 max</span></span><br><span class="line">        &#123;</span><br><span class="line">            map[str[j++]]++;</span><br><span class="line">            <span class="keyword">if</span>(j - i &gt; max)</span><br><span class="line">                max = j - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;与 &lt;code&gt;最长重复子串&lt;/code&gt; 不一样的是，此问题要求所有子串中 没有重复字母的 子串中长度最长为多少。&lt;/p&gt;
&lt;p&gt;题目来源 为 Leetcode 第三题 &lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/description/&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="hash" scheme="http://kangqingfei.cn/tags/hash/"/>
    
    <category term="滑动窗口" scheme="http://kangqingfei.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>最长重复子串-LRS</title>
    <link href="http://kangqingfei.cn/2018/01/25/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2-LRS/"/>
    <id>http://kangqingfei.cn/2018/01/25/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2-LRS/</id>
    <published>2018-01-25T11:06:52.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h3 id="此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS"><a href="#此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS" class="headerlink" title="此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS"></a>此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS</h3><span id="more"></span><p>针对子串是否重叠，又可以分为<code>可重叠的最长重复子串</code> 和 <code>不可重叠的重复子串</code>。</p><ul><li>可重叠的最长重复子串   参考<a href="http://www.voidcn.com/article/p-yjvdpysb-bee.html">后缀数组求最长重复子串</a><br>有关更多后缀数组的题 参考 vjudge-&gt;<a href="https://vjudge.net/contest/58608#overview">后缀数组入门</a></li></ul><h3 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h3><ol><li>通过后缀数组找到所有的子串</li><li>排序得到前后关联比较大的子串序列。注意排序完成后 <em>对于一个子串，一个与其重复最多的字符串肯定是紧挨着自己的两个字符串</em></li><li>遍历每个子串，将其与前后两个子串相比较，得到两者相同长度较大的一者</li><li>遍历所有得到的相同的长度，取最大的就是最长的公共子串</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>例如： banana 可以重复的最长子串是 ana<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCommonLnegth</span><span class="params">(string &amp;self, string &amp;compare)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = <span class="built_in">min</span>(self.<span class="built_in">length</span>(),compare.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(self[j] != compare[j])</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string words = <span class="string">&quot;banana&quot;</span>;</span><br><span class="line">    vector&lt;string &gt; suffix;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = words.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//int count = len;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        suffix.<span class="built_in">push_back</span>(words.<span class="built_in">substr</span>(i,len-i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对后缀数组进行排序</span></span><br><span class="line">    <span class="comment">// 注意到 排序完成之后 每个子序列的最长重复的另一子序列要么在其前面，要么在其后面</span></span><br><span class="line">    <span class="built_in">sort</span>(suffix.<span class="built_in">begin</span>(),suffix.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">commonLen</span><span class="params">(len,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到每个子序列的最长重复长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; i != len <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             commonLen[i] = <span class="built_in">max</span>(<span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i<span class="number">-1</span>]),<span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i+<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            commonLen[i] = <span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == len <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            commonLen[i] = <span class="built_in">getCommonLnegth</span>(suffix[i],suffix[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>,maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxLen &lt; commonLen[i])</span><br><span class="line">        &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            maxLen = commonLen[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxLen; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;suffix[index][i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>不可重叠最长重复子串<br>顾名思义，前后的子串是在不能重叠的情况下面的最长的重复的长度</li></ul><h3 id="类似题型变种还有"><a href="#类似题型变种还有" class="headerlink" title="类似题型变种还有:"></a>类似题型变种还有:</h3><ol start="0"><li><a href="http://blog.csdn.net/qinzhenhua100/article/details/39968291">最长不重叠重复子串 POJ 1743</a></li><li><a href="http://blog.csdn.net/ACdreamers/article/details/9121117">可重叠的K次最长重复子串(POJ 3261)</a></li><li><a href="http://forever97.is-programmer.com/2016/8/12/spoj687.204992.html">重复次数最多的连续重复子串的长度(SPOJ 687)</a></li><li><a href="http://blog.csdn.net/ZouCharming/article/details/46699583">求重复次数最多的子串 POJ 3693</a></li><li><a href="http://blog.csdn.net/u013351484/article/details/43113201">至少重复k次的可重叠的最长重复子串 POJ 3882</a></li><li><a href="http://www.cnblogs.com/zichi/p/4841878.html">RMQ (Range Minimum&#x2F;Maximum Query) 求解中的 ST 算法</a></li><li><a href="http://dongxicheng.org/structure/lca-rmq/">LCA 与 RMQ</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS&quot;&gt;&lt;a href=&quot;#此问题是针对单个字符里面出现的子串的重复的最长的长度-称为最长重复子串-Longest-Repeat-Substring-LRS&quot; class=&quot;headerlink&quot; title=&quot;此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS&quot;&gt;&lt;/a&gt;此问题是针对单个字符里面出现的子串的重复的最长的长度 称为最长重复子串(Longest Repeat Substring)LRS&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="后缀数组" scheme="http://kangqingfei.cn/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
    <category term="字符串" scheme="http://kangqingfei.cn/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="LRS" scheme="http://kangqingfei.cn/tags/LRS/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列-LIS</title>
    <link href="http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/"/>
    <id>http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/</id>
    <published>2018-01-22T13:45:57.000Z</published>
    <updated>2022-09-14T18:03:38.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题"><a href="#LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题" class="headerlink" title="LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题"></a>LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题</h3><p>简单来讲就是要找到一个序列中，所有递增子序列中长度最长的子序列的长度。子序列的取值不要求在原序列中连续。</p><span id="more"></span><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>dp[i] 记录： 以arr[i]结尾的递增子序列的最大长度。<br>dp[i] 的更新：遍历 arr[0] 到 arr[i - 1] 中 小于 arr[i] 的数，并找到所有满足条件的arr[x] 中 dp[x] 最大的那个dp[n]，则dp[i] &#x3D; dp[n] + 1<br>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lis 动态规划 复杂度 O(n^2)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lis</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = length;</span><br><span class="line">    <span class="type">int</span> dp[len] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmpMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])</span><br><span class="line">                tmpMax = <span class="built_in">max</span>(dp[j],tmpMax);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = tmpMax + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmpMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; tmpMax)</span><br><span class="line">        &#123;</span><br><span class="line">            tmpMax = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种递增，即必须严格递增，不能相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格递增不能相等lis</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-二分"><a href="#动态规划-二分" class="headerlink" title="动态规划 + 二分"></a>动态规划 + 二分</h3><p>dp[i] 记录：当前最长的递增子序列的值<br>dp[i] 更新：把arr[i] 放入到 dp[i] 中，其放置方法为，从arr[0] 到 arr[len] 找到第一个大于等于arr[i]的位置pos，dp[pos] &#x3D; arr[i]。并更新len &#x3D; max(len,pos+1);<br>len增加（len &lt; pos +1）的情况只有一种，便是在当前序列的末尾增加了一个数(pos &#x3D; len)，反之如果只是在中间进行替换并不会改变len的大小。<br>注意到这里对 pos 的查找是对一个有序的序列的查找，可以使用二分查到达到log(n) 的复杂度。</p><p>参考代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分+动态规划</span></span><br><span class="line"><span class="built_in">lisDich</span>(<span class="type">int</span> *arr, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> l = length;</span><br><span class="line">    <span class="type">int</span> dp[l] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(dp,dp+len,arr[i]) - dp;<span class="comment">//二分查找，节省时间</span></span><br><span class="line">        dp[pos] = arr[i];</span><br><span class="line">        len = <span class="built_in">max</span>(len,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到的函数函数<code>lower_bound()</code> 用于在first和last中的前闭后开区间进行二分查找，返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置</p><h3 id="华为机试题-24题-合唱队"><a href="#华为机试题-24题-合唱队" class="headerlink" title="华为机试题 24题 合唱队"></a>华为机试题 24题 合唱队</h3><p>一种LIS的变种，通过正向与反向两次dp得到arr[i]左侧递增和右侧递减的长度，将两者相加得到一个满足条件的最大长度。<br>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, vector&lt;<span class="type">int</span>&gt; &amp;dp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j] &amp;&amp; dp[j] + <span class="number">1</span> &gt; dp[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calLis</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpf</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpr</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(size,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">lis</span>(arr,dpf);</span><br><span class="line">    <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">lis</span>(arr,dpr);</span><br><span class="line">    <span class="built_in">reverse</span>(dpr.<span class="built_in">begin</span>(),dpr.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = dpf[i] + dpr[i];</span><br><span class="line">        <span class="keyword">if</span>(max &lt; dp[i])</span><br><span class="line">            max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span> &gt; arr;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp;</span><br><span class="line">        arr.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;tmp;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>() - <span class="built_in">calLis</span>(arr);</span><br><span class="line">        cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>参考<a href="https://xuanwo.org/2015/07/31/dp-lis/">动态规划——最长上升子序列问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题&quot;&gt;&lt;a href=&quot;#LIS问题-Longest-Increasing-Subsequence-Problem-动态规划中经典的问题&quot; class=&quot;headerlink&quot; title=&quot;LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题&quot;&gt;&lt;/a&gt;LIS问题(Longest Increasing Subsequence Problem) 动态规划中经典的问题&lt;/h3&gt;&lt;p&gt;简单来讲就是要找到一个序列中，所有递增子序列中长度最长的子序列的长度。子序列的取值不要求在原序列中连续。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="动态规划" scheme="http://kangqingfei.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LIS" scheme="http://kangqingfei.cn/tags/LIS/"/>
    
  </entry>
  
  <entry>
    <title>今日头条2018校招算法方向 第一批</title>
    <link href="http://kangqingfei.cn/2018/01/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E6%96%B9%E5%90%91-%E7%AC%AC%E4%B8%80%E6%89%B9/"/>
    <id>http://kangqingfei.cn/2018/01/07/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A12018%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95%E6%96%B9%E5%90%91-%E7%AC%AC%E4%B8%80%E6%89%B9/</id>
    <published>2018-01-07T12:45:24.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="今日头条2018校招算法方向-第一批-链接：here"><a href="#今日头条2018校招算法方向-第一批-链接：here" class="headerlink" title="今日头条2018校招算法方向 第一批 链接：here"></a>今日头条2018校招算法方向 第一批 链接：<a href="https://www.nowcoder.com/test/8537290/summary">here</a></h1><h2 id="三道编程题，难度循序渐进，第三题做了很久还是有问题"><a href="#三道编程题，难度循序渐进，第三题做了很久还是有问题" class="headerlink" title="三道编程题，难度循序渐进，第三题做了很久还是有问题"></a>三道编程题，难度循序渐进，第三题做了很久还是有问题</h2><span id="more"></span><ol><li>一道求外围点的题<h3 id="P为给定的二维平面整数点集。定义-P-中某点x，如果x满足-P-中任意点都不在-x-的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复-坐标轴范围在-0-1e9-内）"><a href="#P为给定的二维平面整数点集。定义-P-中某点x，如果x满足-P-中任意点都不在-x-的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复-坐标轴范围在-0-1e9-内）" class="headerlink" title="P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）"></a>P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）</h3> 如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。 <img src="/assest/images/2018010701.jpg" class=""><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3> 第一行输入点集的个数 N， 接下来 N 行，每行两个数字代表点的 X 轴和 Y 轴。<br> 对于 50%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 10000;<br> 对于 100%的数据, 1 &lt;&#x3D; N &lt;&#x3D; 500000;<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出“最大的” 点集合， 按照 X 轴从小到大的方式输出，每行两个数字分别代表点的 X 轴和 Y轴。<h3 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 5<br> 1 2<br> 5 3<br> 4 6<br> 7 5<br> 9 0<h3 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 4 6<br> 7 5<br> 9 0<h3 id="思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代"><a href="#思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代" class="headerlink" title="思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代"></a>思路如果是暴力枚举的话肯定就超时了，这里要用到一个小技巧，就是对横坐标或是纵坐标排序，然后才进行迭代</h3> 还有一个坑就是，输入输出的方式，这里一开始用 cin 和 cout 发现一直是80%AC 改成scanf 和 printf后就是100% :(<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 今日头条实习生 第一题 100% AC cin 与 cout 太浪费时间（80%AC） 改用 scanf 和 printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &gt; b.second;   <span class="comment">//升序排列，如果改为return a&gt;b，则为降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; <span class="built_in">points</span>(count);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;points[i].first, &amp;points[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(),points.<span class="built_in">end</span>(),compare);</span><br><span class="line"></span><br><span class="line">    pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pointTmp = points[<span class="number">0</span>];</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; goodPoints;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(points[i].first &gt;= pointTmp.first)</span><br><span class="line">        &#123;</span><br><span class="line">            goodPoints.<span class="built_in">push_back</span>(i);</span><br><span class="line">            pointTmp = points[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : goodPoints)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, points[c].first,points[c].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一道很像动态规划的单调栈题<h3 id="给定一个数组序列-需要求选出一个区间-使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数-区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列-6-2-1-则根据上述公式-可得到所有可以选定各个区间的计算值"><a href="#给定一个数组序列-需要求选出一个区间-使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数-区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列-6-2-1-则根据上述公式-可得到所有可以选定各个区间的计算值" class="headerlink" title="给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:"></a>给定一个数组序列, 需要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和最后程序输出经过计算后的最大值即可，不需要输出具体的区间。如给定序列 [6 2 1]则根据上述公式, 可得到所有可以选定各个区间的计算值:</h3><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述:"></a>输入描述:</h3> 第一行输入数组序列长度n，第二行输入数组序列。<br> 对于 50%的数据, 1 &lt;&#x3D; n &lt;&#x3D; 10000;<br> 对于 100%的数据, 1 &lt;&#x3D; n &lt;&#x3D; 500000;<h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出数组经过计算后的最大值。<h3 id="输入例子1-1"><a href="#输入例子1-1" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 3<br> 6 2 1<h3 id="输出例子1-1"><a href="#输出例子1-1" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 36<h3 id="思路，有一种动态规划的思路，但是AC好像只有40-原因是内存超出限制"><a href="#思路，有一种动态规划的思路，但是AC好像只有40-原因是内存超出限制" class="headerlink" title="思路，有一种动态规划的思路，但是AC好像只有40% 原因是内存超出限制"></a>思路，有一种动态规划的思路，但是AC好像只有40% 原因是内存超出限制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 动态规划解法 40% AC 内存超出限制</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(num+<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">mindp</span>(num,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>] + arr[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; num; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                mindp[i][j] = arr[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mindp[i][j] = <span class="built_in">min</span>(mindp[i][j<span class="number">-1</span>],arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum,mindp[i][j] * (sum[j+<span class="number">1</span>] - sum[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值"><a href="#第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值" class="headerlink" title="第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值"></a>第二种就是单调栈的解法，大致的思路就是维护一个单调栈，然后每次更新栈的同时更新最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈解法 100% AC</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vecSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> begin, <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin &gt; end)</span><br><span class="line">        begin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i = begin; i &lt;= end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        re += vec[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    <span class="keyword">while</span>(count-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmp;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; upStack;</span><br><span class="line"></span><br><span class="line">    arr.<span class="built_in">push_back</span>(<span class="number">-1</span>); <span class="comment">// 先添加一个小于0 的数作为比较，以去除每次非空的判断</span></span><br><span class="line">    upStack.<span class="built_in">push</span>(num); <span class="comment">// 将 最后的那个自行添加的数的下标添加到栈中</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt;= arr[upStack.<span class="built_in">top</span>()])<span class="comment">// 如果比当前的栈顶的元素要大的话就直接压栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            upStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则的话就先弹出栈顶的元素，直到满足上面的压栈条件，</span></span><br><span class="line">        <span class="comment">// 并且 计算 栈顶元素的单调区间（以栈顶元素开始往前单调递减 但 不小于当前值的 整个区间）的值</span></span><br><span class="line">        <span class="comment">// 然后更新 maxSum 的值 并压栈</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(arr[i] &lt; arr[upStack.<span class="built_in">top</span>()])</span><br><span class="line">            &#123;</span><br><span class="line">                top = upStack.<span class="built_in">top</span>();</span><br><span class="line">                upStack.<span class="built_in">pop</span>();</span><br><span class="line">                maxSum = <span class="built_in">max</span>(maxSum,arr[top] * <span class="built_in">vecSum</span>(arr,upStack.<span class="built_in">top</span>()+<span class="number">1</span>,i<span class="number">-1</span>));<span class="comment">//弹出栈并更新最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">             upStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> topEnd = upStack.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">while</span>(upStack.<span class="built_in">top</span>() != num)</span><br><span class="line">    &#123;</span><br><span class="line">        top = upStack.<span class="built_in">top</span>();</span><br><span class="line">        upStack.<span class="built_in">pop</span>();</span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum,arr[top] * <span class="built_in">vecSum</span>(arr,upStack.<span class="built_in">top</span>()+<span class="number">1</span>,topEnd));<span class="comment">//弹出栈并更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;maxSum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>一道任务调度的题 该题较难，没有AC 但是我感觉思路是死的，也没想到啥高端的算法<h3 id="产品经理-PM-有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个-idea，每个-idea-有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有-PM-会在同一时刻提出两个-idea。"><a href="#产品经理-PM-有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个-idea，每个-idea-有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有-PM-会在同一时刻提出两个-idea。" class="headerlink" title="产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。"></a>产品经理(PM)有很多好的idea，而这些idea需要程序员实现。现在有N个PM，在某个时间会想出一个 idea，每个 idea 有提出时间、所需时间和优先等级。对于一个PM来说，最想实现的idea首先考虑优先等级高的，相同的情况下优先所需时间最小的，还相同的情况下选择最早想出的，没有 PM 会在同一时刻提出两个 idea。</h3> 同时有M个程序员，每个程序员空闲的时候就会查看每个PM尚未执行并且最想完成的一个idea,然后从中挑选出所需时间最小的一个idea独立实现，如果所需时间相同则选择PM序号最小的。直到完成了idea才会重复上述操作。如果有多个同时处于空闲状态的程序员，那么他们会依次进行查看idea的操作。<br> 求每个idea实现的时间。<br> 输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。输出P行，分别表示每个idea实现的时间点。<h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述:"></a>输入描述:</h3> 输入第一行三个数N、M、P，分别表示有N个PM，M个程序员，P个idea。随后有P行，每行有4个数字，分别是PM序号、提出时间、优先等级和所需时间。全部数据范围 [1, 3000]。<h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述:"></a>输出描述:</h3> 输出P行，分别表示每个idea实现的时间点。<h3 id="输入例子1-2"><a href="#输入例子1-2" class="headerlink" title="输入例子1:"></a>输入例子1:</h3> 2 2 5<br> 1 1 1 2<br> 1 2 1 1<br> 1 3 2 2<br> 2 1 1 2<br> 2 3 5 5<h3 id="输出例子1-2"><a href="#输出例子1-2" class="headerlink" title="输出例子1:"></a>输出例子1:</h3> 3<br> 4<br> 5<br> 3<br> 9<h3 id="能有的思路就是一个死的思路，但是没有AC-贴上代码-这里有个10-AC的代码"><a href="#能有的思路就是一个死的思路，但是没有AC-贴上代码-这里有个10-AC的代码" class="headerlink" title="能有的思路就是一个死的思路，但是没有AC 贴上代码,这里有个10%AC的代码"></a>能有的思路就是一个死的思路，但是没有AC 贴上代码,<a href="http://blog.csdn.net/Geng19930909/article/details/77506945">这里</a>有个10%AC的代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> idealId;</span><br><span class="line">    <span class="type">int</span> pmId;</span><br><span class="line">    <span class="type">int</span> timeStart;</span><br><span class="line">    <span class="type">int</span> pority;</span><br><span class="line">    <span class="type">int</span> timeCost;</span><br><span class="line">    <span class="type">int</span> timeFinish;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(Task t1,Task t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.pority == t2.pority)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(t1.timeCost == t2.timeCost)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> t1.timeStart &lt; t2.timeStart;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> t1.timeCost &lt; t2.timeCost;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.pority &lt; t2.pority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTask</span><span class="params">(Task t1,Task t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.timeCost == t2.timeCost)</span><br><span class="line">        <span class="keyword">return</span> t1.pmId &lt; t2.pmId;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> t1.pmId &lt; t2.pmId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPmTask</span><span class="params">( vector&lt;vector&lt;Task &gt; &gt; &amp; pmdata, vector&lt;Task&gt; &amp; taskPerPm, vector&lt;<span class="type">int</span>&gt; &amp;selectIndex, <span class="type">int</span> &amp; coder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    taskPerPm.<span class="built_in">clear</span>();</span><br><span class="line">    Task tmpTask;</span><br><span class="line">    <span class="type">int</span> select = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pmdata.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pmdata[i].<span class="built_in">size</span>() == <span class="number">0</span>)<span class="comment">//该pm已经没有任务可以调度了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coder &lt; pmdata[i][<span class="number">0</span>].timeStart)<span class="comment">//如果优先级高的需要等待，则优先选择不需要等待的次高优先级的任务 情况一</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpTask = pmdata[i][<span class="number">0</span>];</span><br><span class="line">                select = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; pmdata[i].<span class="built_in">size</span>(); ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(pmdata[i][j].timeStart &lt; tmpTask.timeStart)<span class="comment">//待定任务</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        tmpTask = pmdata[i][j];<span class="comment">//更新需要等待时间最少的任务</span></span><br><span class="line">                        select = j;</span><br><span class="line">                        <span class="keyword">if</span>(coder &gt;= pmdata[i][j].timeStart)<span class="comment">//找到优先级最高的那个不需要等待的任务</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            taskPerPm.<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">                            selectIndex[i] = select;<span class="comment">//更新当先加入队列中的任务</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                taskPerPm.<span class="built_in">push_back</span>(tmpTask);<span class="comment">//该pm找不到不需要等待的任务</span></span><br><span class="line">                selectIndex[i] = select;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//高优先级，不需要等待，直接进入队列 情况二</span></span><br><span class="line">            &#123;</span><br><span class="line">                taskPerPm.<span class="built_in">push_back</span>(pmdata[i][<span class="number">0</span>]);</span><br><span class="line">                selectIndex[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tasklt</span><span class="params">(<span class="type">int</span> &amp; coder, vector&lt;<span class="type">int</span>&gt; &amp; selectIndex, vector&lt;Task&gt; &amp; taskPerPm, vector&lt;vector&lt;Task &gt; &gt; &amp; pmdata, vector&lt;Task&gt; &amp; data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 选出需要完成的最高优先级任务</span></span><br><span class="line">    Task tmpTask = taskPerPm[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 并判断coder空闲的时间任务有没有产生，如果没有产生就去获取最先产生的次优先级的任务</span></span><br><span class="line">    <span class="keyword">if</span>(coder &lt; tmpTask.timeStart)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; taskPerPm.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tmpTask.timeStart &gt; taskPerPm[i].timeStart)<span class="comment">// 选取最先产生的任务</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpTask = taskPerPm[i];</span><br><span class="line">                <span class="keyword">if</span>(coder &gt;= tmpTask.timeStart)<span class="comment">//在满足已经产生的情况下，优先级最高的任务 找到了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成一个任务 然后更新它的 timeFinish</span></span><br><span class="line">    data[tmpTask.idealId].timeFinish = tmpTask.timeCost + (tmpTask.timeStart &gt; coder ? tmpTask.timeStart : coder);</span><br><span class="line">    <span class="comment">// 更新coder的工作时长</span></span><br><span class="line">    coder += tmpTask.timeStart &gt; coder ? tmpTask.timeStart : <span class="number">0</span>;<span class="comment">//加上等待时间</span></span><br><span class="line">    coder += tmpTask.timeCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从pm的待解决任务中移除已经调度的任务</span></span><br><span class="line">    vector&lt;Task&gt;::iterator it =  pmdata[tmpTask.pmId].<span class="built_in">begin</span>()+selectIndex[tmpTask.pmId];</span><br><span class="line">    pmdata[tmpTask.pmId].<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pmNum, coderNum, idealNum;</span><br><span class="line">    cin&gt;&gt;pmNum&gt;&gt;coderNum&gt;&gt;idealNum;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;Task &gt; &gt; <span class="built_in">pmdata</span>(pmNum);</span><br><span class="line">    vector&lt;Task &gt; data;</span><br><span class="line">    Task tmpTask;</span><br><span class="line"></span><br><span class="line">    tmpTask.timeFinish = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> idealNumtmp = idealNum;</span><br><span class="line">    <span class="keyword">while</span>(idealNumtmp-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;tmpTask.pmId&gt;&gt;tmpTask.timeStart&gt;&gt;tmpTask.pority&gt;&gt;tmpTask.timeCost;</span><br><span class="line">        tmpTask.idealId = idealNum - idealNumtmp<span class="number">-1</span>;</span><br><span class="line">        tmpTask.pmId -= <span class="number">1</span>;</span><br><span class="line">        data.<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">        pmdata[tmpTask.pmId].<span class="built_in">push_back</span>(tmpTask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先不考虑产生时间， 按照固定的优先级进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pmNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(pmdata[i].<span class="built_in">begin</span>(),pmdata[i].<span class="built_in">end</span>(),compare);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span> &gt; <span class="title">coder</span><span class="params">(coderNum)</span></span>; <span class="comment">// 程序员的当前时间点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : coder)</span><br><span class="line">    &#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">selectIndex</span><span class="params">(pmNum)</span></span>;<span class="comment">//当前进入选择队列的下标</span></span><br><span class="line">    vector&lt;Task&gt; taskPerPm;<span class="comment">//里面是每个pm最想完成的任务</span></span><br><span class="line">    idealNumtmp = idealNum;</span><br><span class="line">    <span class="keyword">while</span>(idealNumtmp-- &gt; <span class="number">0</span>) <span class="comment">// 对每个任务进行调度</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先从pm处获取任务，分为两种情况，coder空闲时 任务已经产生还是没有产生</span></span><br><span class="line">        <span class="built_in">getPmTask</span>(pmdata,taskPerPm,selectIndex,coder[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">sort</span>(taskPerPm.<span class="built_in">begin</span>(),taskPerPm.<span class="built_in">end</span>(),getTask);<span class="comment">// 获取优先级最高的任务</span></span><br><span class="line">        <span class="built_in">tasklt</span>(coder[<span class="number">0</span>],selectIndex,taskPerPm,pmdata,data);<span class="comment">// 寻找优先级最高的任务给 最先完成的程序员进行调度</span></span><br><span class="line">        <span class="built_in">sort</span>(coder.<span class="built_in">begin</span>(),coder.<span class="built_in">end</span>());<span class="comment">//重新进行排序 以获取先完成的任务coder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : data)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;c.timeFinish&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;今日头条2018校招算法方向-第一批-链接：here&quot;&gt;&lt;a href=&quot;#今日头条2018校招算法方向-第一批-链接：here&quot; class=&quot;headerlink&quot; title=&quot;今日头条2018校招算法方向 第一批 链接：here&quot;&gt;&lt;/a&gt;今日头条2018校招算法方向 第一批 链接：&lt;a href=&quot;https://www.nowcoder.com/test/8537290/summary&quot;&gt;here&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;三道编程题，难度循序渐进，第三题做了很久还是有问题&quot;&gt;&lt;a href=&quot;#三道编程题，难度循序渐进，第三题做了很久还是有问题&quot; class=&quot;headerlink&quot; title=&quot;三道编程题，难度循序渐进，第三题做了很久还是有问题&quot;&gt;&lt;/a&gt;三道编程题，难度循序渐进，第三题做了很久还是有问题&lt;/h2&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="头条" scheme="http://kangqingfei.cn/tags/%E5%A4%B4%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>腾讯2016研发工程师编程题</title>
    <link href="http://kangqingfei.cn/2018/01/06/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/01/06/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <published>2018-01-06T11:39:44.000Z</published>
    <updated>2022-09-14T18:03:38.046Z</updated>
    
    <content type="html"><![CDATA[<p>腾讯笔试编程题：链接 <a href="http://static.nowcoder.com/pdf/paper/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98.pdf">腾讯2016研发工程师编程题</a></p><span id="more"></span><ol><li><p>格雷码的输出</p><h3 id="在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，-则称这种编码为格雷码-Gray-Code-，请编写一个函数，使用递归的方法生成N位的格雷码。"><a href="#在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同，-则称这种编码为格雷码-Gray-Code-，请编写一个函数，使用递归的方法生成N位的格雷码。" class="headerlink" title="在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同， 则称这种编码为格雷码(Gray Code)，请编写一个函数，使用递归的方法生成N位的格雷码。"></a>在一组数的编码中，若任意两个相邻的代码只有一位二进制数不同， 则称这种编码为格雷码(Gray Code)，请编写一个函数，使用递归的方法生成N位的格雷码。</h3><p> 给定一个整数n，请返回n位的格雷码，顺序为从0开始。</p><h3 id="测试样例："><a href="#测试样例：" class="headerlink" title="测试样例："></a>测试样例：</h3><p> 输入：1<br> 返回：[“0”,”1”]</p><h2 id="这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可"><a href="#这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可" class="headerlink" title="这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可"></a>这是一个简单的递归的使用，摸清规律，并搞清楚先后顺序即可</h2></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GrayCode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getGray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getGray</span>(n <span class="number">-1</span>);</span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">tmp</span><span class="params">(result)</span></span>;<span class="comment">//复制两份</span></span><br><span class="line">            <span class="function">vector&lt;string&gt; <span class="title">tmp1</span><span class="params">(result)</span></span>;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); ++i) <span class="comment">// 从前往后开始遍历 在首部添加0</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="string">&quot;0&quot;</span>+tmp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = tmp1.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i)<span class="comment">//从后往前开始遍历 在首部添加1</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="string">&quot;1&quot;</span>+tmp1[i]); <span class="comment">//将复制的两份添加数字后放到result中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>寻找出现次数超过一半的红包</p><h3 id="春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。"><a href="#春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。" class="headerlink" title="春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。"></a>春节期间小明使用微信收到很多个红包，非常开心。在查看领取红包记录时发现，某个红包金额出现的次数超过了红包总数的一半。请帮小明找到该红包金额。写出具体算法思路和代码实现，要求算法尽可能高效。</h3><h3 id="给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。"><a href="#给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。" class="headerlink" title="给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。"></a>给定一个红包的金额数组gifts及它的大小n，请返回所求红包的金额。</h3><p> 若没有金额超过总数的一半，返回0。</p><h3 id="测试样例：-1"><a href="#测试样例：-1" class="headerlink" title="测试样例："></a>测试样例：</h3><p> 输入： [1,2,3,2,2],5<br> 返回：2</p><h2 id="思路：-用-count-来维持一个一直出现的红包x的数量，若-x-再次出现则count-若x不再出现则count–-如果count为0了，则重置count并更新-x-这样就能够找到出现次数最多的-x-。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x"><a href="#思路：-用-count-来维持一个一直出现的红包x的数量，若-x-再次出现则count-若x不再出现则count–-如果count为0了，则重置count并更新-x-这样就能够找到出现次数最多的-x-。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x" class="headerlink" title="思路： 用 count 来维持一个一直出现的红包x的数量，若 x 再次出现则count++ 若x不再出现则count– 如果count为0了，则重置count并更新 x 这样就能够找到出现次数最多的 x 。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x"></a>思路： 用 count 来维持一个一直出现的红包x的数量，若 x 再次出现则count++ 若x不再出现则count– 如果count为0了，则重置count并更新 x 这样就能够找到出现次数最多的 x 。该思路对于超过一半的x一定能找到其值，但如果出现次数最多的x数量没有过半，则不一定能找到x</h2></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Gift</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt; gifts, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>( n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>,tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = gifts[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp == gifts[i])</span><br><span class="line">                    count++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(gifts[i] == tmp)</span><br><span class="line">                size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(size &gt; n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;腾讯笔试编程题：链接 &lt;a href=&quot;http://static.nowcoder.com/pdf/paper/%E8%85%BE%E8%AE%AF2016%E7%A0%94%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%BC%96%E7%A8%8B%E9%A2%98.pdf&quot;&gt;腾讯2016研发工程师编程题&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="tencent" scheme="http://kangqingfei.cn/tags/tencent/"/>
    
    <category term="笔试题" scheme="http://kangqingfei.cn/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://kangqingfei.cn/2018/01/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://kangqingfei.cn/2018/01/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2018-01-06T08:55:10.000Z</published>
    <updated>2022-09-14T18:03:38.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="各类背包问题集锦"><a href="#各类背包问题集锦" class="headerlink" title="各类背包问题集锦"></a>各类背包问题集锦</h2><h3 id="背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识"><a href="#背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识" class="headerlink" title="背包问题都是通过 动态规划 来求解的，在此之前需要了解动态规划的相关知识"></a>背包问题都是通过 <strong>动态规划</strong> 来求解的，在此之前需要了解<a href="http://kangqingfei.cn/">动态规划的相关知识</a></h3><h3 id="网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。"><a href="#网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。" class="headerlink" title="网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。"></a>网上有很好的参考资料：<a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">背包问题九讲</a>，自己也是参考该资料入门的。</h3><span id="more"></span><h3 id="下面列举一些刷题中遇到的实际的背包问题"><a href="#下面列举一些刷题中遇到的实际的背包问题" class="headerlink" title="下面列举一些刷题中遇到的实际的背包问题"></a>下面列举一些刷题中遇到的实际的背包问题</h3><ol><li><p>华为机试 16&#x2F;108 题 -&gt; 购物单</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p> 王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：<br> 主件附件<br> 电脑打印机，扫描仪<br> 书柜图书<br> 书桌台灯，文具<br> 工作椅无<br> 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。<br> 设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：<br> <code>v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ]</code> 。（其中 <code>*</code> 为乘号）<br> 请你帮助王强设计一个满足要求的购物单。</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p> 输入的第 1 行，为两个正整数，用一个空格隔开：N m<br> 其中 N （ &lt;32000 ）表示总钱数， m （ &lt;60 ）为希望购买物品的个数。<br> 从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q<br> 其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q&#x3D;0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p> 输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ &lt;200000 ）。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p> 输入<br> 1000 5<br> 800 2 0<br> 400 5 1<br> 300 5 1<br> 400 3 0<br> 500 2 0<br> 输出<br> 2200</p><h2 id="有依赖的背包问题：-将依赖转换为分组的背包问题，通过先后迭代-分组g-容量-v-每个分组中的条目-k-来求解最优解"><a href="#有依赖的背包问题：-将依赖转换为分组的背包问题，通过先后迭代-分组g-容量-v-每个分组中的条目-k-来求解最优解" class="headerlink" title="有依赖的背包问题： 将依赖转换为分组的背包问题，通过先后迭代 分组g 容量 v 每个分组中的条目 k 来求解最优解"></a>有依赖的背包问题： 将依赖转换为分组的背包问题，通过先后迭代 分组g 容量 v 每个分组中的条目 k 来求解最优解</h2></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;<span class="comment">//物品个数</span></span><br><span class="line">    <span class="type">int</span> N;<span class="comment">//总钱数</span></span><br><span class="line">    cin&gt;&gt;N&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    N /= <span class="number">10</span>; <span class="comment">//总钱数是10的倍数，先除以10 以节约空间</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> num = c;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> money = N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int price[num][3];//进行分组 事实上 num/3 &lt;= 分组数 &lt;= num 这里浪费了空间 clang++ 与 g++的不兼容的问题</span></span><br><span class="line">    <span class="comment">//int value[num][3];</span></span><br><span class="line">    <span class="type">int</span> price[<span class="number">61</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> value[<span class="number">61</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> h = <span class="number">0</span>; h &lt; num; ++h)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            price[h][j] = <span class="number">0</span>;</span><br><span class="line">            value[h][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i,j,m,n;</span><br><span class="line">    <span class="type">int</span> v,p,q;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    m = <span class="number">0</span>;</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v&gt;&gt;p&gt;&gt;q;</span><br><span class="line">        v /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">0</span>) <span class="comment">//主件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            price[j][<span class="number">0</span>] = v;</span><br><span class="line">            value[j][<span class="number">0</span>] = v*p;</span><br><span class="line">            n += m; <span class="comment">//记录实际的分组号与q（总的物件数量）的差值</span></span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//附件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(price[j][<span class="number">1</span>] == <span class="number">0</span>)<span class="comment">//第一个附件</span></span><br><span class="line">            &#123;</span><br><span class="line">                price[q-n][<span class="number">1</span>] = v;</span><br><span class="line">                value[q-n][<span class="number">1</span>] = v*p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//第二个附件</span></span><br><span class="line">            &#123;</span><br><span class="line">                price[q-n][<span class="number">2</span>] = v;</span><br><span class="line">                value[q-n][<span class="number">2</span>] = v*p;</span><br><span class="line">            &#125;</span><br><span class="line">            m++;<span class="comment">//附件个数计数,为了正确的分组，即当前主件有多少个附件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> group = j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int dp[group+1][money+1];// 第i个分组 在使用j数量钱 的 最大收益</span></span><br><span class="line">    <span class="type">int</span> dp[<span class="number">61</span>][<span class="number">3201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= group; ++j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= money; ++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j][k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= group; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = money; j &gt; <span class="number">0</span>; --j)<span class="comment">//从最大值开始，防止出现 j - price &lt; 0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 三个if就把分组的背包问题转换成了普通的背包问题</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= price[i][<span class="number">0</span>])<span class="comment">//只购买主件dp[i-1][j-price[i][0]] 为空出这么多钱的情况下的最大收益</span></span><br><span class="line">                dp[i][j] = <span class="built_in">getMax</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-price[i][<span class="number">0</span>]]+value[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= ( price[i][<span class="number">0</span>] + price[i][<span class="number">1</span>] ))<span class="comment">//购买主件和1附件</span></span><br><span class="line">                dp[i][j] = <span class="built_in">getMax</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-price[i][<span class="number">0</span>] - price[i][<span class="number">1</span>]]+value[i][<span class="number">0</span>]+value[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= price[i][<span class="number">0</span>] + price[i][<span class="number">1</span>] + price[i][<span class="number">2</span>])<span class="comment">// 购买主件和 1,2 附件</span></span><br><span class="line">                dp[i][j] = <span class="built_in">getMax</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-price[i][<span class="number">0</span>] - price[i][<span class="number">1</span>] - price[i][<span class="number">2</span>]]+value[i][<span class="number">0</span>]+value[i][<span class="number">1</span>]+value[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">10</span>*dp[group][money]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>背包问题2</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;各类背包问题集锦&quot;&gt;&lt;a href=&quot;#各类背包问题集锦&quot; class=&quot;headerlink&quot; title=&quot;各类背包问题集锦&quot;&gt;&lt;/a&gt;各类背包问题集锦&lt;/h2&gt;&lt;h3 id=&quot;背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识&quot;&gt;&lt;a href=&quot;#背包问题都是通过-动态规划-来求解的，在此之前需要了解动态规划的相关知识&quot; class=&quot;headerlink&quot; title=&quot;背包问题都是通过 动态规划 来求解的，在此之前需要了解动态规划的相关知识&quot;&gt;&lt;/a&gt;背包问题都是通过 &lt;strong&gt;动态规划&lt;/strong&gt; 来求解的，在此之前需要了解&lt;a href=&quot;http://kangqingfei.cn/&quot;&gt;动态规划的相关知识&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。&quot;&gt;&lt;a href=&quot;#网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。&quot; class=&quot;headerlink&quot; title=&quot;网上有很好的参考资料：背包问题九讲，自己也是参考该资料入门的。&quot;&gt;&lt;/a&gt;网上有很好的参考资料：&lt;a href=&quot;http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/&quot;&gt;背包问题九讲&lt;/a&gt;，自己也是参考该资料入门的。&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="背包问题" scheme="http://kangqingfei.cn/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>华为机试</title>
    <link href="http://kangqingfei.cn/2018/01/06/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/"/>
    <id>http://kangqingfei.cn/2018/01/06/%E5%8D%8E%E4%B8%BA%E6%9C%BA%E8%AF%95/</id>
    <published>2018-01-06T08:03:07.000Z</published>
    <updated>2022-09-14T18:03:38.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="华为机试题汇总，对于一些比较复杂的题目会单独分析"><a href="#华为机试题汇总，对于一些比较复杂的题目会单独分析" class="headerlink" title="华为机试题汇总，对于一些比较复杂的题目会单独分析"></a>华为机试题汇总，对于一些比较复杂的题目会单独分析</h2><h3 id="链接：https-www-nowcoder-com-ta-huawei-总共-108-道题"><a href="#链接：https-www-nowcoder-com-ta-huawei-总共-108-道题" class="headerlink" title="链接：https://www.nowcoder.com/ta/huawei 总共 108 道题"></a><a href="https://www.nowcoder.com/ta/huawei">链接：https://www.nowcoder.com/ta/huawei</a> 总共 108 道题</h3><span id="more"></span><ol><li><p>字符串最后一个单词的长度  </p><h3 id="处理输入就好"><a href="#处理输入就好" class="headerlink" title="处理输入就好"></a>处理输入就好</h3></li><li><p>计算字符个数</p><h3 id="处理输入以及字符串处理"><a href="#处理输入以及字符串处理" class="headerlink" title="处理输入以及字符串处理"></a>处理输入以及字符串处理</h3><p> 用到 <em>range for</em> <code>for(auto c : str)</code> 以及大小写的转换 <code>toupper(c)</code> <code>tolower(c)</code></p></li><li><p>明明的随机数  </p><h3 id="去重与排序"><a href="#去重与排序" class="headerlink" title="去重与排序"></a>去重与排序</h3><p> 用到 排序 <code>sort(data.begin(),data.end())</code><br> 去重 <code>auto ite = unique(data.begin(),data.end())</code><br> ite为第一个重复元素的迭代器 <code>unique</code> 实际上并没有删除任何元素，而是将无重复的元素复制到序列的前端<br> 删除指定范围的元素 <code>data.erase(ite,data.end())</code></p></li><li><p>字符串分隔</p><h3 id="基本的字符串处理-注意边界条件"><a href="#基本的字符串处理-注意边界条件" class="headerlink" title="基本的字符串处理 注意边界条件"></a>基本的字符串处理 注意边界条件</h3></li><li><p>进制转换</p><h3 id="十六进制转十进制-基本的字符串处理-注意处理循环多组数据的输入"><a href="#十六进制转十进制-基本的字符串处理-注意处理循环多组数据的输入" class="headerlink" title="十六进制转十进制 基本的字符串处理 注意处理循环多组数据的输入"></a>十六进制转十进制 基本的字符串处理 注意处理循环多组数据的输入</h3></li><li><p>质数因子</p><h3 id="这里用到一些数学技巧，数学因子-是-将输入数值除以i-i从2开始-，除到无法整除-可以整除就输出然后做除法-后i-，直到除数平方大于等于输入数值"><a href="#这里用到一些数学技巧，数学因子-是-将输入数值除以i-i从2开始-，除到无法整除-可以整除就输出然后做除法-后i-，直到除数平方大于等于输入数值" class="headerlink" title="这里用到一些数学技巧，数学因子 是 将输入数值除以i(i从2开始)，除到无法整除(可以整除就输出然后做除法)后i++，直到除数平方大于等于输入数值"></a>这里用到一些数学技巧，数学因子 是 将输入数值除以i(i从2开始)，除到无法整除(可以整除就输出然后做除法)后i++，直到除数平方大于等于输入数值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i*i &lt; tmp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(tmp1 % i == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp1 /= i;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取近似值</p><h3 id="将原数先乘以10-来分析其小数部分"><a href="#将原数先乘以10-来分析其小数部分" class="headerlink" title="将原数先乘以10 来分析其小数部分"></a>将原数先乘以10 来分析其小数部分</h3></li><li><p>合并表记录</p><h3 id="使用-map-处理索引和值，并将相同索引的值相加"><a href="#使用-map-处理索引和值，并将相同索引的值相加" class="headerlink" title="使用 map 处理索引和值，并将相同索引的值相加"></a>使用 map 处理索引和值，并将相同索引的值相加</h3></li><li><p>提取不重复整数</p><h3 id="提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。"><a href="#提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。" class="headerlink" title="提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。"></a>提取一个整数的每一位数，判断个位是否为0，然后逆序输出，输出时使用flag来去重。</h3></li><li><p>字符个数判断</p><h3 id="简单的字符串处理-也可以用set-insert-来去重"><a href="#简单的字符串处理-也可以用set-insert-来去重" class="headerlink" title="简单的字符串处理 也可以用set.insert() 来去重"></a>简单的字符串处理 也可以用set.insert() 来去重</h3></li><li><p>数字颠倒</p><h3 id="该题要求字符串的形式逆序输出，-因此要用到-to-string-num-来将数字变为字符串"><a href="#该题要求字符串的形式逆序输出，-因此要用到-to-string-num-来将数字变为字符串" class="headerlink" title="该题要求字符串的形式逆序输出， 因此要用到 to_string(num) 来将数字变为字符串"></a>该题要求字符串的形式逆序输出， 因此要用到 <code>to_string(num)</code> 来将数字变为字符串</h3></li><li><p>字符串反转</p><h3 id="简单的字符串反转"><a href="#简单的字符串反转" class="headerlink" title="简单的字符串反转"></a>简单的字符串反转</h3></li><li><p>句子逆序</p><h3 id="简单的-vector-与-string-的联合使用"><a href="#简单的-vector-与-string-的联合使用" class="headerlink" title="简单的 vector 与 string 的联合使用"></a>简单的 vector 与 string 的联合使用</h3></li><li><p>字串的连接最长路径查找</p><h3 id="对n个字符串按照字典序排列-直接使用-vector-加上-sort"><a href="#对n个字符串按照字典序排列-直接使用-vector-加上-sort" class="headerlink" title="对n个字符串按照字典序排列 直接使用 vector 加上 sort"></a>对n个字符串按照字典序排列 直接使用 vector<string> 加上 sort</h3></li><li><p>求int 型正整数在内存中存储时1的个数</p><h3 id="即求这个数转换成2进制后，输出1的个数-通过移位来解决"><a href="#即求这个数转换成2进制后，输出1的个数-通过移位来解决" class="headerlink" title="即求这个数转换成2进制后，输出1的个数 通过移位来解决"></a>即求这个数转换成2进制后，输出1的个数 通过移位来解决</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">num</span> &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    count += <span class="built_in">num</span> &amp; <span class="number">0x01</span>;</span><br><span class="line">    <span class="built_in">num</span> = <span class="built_in">num</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>购物单</p><h3 id="典型的分组背包问题。具体参考-背包问题"><a href="#典型的分组背包问题。具体参考-背包问题" class="headerlink" title="典型的分组背包问题。具体参考 背包问题"></a>典型的分组背包问题。具体参考 <a href="http://kangqingfei.cn/2018/01/06/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></h3></li><li><p>坐标移动</p><h3 id="主要是处理输入与输出"><a href="#主要是处理输入与输出" class="headerlink" title="主要是处理输入与输出"></a>主要是处理输入与输出</h3><p>判断是否是数字:<code>isdigit(str[i])</code><br>指定输入的分割符的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">string strt,str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; strt)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="function">istringstream <span class="title">iss</span><span class="params">(strt)</span></span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">getline</span>(iss, str, <span class="string">&#x27;;&#x27;</span>)) <span class="comment">// 以`;`分割来输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指定个数的数字字符转为数字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string strTmp;</span><br><span class="line">strTmp.<span class="built_in">append</span>(str,<span class="number">1</span>,str.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">step = <span class="built_in">stoi</span>(strTmp);</span><br></pre></td></tr></table></figure></li><li><p>识别有效IP地址和掩码并进行分类统计</p><h3 id="字符串处理-主要用到-atoi-str-c-str"><a href="#字符串处理-主要用到-atoi-str-c-str" class="headerlink" title="字符串处理 主要用到 atoi(str.c_str())"></a>字符串处理 主要用到 <code>atoi(str.c_str())</code></h3><p>有个坑就是 有的ip 啥都不是， 比如 127.0.0.1&#x2F;8<br>还有一个坑就是 255.255.255.255 这个掩码是错误的<br>实现了一个string 的 split</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string &amp;str, <span class="type">char</span> sep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">sstr</span><span class="params">(str)</span></span>;</span><br><span class="line">    vector&lt;string&gt; re;</span><br><span class="line">    string tmp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(sstr,tmp,sep))</span><br><span class="line">        re.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单错误记录</p><h3 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>用到 <code>string.rfind()</code> 反向查找，返回第一个下标的位置<br><code>string.find()</code> 正向查找，返回第一个找到字符的下标<br>还有一个有趣的结构体构造的代码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct ErrRecord&#123;</span><br><span class="line">    string <span class="keyword">file</span>;</span><br><span class="line">    <span class="keyword">int</span> lineNo;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">    ErrRecord(string <span class="keyword">file</span>, <span class="keyword">int</span> lineNo)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;lineNo = lineNo;</span><br><span class="line">        <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool operator==(const ErrRecord &amp; a)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">file</span> == a.<span class="keyword">file</span>) &amp;&amp; (lineNo == a.lineNo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后利用 <code>ErrRecord record(getFileName(file), lineNo);</code>进行初始化</p></li><li><p>密码验证合格程序</p><h3 id="字符串处理-1"><a href="#字符串处理-1" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>主要难点在 <code>不能有相同长度超2的子串重复</code> 这里涉及一个重复字串的处理 使用的是暴力穷举，但是能AC</p></li><li><p>简单密码</p><h3 id="字符串处理-2"><a href="#字符串处理-2" class="headerlink" title="字符串处理"></a>字符串处理</h3><p>简单的字符串处理，注意多值case语句的使用方法。以及 <code>Z</code> 后移一位是 <code>a</code>。</p></li><li><p>汽水瓶</p><h3 id="简单的数值处理题"><a href="#简单的数值处理题" class="headerlink" title="简单的数值处理题"></a>简单的数值处理题</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;<span class="built_in">num</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">int</span> remainder = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">num</span>/<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count += <span class="built_in">num</span>/<span class="number">3</span>;</span><br><span class="line">        remainder = <span class="built_in">num</span>%<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">num</span> = <span class="built_in">num</span>/<span class="number">3</span> + remainder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">num</span> == <span class="number">2</span>)</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除字符串中出现最少的字符</p><h3 id="简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。"><a href="#简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。" class="headerlink" title="简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。"></a>简单的字符串处理，可以通过map统计出现次数后取最小次数的然后删除。</h3><p>注意 列表初始化： <code>int flag[3] = &#123;0&#125;</code> &#x3D;&gt; [0 0 0] <code>int flag[3] = &#123;1&#125;</code> &#x3D;&gt; [1 0 0]</p></li><li><p>合唱队</p><h3 id="LIS-的变种-具体参考-最长递增子序列-LIS"><a href="#LIS-的变种-具体参考-最长递增子序列-LIS" class="headerlink" title="LIS 的变种 具体参考 最长递增子序列-LIS"></a>LIS 的变种 具体参考 <a href="http://kangqingfei.cn/2018/01/22/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-LIS/">最长递增子序列-LIS</a></h3></li><li><p>数据分类处理</p><h3 id="简单的字符串处理-貌似没有时间的要求-或者时间要求很宽裕，但是有多个case-输入的要求"><a href="#简单的字符串处理-貌似没有时间的要求-或者时间要求很宽裕，但是有多个case-输入的要求" class="headerlink" title="简单的字符串处理 貌似没有时间的要求 或者时间要求很宽裕，但是有多个case 输入的要求"></a>简单的字符串处理 貌似没有时间的要求 或者时间要求很宽裕，但是有多个case 输入的要求</h3><p>用到string的几个函数 <code>to_string( int ).find( string ) != string::npos</code></p></li><li><p>字符串排序</p><h3 id="简单的字符串处理"><a href="#简单的字符串处理" class="headerlink" title="简单的字符串处理"></a>简单的字符串处理</h3></li><li><p>查找兄弟单词</p><h3 id="简单字符串处理"><a href="#简单字符串处理" class="headerlink" title="简单字符串处理"></a>简单字符串处理</h3><p>注意判断是否是兄弟单词的做法是使用排序后的字符串进行比较看是否相等，其次输出很坑的是换行，而且当k大于兄弟单词的总数时只输出兄弟单词的总数</p></li><li><p>素数伴侣</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;华为机试题汇总，对于一些比较复杂的题目会单独分析&quot;&gt;&lt;a href=&quot;#华为机试题汇总，对于一些比较复杂的题目会单独分析&quot; class=&quot;headerlink&quot; title=&quot;华为机试题汇总，对于一些比较复杂的题目会单独分析&quot;&gt;&lt;/a&gt;华为机试题汇总，对于一些比较复杂的题目会单独分析&lt;/h2&gt;&lt;h3 id=&quot;链接：https-www-nowcoder-com-ta-huawei-总共-108-道题&quot;&gt;&lt;a href=&quot;#链接：https-www-nowcoder-com-ta-huawei-总共-108-道题&quot; class=&quot;headerlink&quot; title=&quot;链接：https://www.nowcoder.com/ta/huawei 总共 108 道题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/huawei&quot;&gt;链接：https://www.nowcoder.com/ta/huawei&lt;/a&gt; 总共 108 道题&lt;/h3&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="汇总" scheme="http://kangqingfei.cn/tags/%E6%B1%87%E6%80%BB/"/>
    
  </entry>
  
  <entry>
    <title>很久没更新了</title>
    <link href="http://kangqingfei.cn/2018/01/03/%E5%BE%88%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86/"/>
    <id>http://kangqingfei.cn/2018/01/03/%E5%BE%88%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E4%BA%86/</id>
    <published>2018-01-03T02:02:55.000Z</published>
    <updated>2022-09-14T18:03:38.040Z</updated>
    
    <content type="html"><![CDATA[<h3 id="荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。"><a href="#荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。" class="headerlink" title="荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。"></a>荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。</h3><p>话说自从上了研究生就没有更博了，因为自己累，心累！</p><p>接下来，我将会更新一系列的笔试面试题，以求在2018的招聘中能有好运。</p><p>苦心人，人不负。</p><p>这是开博的初衷。</p><p>有志者，事竟成。</p><p>这是开博的目标。</p><span id="more"></span><p>网上已经有很多博客有过相关的笔试面试经验，每一个博客都见证了一个人的成长。这里将会列举一些自己曾经参考过的博客，可能这里会有很多与之前重复的地方，因为，<code>纸上得来终觉浅，绝知此事要躬行</code>。</p><ol><li><a href="http://blog.csdn.net/za30312/article/category/6312648">蓝桥杯</a></li><li><a href="http://blog.csdn.net/u013616945">Rock N Roll</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&quot;&gt;&lt;a href=&quot;#荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&quot; class=&quot;headerlink&quot; title=&quot;荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&quot;&gt;&lt;/a&gt;荒废了一年多没有更博，其实写了很多pdf，后面有机会可以拿出来。&lt;/h3&gt;&lt;p&gt;话说自从上了研究生就没有更博了，因为自己累，心累！&lt;/p&gt;
&lt;p&gt;接下来，我将会更新一系列的笔试面试题，以求在2018的招聘中能有好运。&lt;/p&gt;
&lt;p&gt;苦心人，人不负。&lt;/p&gt;
&lt;p&gt;这是开博的初衷。&lt;/p&gt;
&lt;p&gt;有志者，事竟成。&lt;/p&gt;
&lt;p&gt;这是开博的目标。&lt;/p&gt;</summary>
    
    
    
    <category term="jobs" scheme="http://kangqingfei.cn/categories/jobs/"/>
    
    
    <category term="job" scheme="http://kangqingfei.cn/tags/job/"/>
    
    <category term="blog" scheme="http://kangqingfei.cn/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Makefile 与 make</title>
    <link href="http://kangqingfei.cn/2016/10/23/Makefile-%E4%B8%8E-make/"/>
    <id>http://kangqingfei.cn/2016/10/23/Makefile-%E4%B8%8E-make/</id>
    <published>2016-10-23T11:26:03.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h2><p>Makefile 是一种类似于脚本的，能够自动化执行程序的编译链接工作(甚至命令的执行 py latex 等命令)，从而省去了人工在命令行里输入指令的繁琐过程(并且在vim下对Makefile有着极好的支持)。而make指令(在win是cmake，linux下是gmake)可以自动搜索路径下的Makefile文件，并根据文件内容进行指令的执行，所以Makefile可以看做是一个工程的配置文件，只不过这个工程是用make打开编译。虽然Makefile给我们的程序的编译链接工作省去了很多繁琐的工作，但是偷懒的程序员依然觉得编写Makefile也是一件很是繁琐的工作，因此就诞生了诸多款的make工具用来根据程序员的一些设定自动生成能够执行的Makefile文件，从未又一定程度上减少了编写Makefile文件的重复工作量。这些工具有：</p><span id="more"></span><ul><li><p>cmake cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，比如你可用math表示数学库，而不需要再具体指定到底是math.dll还是libmath.so，在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个IDE定制工程文件。cmake命令执行的CMakeLists.txt文件 参考 <a href="https://www.zhihu.com/question/27455963/answer/36722992">来源：知乎</a></p></li><li><p>qmake qmake工具就是Qt公司制造出来，用来生成Qt 专用makefile文件，这种makefile文件就能自动智能调用moc和uic对源程序进行预处理和编译。qmake当然必须也是跨平台的，跟cmake一样能对应各种平台生成对应makefile文件。qmake是根据Qt 工程文件（.pro）来生成对应的makefile的。工程文件（.pro）相对来说比较简单，一般工程你都可以自己手写，但是一般都是由Qt的开发环境 Qt Creator自动生成的，你还是只需要按下那个邪恶三角形就完事了。还没有完，由于qmake很简单很好用又支持跨平台，而且是可以独立于它的IDE，所以你也可以用在非Qt工程上面，照样可以生成普通的makefile，只要在pro文件中加入CONFIG -&#x3D; qt 就可以了。 参考<a href="https://www.zhihu.com/question/27455963/answer/89770919">辉常哥</a></p></li></ul><h2 id="Makefile-语法"><a href="#Makefile-语法" class="headerlink" title="Makefile 语法"></a>Makefile 语法</h2><h2 id="cmake-语法"><a href="#cmake-语法" class="headerlink" title="cmake 语法"></a>cmake 语法</h2><h2 id="qmake-语法"><a href="#qmake-语法" class="headerlink" title="qmake 语法"></a>qmake 语法</h2> <script type="text/javascript" src="https://asciinema.org/a/50301.js" id="asciicast-50301" async></script><h2 id="使用make进行程序的编译"><a href="#使用make进行程序的编译" class="headerlink" title="使用make进行程序的编译"></a>使用make进行程序的编译</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Makefile介绍&quot;&gt;&lt;a href=&quot;#Makefile介绍&quot; class=&quot;headerlink&quot; title=&quot;Makefile介绍&quot;&gt;&lt;/a&gt;Makefile介绍&lt;/h2&gt;&lt;p&gt;Makefile 是一种类似于脚本的，能够自动化执行程序的编译链接工作(甚至命令的执行 py latex 等命令)，从而省去了人工在命令行里输入指令的繁琐过程(并且在vim下对Makefile有着极好的支持)。而make指令(在win是cmake，linux下是gmake)可以自动搜索路径下的Makefile文件，并根据文件内容进行指令的执行，所以Makefile可以看做是一个工程的配置文件，只不过这个工程是用make打开编译。虽然Makefile给我们的程序的编译链接工作省去了很多繁琐的工作，但是偷懒的程序员依然觉得编写Makefile也是一件很是繁琐的工作，因此就诞生了诸多款的make工具用来根据程序员的一些设定自动生成能够执行的Makefile文件，从未又一定程度上减少了编写Makefile文件的重复工作量。这些工具有：&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="Makefile" scheme="http://kangqingfei.cn/tags/Makefile/"/>
    
    <category term="make" scheme="http://kangqingfei.cn/tags/make/"/>
    
  </entry>
  
  <entry>
    <title>GCC/G++ 与 GDB</title>
    <link href="http://kangqingfei.cn/2016/10/23/GCC-G-%E4%B8%8E-GDB/"/>
    <id>http://kangqingfei.cn/2016/10/23/GCC-G-%E4%B8%8E-GDB/</id>
    <published>2016-10-23T11:25:36.000Z</published>
    <updated>2022-09-14T18:03:38.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从hello-world说起"><a href="#从hello-world说起" class="headerlink" title="从hello world说起"></a>从hello world说起</h2><ol><li>首先我们有一段 hello world 程序<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  retunr <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span></li><li>我们通过以下步骤编译程序：</li></ol><ul><li>g++ hello.cpp<br>这会生成一个<code>a.out</code>的文件，这个名字是由于历史原因导致的，所以不管源文件的名字是啥，生成的可执行文件的文件名都是一样的。</li></ul><ol start="3"><li>首先，认识一下文件的后缀</li></ol><ul><li><code>.c</code> c语言的源文件</li><li><code>.cpp .C .cc .cxx</code> c++ 语言的源文件</li><li><code>.i</code> 经过预处理的c 文件</li><li><code>.ii</code> 经过处理后的c++ 文件</li><li><code>.s</code> 汇编代码源文件</li><li><code>.S</code> 经过预处理的汇编代码文件</li><li><code>.h</code> 头文件</li><li><code>.o</code> 编译后的目标文件</li><li><code>.so</code> 动态链接库文件 在Win下是 <code>.dll</code></li><li><code>.a</code> 静态链接库文件 在Win下是  <code>.lib</code></li></ul><ol start="4"><li>gcc 常用的命令</li></ol><ul><li>一般格式： <code>gcc [-option] srcfile [-option] desfile</code></li><li>g++ -E hello.cpp -o hello.ii 只进行预处理，得到预处理后的文件</li><li>g++ -S hello.cpp -o hello.s 生成到汇编代码后停止，得到汇编文件。</li><li>g++ -c hello.cpp -o hello.o 编译到最后的二进制代码，但不进行链接，得到目标文件。</li><li>g++ -g hello.cpp -o ghello 生成包含调试信息的可执行文件，可以通过<code>strip ghello</code> 删除文件中的debug信息。</li><li>g++ -O hello.cpp 对代码进行自动优化编译，O后面可以接数字，比如可以使用 <code>-O3</code>进行三级优化编译</li><li>g++ -W hello.cpp 编译中开启一些额外的警告信息，<code>-Wall</code>表示把所有的警告信息全部打开</li><li>g++ hello.cpp -I&#x2F;path&#x2F;to&#x2F;include -L&#x2F;path&#x2F;to&#x2F;lib -lnameoflib 分别表示添加包含文件的搜索路径，链接文件的搜索路径以及指定要使用的链接库的名字</li></ul><ol start="5"><li>链接库的生成，首先要介绍一些基本的规则</li></ol><ul><li>动态库一律是以 lib 开头，制定链接库名字的时候可以省去lib三个字母。</li><li>由于动态库节省空间，所以默认链接动态库，可就是说如果有两个同名的动态库和静态库，那么linux会优先选择动态库链接，如果要特别告诉编译器与重名的那个静态库链接，则主要加上<code>-static</code>或<code>-WI,-Bstatic</code>选项,如果既要链接动态库又要链接静态库，则需使用<code>-WI,-Bstatic -lnameofstaticlib -WI,-Bdynamic -lnameofdynamiclib</code></li><li>为了让程序使用自己创建的动态库有三种方法<ul><li>将自己的库拷到 &#x2F;usr&#x2F;lib或&#x2F;lib 等已经存在于环境变量中的动态库搜索路径中</li><li>修改环境变量 <code>export LD_LIBRARY_PATH</code>&#x3D;$LD_LIBRARY_PATH:&#x2F;new&#x2F;lib&#x2F;path</li><li>修改 &#x2F;etc&#x2F;ld.so.conf ,把库的路径加到末尾，然后执行 ldconfig 刷新。</li></ul></li><li>nm libname.so 查看库中有哪些函数，如果库中没有自己想要找的库，则可以使用 ldd libname.so 来看看它依赖的其他库，在其他库中说不定可以找到哦</li><li>到达</li></ul><ol start="6"><li>生成库文件</li></ol><ul><li>ar cqs libname.a name.o</li><li>ar cr libnamme.a name.o</li><li>g++ -shared -W1,-soname,libname.so.1 -o libname.so.1.0 hello.o</li><li>g++ -shared -fPCI -o libname.so name.o</li><li>其中soname 是库区分的标志，这就像库的身份证，通常的做法就是将库的soname与库的顶级版本号的保持一致，然后将低级版本到软连接到一个与soname同名的链接文件。</li></ul><h2 id="使用GDB调试程序"><a href="#使用GDB调试程序" class="headerlink" title="使用GDB调试程序"></a>使用GDB调试程序</h2><ol><li>使用 gdb test 来启动调试。</li><li>一些常用的命令</li></ol><ul><li>r(run) pram1 parm2 运行</li><li>l(list) start,end 显示指定行数的代码</li><li>p(print) var(fun) 打印变量的值，或是打印函数调用的值</li><li>whatis 查看变量的类型</li><li>b(break) [行号，函数名]  在指定位置设置断点</li><li>tbreak 设置临时断点，触发后自动删除</li><li>info b 查看所有的断点</li><li>d(delete) 删除断点</li><li>set pram&#x3D;val 设置变量的值</li><li>c(continue) 继续执行直到遇到新的断点</li><li>n(next) 不进入的单步调试</li><li>s(step) 进入的单步调试</li><li>finish 执行完当前函数</li><li>q(quit) 退出调试</li><li>h(help) command 查看指定命令的用法</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;从hello-world说起&quot;&gt;&lt;a href=&quot;#从hello-world说起&quot; class=&quot;headerlink&quot; title=&quot;从hello world说起&quot;&gt;&lt;/a&gt;从hello world说起&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先我们有一段 hello world 程序&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; std;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  retunr &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="tools" scheme="http://kangqingfei.cn/categories/tools/"/>
    
    
    <category term="linux" scheme="http://kangqingfei.cn/tags/linux/"/>
    
    <category term="gcc" scheme="http://kangqingfei.cn/tags/gcc/"/>
    
    <category term="g++" scheme="http://kangqingfei.cn/tags/g/"/>
    
    <category term="gdb" scheme="http://kangqingfei.cn/tags/gdb/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://kangqingfei.cn/2016/10/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://kangqingfei.cn/2016/10/07/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2016-10-07T02:20:27.000Z</published>
    <updated>2022-09-14T18:03:38.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重新复习一遍常用的排序算法"><a href="#重新复习一遍常用的排序算法" class="headerlink" title="重新复习一遍常用的排序算法"></a>重新复习一遍常用的排序算法</h2><ol><li>冒泡排序</li></ol><ul><li>顾名思义就是将相邻的两个数比较，不满足大小关系就交换顺序，将最大或最小的数像泡泡一样冒到最右或最左端</li></ul><ol start="2"><li>选择排序</li></ol><ul><li>找到一个最大或最小值，然后将其和最右或最左端的数交换</li></ul><ol start="3"><li>直接插入排序</li></ol><ul><li>首先取出序列的第一个数，假设它已经排好序，然后从第二个数开始将其插入到第一个数前面或后面</li><li>然后将序列长度增加</li><li>现在前面的序列已经排好序了，然后先取出没排好序的第一个值，将其与前面的序列相比较，如果比要插入的值大就把排好序的值依次往后挪一个，以空出一个空位让要插入的值占着。直到找到那个排好序的序列中比要插入的值小或相等的值，则要放置的位置就确定了，然后放入要插入的值，再将排好序的序列的长度增加，开始下一轮循环。</li><li>简言之就是在已排序的序列中从后往前扫描，找到相应位置并插入<span id="more"></span></li></ul><ol start="4"><li>二分插入排序</li></ol><ul><li>如果在寻找插入值的过程中使用二分查找就是<code>二分查找排序/二分（折半）插入排序</code>这样仅仅只是减小了比较操作的数量，并没有减小挪位操作的数量</li></ul><ol start="5"><li>快速排序</li></ol><ul><li><p>核心思想：</p><ol><li>确定一个 缘分值 的位置 ，使得该值的左边全部比它小，右边全部比它大，但是左右依然可能是无序的。</li><li>对左右两边递归调用快排算法，递归结束条件是需要排序的序列的长度是一，即left &gt;&#x3D; right</li></ol></li><li><p>主干部分，缘分值的确定</p><ol><li>首先将最左边的值确定为缘分值，然后通过循环从两边向中间靠拢求得缘分值的合适的位置。</li><li>循环的结束条件，左侧值和右侧值为同一值，则找到该 缘分值 的恰当位置，跳出循环。</li><li>循环体<ol><li>找到右侧比当前 缘分值 小的值</li><li>将该值换到左侧（当前缘分值移到了右侧），然后将左边界右移一位</li><li>找到左侧比当前缘分值大的值</li><li>将该值换到右侧，则缘分值回到左侧起点的位置，开始下一轮循环</li></ol></li></ol></li><li><p>细节：</p><ol start="3"><li>循环主要就是要找到 缘分值（在最左侧的那个值）的正确位置（下标），保证左侧的比它小，右侧的比它大。</li><li>循环结束之前，该缘分值一直保存在临时变量之中，而在排序的序列中一定是会有一个重复值（要么是i指向的那个值，要么是j指向的那个值）</li><li>在左右两边的变量互换之后应该判断 左右下标是否相等，如果相等则不用移动左右下标（否则会出错）。</li><li>在循环结束之前记得将原来放在临时变量中的值放回到序列之中，从而剔除序列中的重复值</li></ol></li></ul><ol start="6"><li>排序</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;重新复习一遍常用的排序算法&quot;&gt;&lt;a href=&quot;#重新复习一遍常用的排序算法&quot; class=&quot;headerlink&quot; title=&quot;重新复习一遍常用的排序算法&quot;&gt;&lt;/a&gt;重新复习一遍常用的排序算法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;冒泡排序&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;顾名思义就是将相邻的两个数比较，不满足大小关系就交换顺序，将最大或最小的数像泡泡一样冒到最右或最左端&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;选择排序&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;找到一个最大或最小值，然后将其和最右或最左端的数交换&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;直接插入排序&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;首先取出序列的第一个数，假设它已经排好序，然后从第二个数开始将其插入到第一个数前面或后面&lt;/li&gt;
&lt;li&gt;然后将序列长度增加&lt;/li&gt;
&lt;li&gt;现在前面的序列已经排好序了，然后先取出没排好序的第一个值，将其与前面的序列相比较，如果比要插入的值大就把排好序的值依次往后挪一个，以空出一个空位让要插入的值占着。直到找到那个排好序的序列中比要插入的值小或相等的值，则要放置的位置就确定了，然后放入要插入的值，再将排好序的序列的长度增加，开始下一轮循环。&lt;/li&gt;
&lt;li&gt;简言之就是在已排序的序列中从后往前扫描，找到相应位置并插入</summary>
    
    
    
    <category term="ACM" scheme="http://kangqingfei.cn/categories/ACM/"/>
    
    
    <category term="sort" scheme="http://kangqingfei.cn/tags/sort/"/>
    
    <category term="ACM" scheme="http://kangqingfei.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>cplusplus notes</title>
    <link href="http://kangqingfei.cn/2016/09/22/cplusplus-notes/"/>
    <id>http://kangqingfei.cn/2016/09/22/cplusplus-notes/</id>
    <published>2016-09-22T08:30:54.000Z</published>
    <updated>2022-09-14T18:03:38.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一些关于C-的笔记"><a href="#一些关于C-的笔记" class="headerlink" title="一些关于C++的笔记"></a>一些关于C++的笔记</h2><ol><li><p>Lambdas 表达式</p></li><li><p><code>尾置返回类型</code>-一般用于返回类型比较复杂和难理解（例如 数组的指针或是数组的引用）的函数中来声明返回类型。<br>* 尾置返回类型的一般格式为：<code>auto fun(parameter list) -&gt; trailing type</code><br>* 返回类型跟在形参列表的后面，并且以一个<code>-&gt;</code> 符号开头。<br>* 为了表示真正的返回类型跟在形参列表之后，在本该出现返回类型的地方放置一个<code>auto</code>。<br>* 实例：申明一个返回指向一个维度为10的int数组的指针</p><ul><li>原生的方式： <code>int (*function(int i))[10]</code></li><li>使用尾置返回： <code>auto function(int i) -&gt; int (*)[10]</code></li><li>使用类型别名： <code>typedef int arrT[10]</code> or <code>using arrT = int[10]</code> then <code>arrT* function(int i)</code></li><li>使用<code>decltype</code>：首先<code>int arr[] = &#123;1,2,3,4&#125;</code> then <code>decltype(arr) *function(int i)</code><span id="more"></span></li></ul></li><li><p><code>调用运算符</code>-调用运算符是一对圆括号，里面放置实参列表。</p></li><li><p><code>可调用的(对象/表达式)</code>-我们可以对一个(对象&#x2F;表达式)使用调用运算符，则称这样的对象或表达式是可调用的。</p></li><li><p>四种可调用的对象- <code>函数</code> <code>函数指针</code> <code>重载了函数调用运算符的类</code> <code>Lambda表达式</code></p></li><li><p>lambda expression represent a callable unit of code. It can be thought of as unnamed,inline function, but may be defined inside a function.</p></li><li><p>A lambda expression has the form : <code>[capture list](parameter list) -&gt; return type &#123; function body &#125; </code><br>* capture list 称为捕获列表，是在enclosing function 中的局部变量.<br>* lambda 必须使用的是尾置返回(trailing return)来指定它的返回类型.<br>* 可以忽略参数列表和返回类型，但是必须包含函数体和捕获列表:<code>auto f = [] &#123; return 0;&#125;</code></p></li><li><p>向lambda传递参数及使用捕获列表。<br>1. lambda不能含有默认参数，因此lambda的形参的个数和实参的个数一定是一样的。<br>2. 空的捕获列表表明lambda表达式不使用它所在函数中的任何局部变量。<br>3. lambda 表达式可以使用定义在当前函数之外的名字 比如 cout.<br>4. 捕获列表只适用于局部的非静态变量，它可以直接使用局部的静态变量和在函数外部的名字.</p></li><li><p>lambda 捕获和返回<br>1. 定义一个lambda 表达式的时候，编译器会生成一个与lambda对应的未命名的类类型。<br>2. 变量的捕获方式可以是值或是引用。如果使用的是值捕获前提是采用值捕获的变量可以被复制。<br>3. 与参数的传递不同，被捕获的变量的值是在lambda创建的时候发生拷贝，而不是在调用的时候发生拷贝的。因此对捕获的变量的后续的修改将不会影响到lambda里面对应的值。<br>4. 使用引用捕获必须确定被引用的对象在lambda执行的时候是存在的。<br>5. 引用值捕获在有的时候显得十分必要，比如我们需要使用输出流，因为ostream是不能复制的，所以唯一的方式就是使用引用捕获（或指针）。<br>6. 我们可以返回lambda表达式，但是不能返回局部变量的引用，也就是说lambda不能包含引用捕获。<br>7. 隐式捕获，就是不显式地指明我们需要捕获的变量而是在捕获列表里使用<code>&amp;</code>或<code>=</code>。其中<code>&amp;</code>表示要使用引用捕获，而<code>=</code>表示要使用值捕获。如果我们混合使用显式捕获和隐式捕获，那么捕获列表的第一项必须是<code>&amp;</code>或<code>=</code>。<br>8. 如果混合使用显式捕获和隐式捕获，那么如果隐式捕获使用的是引用模式那么显式捕获只能使用值捕获模式（如果使用引用直接用就行不用再次声明），反之亦然。</p></li><li><p>可变的lambda.<br>1. 一般情况下lambda不会改变使用值捕获的变量的值，如果我们想改变这个值，那么我们必须在参数列表后面跟上关键词<code>mutable</code><br>2. 一个引用变量能否修改，取决于引用指向的是一个const类型变量还是一个非const类型的变量。</p></li><li><p>指定lambda的返回类型.<br>1. 如果一个lambda表达式的函数体包含return之外的任何语句，则编译器假定此lambda返回void，被推断返回void的lambda不能返回值。<br>2. 如果想在函数体中使用除了return之外的其他语句，并且还要返回非void的值，则要使用尾置返回来指定返回的类型。</p></li><li><p>参数绑定<br>1. 若果一个lambda的捕获列表为空则我们可以使用一个函数来代替它。<br>2. 对于一个捕获局部变量的lambda，我们可以使用<code>bind</code>-定义在<code>functional</code>中，这个标准库函数。它接收一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。<br>3. bind 调用的一般形式是 <code>suto newCallable = bind(callable, arg_list)</code>arg_list中包含_n（<code>_1 _2 _3</code>）之类的占位符。来表示这是第几个参数。<br>4. 绑定引用参数。如果我们希望传递给bind一个对象而又不拷贝它，就必须使用ref函数。ref返回一个对象，包含给定的引用，此对象是可以拷贝的。另外还有一个cref函数，生成一个保存const引用的类。</p></li><li><p>作用域和命名空间</p></li><li><p>第三方</p></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://imzlp.me/2016/05/12/cpp11-new-features/">C++11的语法糖</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一些关于C-的笔记&quot;&gt;&lt;a href=&quot;#一些关于C-的笔记&quot; class=&quot;headerlink&quot; title=&quot;一些关于C++的笔记&quot;&gt;&lt;/a&gt;一些关于C++的笔记&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Lambdas 表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;尾置返回类型&lt;/code&gt;-一般用于返回类型比较复杂和难理解（例如 数组的指针或是数组的引用）的函数中来声明返回类型。&lt;br&gt;* 尾置返回类型的一般格式为：&lt;code&gt;auto fun(parameter list) -&amp;gt; trailing type&lt;/code&gt;&lt;br&gt;* 返回类型跟在形参列表的后面，并且以一个&lt;code&gt;-&amp;gt;&lt;/code&gt; 符号开头。&lt;br&gt;* 为了表示真正的返回类型跟在形参列表之后，在本该出现返回类型的地方放置一个&lt;code&gt;auto&lt;/code&gt;。&lt;br&gt;* 实例：申明一个返回指向一个维度为10的int数组的指针&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原生的方式： &lt;code&gt;int (*function(int i))[10]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用尾置返回： &lt;code&gt;auto function(int i) -&amp;gt; int (*)[10]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用类型别名： &lt;code&gt;typedef int arrT[10]&lt;/code&gt; or &lt;code&gt;using arrT = int[10]&lt;/code&gt; then &lt;code&gt;arrT* function(int i)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;decltype&lt;/code&gt;：首先&lt;code&gt;int arr[] = &amp;#123;1,2,3,4&amp;#125;&lt;/code&gt; then &lt;code&gt;decltype(arr) *function(int i)&lt;/code&gt;</summary>
    
    
    
    <category term="notes" scheme="http://kangqingfei.cn/categories/notes/"/>
    
    
    <category term="cplusplus" scheme="http://kangqingfei.cn/tags/cplusplus/"/>
    
  </entry>
  
  <entry>
    <title>优雅地使用Kindle</title>
    <link href="http://kangqingfei.cn/2016/08/31/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Kindle/"/>
    <id>http://kangqingfei.cn/2016/08/31/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Kindle/</id>
    <published>2016-08-31T12:39:22.000Z</published>
    <updated>2022-09-14T18:03:38.041Z</updated>
    
    <content type="html"><![CDATA[<p>嗯，在纠结了很久之后还是剁手了，包括机械键盘和kindle，现在还差一个显示器和一个ssd，加油吧，尽早把它们买回来。在此之前我要插播一个小广告-当然是给Kindle做广告。嗯，在我选择kindle之前，我做了很多的工作，因为很早之前就种了一棵kindle的草，然后前些时间我拿了同学的kpw2 看了看英文原版的电子书，感觉效果很是不错，然后我就下狠心要买一个电纸书，然后我要选择kindle的版本所以问了很多的同学有的使用的是 oasis，有的是 kpw，一个偶然的机会看到了一个前辈说到了文石的一款机器，之后逛了贴吧和淘宝感觉这个评价不是很高，但是我看那个前辈极力推荐这款设备而且又看了他的资料感觉应该可能靠谱，又鉴于文石的机器支持自定义剪裁，而且价格很是可以，顿时就对文石的机器产生了好感，很不幸的下单了一个文石的机器，机器到手后一个小时候我就毅然决定退掉这款机器，可能是自己的问题老师感觉那个机器的屏幕雾蒙蒙的，然后拿了同学的kpw2对比发现差距太明显了，而且有的时候还会有残影。所以还是退了，但是售后感觉态度还是不错的说，虽然稍微有点恼火。然后我就立马下单了一个 kpw3，希望老天保佑，所以在收货之前先做一把<a href="http://www.zhihu.com/question/27741189">功课</a>，希望能借此有好运气。</p><span id="more"></span><h2 id="论kindle的数据来源。"><a href="#论kindle的数据来源。" class="headerlink" title="论kindle的数据来源。"></a>论kindle的数据来源。</h2><ol><li>最传统的方式，通过usb数据线将书籍导入到kindle的对应的目录下面。</li><li>第二个方式，通过kindle的同步的功能将资源同步到kindle。这是所有其他推送方式的本质方式，不会改变。</li></ol><h2 id="论kindle的同步模式。"><a href="#论kindle的同步模式。" class="headerlink" title="论kindle的同步模式。"></a>论kindle的同步模式。</h2><p>kindle可以使用一个唯一的账号来接收各种邮件，然后把邮件的内容按照一定的方式转换为适合于kindle阅读的格式并存在某个类似于云盘的地方，然后每次类似于kindle的设备（包括安卓的kindle app 或是kindle物理设备）进行同步的时候就会将里面的东西同步到用户的设备中。<br>在这里值得一提的是，只有信任的邮箱发来的指定格式附件的邮件才会被kindle接收然后处理，而不在信任列表里面的邮箱发来的邮件就会被kindle的邮件处理程序抛弃。或是不是指定的格式的邮件也会被kindle的邮件处理程序所丢弃。所以很多推送的服务都会要求把他们家的邮箱放到kindle的信任列表里面，这样他们的推送邮件才会被kindle的邮件处理程序处理而不是被丢弃。</p><h2 id="论kindle的同步账号"><a href="#论kindle的同步账号" class="headerlink" title="论kindle的同步账号"></a>论kindle的同步账号</h2><p>写到这里自己买的kindle已经到了，由于自己的kindle是在amazon.cn买的，也就是国行而不是美版，所以它默认注册到了amazon.cn 上面。然后我遇见了一个很蛋疼的问题，我以前用过Android的kindle app，其中当时登录账号后就默认注册到了amazon.com。直到后来拿到kindle机器我继续输入自己的账户和密码之后才发现原来我的Android device已经注册到了amazon.com。这样就面临了一个困境：</p><ol><li>我的amazon.cn下面挂了两个设备，一个是kindle，一个是安卓设备，而且两个的推送邮箱一定要区别，这样就使得推送邮箱看起来很丑（本来是 <a href="mailto:&#x75;&#115;&#x65;&#x72;&#110;&#97;&#109;&#x65;&#64;&#107;&#105;&#x6e;&#100;&#108;&#101;&#46;&#x63;&#110;">&#x75;&#115;&#x65;&#x72;&#110;&#97;&#109;&#x65;&#64;&#107;&#105;&#x6e;&#100;&#108;&#101;&#46;&#x63;&#110;</a> 现在要分成 <a href="mailto:&#x75;&#115;&#x65;&#x72;&#x6e;&#x61;&#109;&#101;&#x5f;&#x78;&#120;&#x78;&#64;&#107;&#105;&#110;&#100;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x75;&#115;&#x65;&#x72;&#x6e;&#x61;&#109;&#101;&#x5f;&#x78;&#120;&#x78;&#64;&#107;&#105;&#110;&#100;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>）。</li><li>我的安卓设备挂到了两个域名下面，使得 <a href="mailto:&#117;&#115;&#x65;&#x72;&#x6e;&#97;&#109;&#101;&#64;&#x6b;&#x69;&#x6e;&#100;&#x6c;&#x65;&#46;&#x63;&#111;&#109;">&#117;&#115;&#x65;&#x72;&#x6e;&#97;&#109;&#101;&#64;&#x6b;&#x69;&#x6e;&#100;&#x6c;&#x65;&#46;&#x63;&#111;&#109;</a> 的推送邮箱被安卓设备占用，而<a href="mailto:&#117;&#115;&#101;&#114;&#x6e;&#x61;&#x6d;&#101;&#64;&#x6b;&#105;&#x6e;&#100;&#108;&#x65;&#46;&#x63;&#110;">&#117;&#115;&#101;&#114;&#x6e;&#x61;&#x6d;&#101;&#64;&#x6b;&#105;&#x6e;&#100;&#108;&#x65;&#46;&#x63;&#110;</a>的推送邮箱不可用，着就很尴尬了。</li><li>由于主要是要使用一些工具推送到 kindle机器上面阅读而不是安卓设备，然后主要用到的一些pc的工具貌似只认kindle.com的邮箱，因此需要将kindle设备注册到kindle.com下面。</li></ol><p>经过一把搜索发现了一个很好玩的东西，就是amazon.cn 与 amazon.com 貌似用的不是相同账号和密码，因此我们在kindle里面注册的时候可以选择不同的密码。简单来说就是本来我的 亚马逊美国和亚马逊中国的账号和密码用的是同一个，然后我输入相同的账户和密码后，有的设备默认注册到了美国亚马逊（比如安卓app），有的注册到了亚马逊中国（比如我的kindle设备）。为了可控这个貌似随机的过程，就只有将两个地方的密码区别开来。我是这样做的：</p><ol><li>修改亚马逊美国的密码，然后在kindle注销亚马逊的账户。</li><li>在kindle上重新登录kindle的账户，使用新的密码，这样我的kindle机器就注册到了亚马逊美国。</li><li>打开安卓设备上面的kindle app 发现注册信息已经失效，重新输入 亚马逊中国的登录密码，这样我的安卓设备就注册到了亚马逊中国的域名。</li></ol><p>这样就基本上完成了自己的需求，但是这样就会有点蛋疼就是两部分的数据会被搞乱，就是说我原来安卓设备上的数据会同步到kindle上面，而原来kindle上的数据会同步安卓设备上面。</p><h2 id="论rss或链接的推送原理。一般而言，rss的推送主要分为以下几个步骤。"><a href="#论rss或链接的推送原理。一般而言，rss的推送主要分为以下几个步骤。" class="headerlink" title="论rss或链接的推送原理。一般而言，rss的推送主要分为以下几个步骤。"></a>论rss或链接的推送原理。一般而言，rss的推送主要分为以下几个步骤。</h2><ol><li>首先在第三方应用填写你的kindle推送的邮件地址，然后并将第三方应用为你生成的发送推送的邮件地址（或是你自己填写的受信任的邮件地址）添加到kindle的信任列表里面，这样第三方应用就取得了向你的kindle的推送的权利。</li><li>你在第三方应用中添加你的rss或链接地址。这样第三方应用就取得了你的偏好的内容。</li><li>第三方应用从给定的地址获取数据源。</li><li>第三方应用使用自己的文本提取软件提取文本内容。</li><li>清理不必要的html。</li><li>将得到的文本转换成mobi（原生系统）或epub。</li><li>发送邮件到用户的接收资源的kindle地址从而实现推送功能。</li></ol><h2 id="论优雅地使用推送功能。"><a href="#论优雅地使用推送功能。" class="headerlink" title="论优雅地使用推送功能。"></a>论优雅地使用推送功能。</h2><ol><li>PC端的推送功能使用</li><li>使用亚马逊开发的send to kindle 的工具，此款工具非常方便好用，可以直接拖拽到应用内即可，还可以在文件系统中右击然后推送 适合于推送指定格式的文件，但是只支持美国亚马逊的推送账户（<a href="mailto:&#x78;&#120;&#120;&#64;&#x78;&#x78;&#x78;&#x2e;&#107;&#105;&#110;&#100;&#x6c;&#101;&#46;&#99;&#111;&#x6d;">&#x78;&#120;&#120;&#64;&#x78;&#x78;&#x78;&#x2e;&#107;&#105;&#110;&#100;&#x6c;&#101;&#46;&#99;&#111;&#x6d;</a>）。</li><li>在chrome中使用插件send to kindle ，也是很方便，适合于推送链接，也是只能使用美国亚马逊的推送账户。但是很遗憾自己一开始一直没能用起，有小伙伴反映只要将chrome的语言选项改成<code>英文（美国）</code>后重启chrome就可以了，经测试这样确实是可以的。只要在设置的时候登录自己的美国亚马逊的账户就可以直接推送了而不需要添加信任邮箱列表。</li><li>还有一款值得一提的稍后阅读的推送工具 instapaper。这款工具的好处就是它可以保存你想阅读的页面但是不会立即推送到你的kindle而是可以设置一定的周期去推送比如说一天一次，这样就可以减少kindle中文件的数目，因为这个应用将几个甚至几十个的页面做成了一期电子书，然后再推送一期电子书到你的kindle。</li><li>移动端的推送功能。</li><li>微信的推送。这里自己用到的主要就是微信的推送功能，因为移动端主要就是推送一些链接或是图片，所以就只用一个微信的公众号推送就可以了。这里要说的是不要使用那些收费的公众号，一开始自己不明真相就弄了一个免费一个月几次的，太不爽了。直接使用亚马逊官方的微信公众号就可以很方便地使用了。只要绑定自己的账户然后添加一下信任邮箱列表，然后就可以愉快地推送了。</li><li>安卓上面好像还有一款推送的app叫做send to kindle ，因为自己没有这个使用的需求，所以就没有安装。值得一提的是，如果你使用的是kindle app的话默认会内置一个send to kindle 不过那个东西不可以跨域貌似，就是说，只能推送到和安卓设备注册地址一样域名的推送邮箱上面，比如我的kindle注册在了美国亚马逊，然后安卓设备注册在了中国亚马逊，所以就不能通过kindle app 内置的send to kindle来推送东西到我的kindle。</li></ol><h2 id="论优雅地阅读rss订阅源"><a href="#论优雅地阅读rss订阅源" class="headerlink" title="论优雅地阅读rss订阅源"></a>论优雅地阅读rss订阅源</h2><p>rss 订阅在kindle的阅读方式主要分为两种，第一种就是将订阅源添加到指定的网站，然后该网站制作出符合kindle阅读习惯的页面，然后在kindle中用自带的浏览器打开。第二种就是将订阅的源的文本进行处理，然后将处理过后的文本整理成为文件，然后将文件推送到kindle，在kindle中阅读就是。</p><ol><li>inoreader。这是属于第一种方式 这同样是一款类似Google Reader的RSS阅读器 inoreader 独有的服务，针对kindle用户单独设计的一个在线阅读页面，让kindle用户也能优雅的享受到在线阅读的快感。reabble 却根据电子墨水屏单独设计了一个适合kindle阅读的页面，在页面全部是通过点击来完成RSS的阅读，体验非常棒，可以访问 reabble.com 使用 inoreader。</li><li>kindle4rss，狗耳朵等之类的都是这样的功能。kindle4rss 可以免费订阅12个订阅源然后每次手动推送，而狗耳朵都不能添加自己喜欢的rss。但是由于目前这方面的需求不是很大，所以就没有使用付费的用户，但是感觉付费的话两个都差不多，就是可以添加很多的rss源，然后在设置的时间自动推送到你的kindle，而不用手动去推送。值得一题的是这些第三方应用可以通过绑定一些第三方账号比如 feedly EverNote pocket之类的，从而实现推送第三方内容到自己的kindle。</li></ol><h2 id="论优雅地管理书籍"><a href="#论优雅地管理书籍" class="headerlink" title="论优雅地管理书籍"></a>论优雅地管理书籍</h2><ol><li>了解一款电子书的管理软件叫做 calibre，刚刚安上，还没怎么用，等用过之后再补。</li></ol><h2 id="论优雅地管理笔记"><a href="#论优雅地管理笔记" class="headerlink" title="论优雅地管理笔记"></a>论优雅地管理笔记</h2><ol><li>有一款笔记和单词管理软件叫做 kindle mate，也是还没怎么用，待评测。</li></ol><h2 id="其他的一些使用技巧"><a href="#其他的一些使用技巧" class="headerlink" title="其他的一些使用技巧"></a>其他的一些使用技巧</h2><ol><li>sdr清理软件。电子书阅读会产生很多的sdr文件，于是有了一款专门清理sdr的软件叫做 <a href="http://kindlefere.com/post/43.html">sdr-cleaner</a>。</li></ol><p>·11</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;嗯，在纠结了很久之后还是剁手了，包括机械键盘和kindle，现在还差一个显示器和一个ssd，加油吧，尽早把它们买回来。在此之前我要插播一个小广告-当然是给Kindle做广告。嗯，在我选择kindle之前，我做了很多的工作，因为很早之前就种了一棵kindle的草，然后前些时间我拿了同学的kpw2 看了看英文原版的电子书，感觉效果很是不错，然后我就下狠心要买一个电纸书，然后我要选择kindle的版本所以问了很多的同学有的使用的是 oasis，有的是 kpw，一个偶然的机会看到了一个前辈说到了文石的一款机器，之后逛了贴吧和淘宝感觉这个评价不是很高，但是我看那个前辈极力推荐这款设备而且又看了他的资料感觉应该可能靠谱，又鉴于文石的机器支持自定义剪裁，而且价格很是可以，顿时就对文石的机器产生了好感，很不幸的下单了一个文石的机器，机器到手后一个小时候我就毅然决定退掉这款机器，可能是自己的问题老师感觉那个机器的屏幕雾蒙蒙的，然后拿了同学的kpw2对比发现差距太明显了，而且有的时候还会有残影。所以还是退了，但是售后感觉态度还是不错的说，虽然稍微有点恼火。然后我就立马下单了一个 kpw3，希望老天保佑，所以在收货之前先做一把&lt;a href=&quot;http://www.zhihu.com/question/27741189&quot;&gt;功课&lt;/a&gt;，希望能借此有好运气。&lt;/p&gt;</summary>
    
    
    
    <category term="config" scheme="http://kangqingfei.cn/categories/config/"/>
    
    
    <category term="kindle" scheme="http://kangqingfei.cn/tags/kindle/"/>
    
  </entry>
  
</feed>
