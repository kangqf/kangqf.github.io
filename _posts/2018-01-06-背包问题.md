---
title: 背包问题
categories:
  - jobs
tags:
  - job
  - 背包问题
date: 2018-01-06 16:55:10
---

## 各类背包问题集锦
### 背包问题都是通过 **动态规划** 来求解的，在此之前需要了解[动态规划的相关知识](http://kangqingfei.cn)
### 网上有很好的参考资料：[背包问题九讲](http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/)，自己也是参考该资料入门的。

<!--more-->

### 下面列举一些刷题中遇到的实际的背包问题
1. 华为机试 16/108 题 -> 购物单
    ### 题目描述
    王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：
    主件	附件
    电脑	打印机，扫描仪
    书柜	图书
    书桌	台灯，文具
    工作椅	无
    如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
    设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：
    `v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ]` 。（其中 `*` 为乘号）
    请你帮助王强设计一个满足要求的购物单。
    ### 输入描述:
    输入的第 1 行，为两个正整数，用一个空格隔开：N m
    其中 N （ <32000 ）表示总钱数， m （ <60 ）为希望购买物品的个数。
    从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q
    其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号
    ### 输出描述:
    输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ <200000 ）。
    ### 示例1
    输入
    1000 5
    800 2 0
    400 5 1
    300 5 1
    400 3 0
    500 2 0
    输出
    2200

    ## 有依赖的背包问题： 将依赖转换为分组的背包问题，通过先后迭代 分组g 容量 v 每个分组中的条目 k 来求解最优解
``` cpp
#include <iostream>

using namespace std;

int getMax(int a, int b)
{
    return (a>b)?a:b;
}

int main()
{
    int c;//物品个数
    int N;//总钱数
    cin>>N>>c;

    N /= 10; //总钱数是10的倍数，先除以10 以节约空间

    const size_t num = c;
    const size_t money = N;

    //int price[num][3];//进行分组 事实上 num/3 <= 分组数 <= num 这里浪费了空间 clang++ 与 g++的不兼容的问题
    //int value[num][3];
    int price[61][3] = {0};
    int value[61][3] = {0};
    for(int h = 0; h < num; ++h)
    {
        for(int j = 0; j < 3; ++j)
        {
            price[h][j] = 0;
            value[h][j] = 0;
        }
    }

    int i,j,m,n;
    int v,p,q;

    j = 0;
    m = 0;
    n = 0;
    for(i = 0; i < num; ++i)
    {
        cin>>v>>p>>q;
        v /= 10;
        if(q == 0) //主件
        {
            ++j;
            price[j][0] = v;
            value[j][0] = v*p;
            n += m; //记录实际的分组号与q（总的物件数量）的差值
            m = 0;
        }
        else //附件
        {
            if(price[j][1] == 0)//第一个附件
            {
                price[q-n][1] = v;
                value[q-n][1] = v*p;
            }
            else//第二个附件
            {
                price[q-n][2] = v;
                value[q-n][2] = v*p;
            }
            m++;//附件个数计数,为了正确的分组，即当前主件有多少个附件
        }
    }

    const size_t group = j;

    //int dp[group+1][money+1];// 第i个分组 在使用j数量钱 的 最大收益
    int dp[61][3201] = {0};
    for(int j = 0; j <= group; ++j)
    	for(int k = 0; k <= money; ++k)
        {
            dp[j][k] = 0;
        }

    //进行动态规划
    for(int i = 1; i <= group; ++i)
    {
        for(int j = money; j > 0; --j)//从最大值开始，防止出现 j - price < 0
        {
            // 三个if就把分组的背包问题转换成了普通的背包问题
            if(j >= price[i][0])//只购买主件dp[i-1][j-price[i][0]] 为空出这么多钱的情况下的最大收益
                dp[i][j] = getMax(dp[i-1][j],dp[i-1][j-price[i][0]]+value[i][0]);
            if(j >= ( price[i][0] + price[i][1] ))//购买主件和1附件
                dp[i][j] = getMax(dp[i-1][j],dp[i-1][j-price[i][0] - price[i][1]]+value[i][0]+value[i][1]);
            if(j >= price[i][0] + price[i][1] + price[i][2])// 购买主件和 1,2 附件
                dp[i][j] = getMax(dp[i-1][j],dp[i-1][j-price[i][0] - price[i][1] - price[i][2]]+value[i][0]+value[i][1]+value[i][2]);
        }
    }
    cout<<10*dp[group][money]<<endl;
}

```

2. 背包问题2
