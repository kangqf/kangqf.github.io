---
title: LCS与编辑距离
categories:
  - jobs
tags:
  - 字符串
  - 动态规划
  - job
  - 编辑距离
date: 2018-02-04 16:02:09
---

## LCS(Longest Common Subsequence) 问题即最长公共子序列问题，就是两个字符串的 `子序列` 而不是 `子串` 的最大的长度。
之前的 LIS 问题也可以通过构造两个字符串来解决，一个是原串，一个是排序后的递增串，然后通过两个字符串求 LCS 的问题。

<!-- more -->

### 算法流程
* 设定 dp[i][j] 为str(0...i) 与 patten(0...j) 的最长子公共子序列的长度

1. 初始化 数组的 0 下标为零，然后更新 dp[i][j];
2. 若 `str[i] == patten[j]` 则`dp[i][j] = dp[i-1][j-1]`，若 `str[i] != patten[j]` 则 `dp[i][j] = max(dp[i][j-1],dp[i-1][j])`
3. 迭代更新 dp[i][j]

### 最长子序列输出
1. 若 `str[i] == patten[j]`，则输出 str[i] （导致反向输出）
2. 若 `str[i] != patten[j]`，则判断 dp[i][j] 是等于上方的(i--)还是下方的(j--)，然后移到该方向。

### 参考代码
``` cpp
// LCS 问题

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

void lcs(const string &str, const string &patten)
{
    const int strSize = str.length();
    const int pattenSize = patten.length();

    int dp[strSize+1][pattenSize+1] = {0};

    for(int i = 1; i <= strSize; ++i)
    {
        for(int j = 1; j <= pattenSize; ++j)
        {
            if(str[i-1] == patten[j-1])
            {
                dp[i][j] = dp[i-1][j-1] + 1;
            }
            else
            {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    int i = strSize;
    int j = pattenSize;
    vector<char> re;
    while(i > 0 && j > 0)
    {
        if(str[i-1] == patten[j-1])
        {
            re.push_back(str[i-1]);
            --i;
            --j;
        }
        else if(dp[i][j] == dp[i-1][j])
        {
            --i;
        }
        else if(dp[i][j] == dp[i][j-1])
        {
            --j;
        }
    }

    reverse(re.begin(),re.end());
    for(auto c:re)
    {
        cout<<c;
    }
    cout<<endl;

}

int main(int argc, char *argv[])
{
    string str = "kangqingfei";
    string patten = "ng";

    lcs(str,patten);

    return 0;
}

```

## 编辑距离问题(Edit Distance)
编辑距离和LCS很像，只是更新 dp[i][j] 的时候略有不同而已
### 算法流程
* 设定 dp[i][j] 为 str1(0...i) 与 str2(0...j) 的编辑距离

1. 初始化 dp[0][j] 和 dp[i][0] 为 j 和 i  其含义为，一个字符串与一个空串的编辑距离为字符串本身的长度
2. 更新dp[i][j],更新规则为，若 str1[i] == str2[j] 则dp[i][j] = dp[i-1][j-1] 若 str1[i] != str2[j] 则考虑 str1 不变，str2 可以通过 增加(dp[i-1][j] + 1) 删除(dp[i][j-1] + 1) 替换(dp[i-1][j-1] + 1) 变到str1
3. 迭代更新 dp[i][j], 输出dp[iMax][jMax] 即为编辑距离

### 参考代码
``` cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

editDistance(string str1, string str2)
{
    const int length1 = str1.length();
    const int length2 = str2.length();

    int dp[length1+1][length2+1] = {0};

    for(int i = 0; i <= length1; ++i)
    {
        dp[i][0] = i;
    }
    for(int i = 0; i <= length2; ++i)
    {
        dp[0][i] = i;
    }
    for(int i = 0; i <= length1; ++i)
    {
        for(int j = 0; j <= length2; ++j)
        {
            if(str1[i] == str2[j])
            {
                dp[i][j] = dp[i-1][j-1];
            }
            else
            {//                     增加       删除          替换
                dp[i][j] = min(min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;
            }
        }
    }
    cout<<dp[length1][length2]<<endl;

}

int main(int argc, char *argv[])
{
    string str1 = "kangqingfei";
    string str2 = "kangqingfeng";

    editDistance(str1,str2);

    return 0;
}
```




  士大夫
